/* automatically generated by rust-bindgen */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
}
impl <T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __BindgenUnionField<T> { }
impl <T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
pub const LIBCOUCHBASE_COUCHBASE_H: ::std::os::raw::c_uint = 1;
pub const LCB_CONFIG_MCD_PORT: ::std::os::raw::c_uint = 11210;
pub const LCB_CONFIG_MCD_SSL_PORT: ::std::os::raw::c_uint = 11207;
pub const LCB_CONFIG_HTTP_PORT: ::std::os::raw::c_uint = 8091;
pub const LCB_CONFIG_HTTP_SSL_PORT: ::std::os::raw::c_uint = 18091;
pub const LCB_CONFIG_MCCOMPAT_PORT: ::std::os::raw::c_uint = 11211;
pub const __DARWIN_ONLY_64_BIT_INO_T: ::std::os::raw::c_uint = 0;
pub const __DARWIN_ONLY_VERS_1050: ::std::os::raw::c_uint = 0;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: ::std::os::raw::c_uint = 1;
pub const __DARWIN_UNIX03: ::std::os::raw::c_uint = 1;
pub const __DARWIN_64_BIT_INO_T: ::std::os::raw::c_uint = 1;
pub const __DARWIN_VERS_1050: ::std::os::raw::c_uint = 1;
pub const __DARWIN_NON_CANCELABLE: ::std::os::raw::c_uint = 0;
pub const __DARWIN_SUF_64_BIT_INO_T: &'static [u8; 9usize] = b"$INODE64\x00";
pub const __DARWIN_SUF_1050: &'static [u8; 6usize] = b"$1050\x00";
pub const __DARWIN_SUF_EXTSN: &'static [u8; 14usize] = b"$DARWIN_EXTSN\x00";
pub const __DARWIN_C_ANSI: ::std::os::raw::c_uint = 4096;
pub const __DARWIN_C_FULL: ::std::os::raw::c_uint = 900000;
pub const __DARWIN_C_LEVEL: ::std::os::raw::c_uint = 900000;
pub const __STDC_WANT_LIB_EXT1__: ::std::os::raw::c_uint = 1;
pub const _DARWIN_FEATURE_64_BIT_INODE: ::std::os::raw::c_uint = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: ::std::os::raw::c_uint = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: ::std::os::raw::c_uint = 3;
pub const __PTHREAD_SIZE__: ::std::os::raw::c_uint = 8176;
pub const __PTHREAD_ATTR_SIZE__: ::std::os::raw::c_uint = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: ::std::os::raw::c_uint = 8;
pub const __PTHREAD_MUTEX_SIZE__: ::std::os::raw::c_uint = 56;
pub const __PTHREAD_CONDATTR_SIZE__: ::std::os::raw::c_uint = 8;
pub const __PTHREAD_COND_SIZE__: ::std::os::raw::c_uint = 40;
pub const __PTHREAD_ONCE_SIZE__: ::std::os::raw::c_uint = 8;
pub const __PTHREAD_RWLOCK_SIZE__: ::std::os::raw::c_uint = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: ::std::os::raw::c_uint = 16;
pub const __DARWIN_WCHAR_MIN: ::std::os::raw::c_int = -2147483648;
pub const _FORTIFY_SOURCE: ::std::os::raw::c_uint = 2;
pub const CLOCKS_PER_SEC: ::std::os::raw::c_uint = 1000000;
pub const __GNUC_VA_LIST: ::std::os::raw::c_uint = 1;
pub const __MAC_10_0: ::std::os::raw::c_uint = 1000;
pub const __MAC_10_1: ::std::os::raw::c_uint = 1010;
pub const __MAC_10_2: ::std::os::raw::c_uint = 1020;
pub const __MAC_10_3: ::std::os::raw::c_uint = 1030;
pub const __MAC_10_4: ::std::os::raw::c_uint = 1040;
pub const __MAC_10_5: ::std::os::raw::c_uint = 1050;
pub const __MAC_10_6: ::std::os::raw::c_uint = 1060;
pub const __MAC_10_7: ::std::os::raw::c_uint = 1070;
pub const __MAC_10_8: ::std::os::raw::c_uint = 1080;
pub const __MAC_10_9: ::std::os::raw::c_uint = 1090;
pub const __MAC_10_10: ::std::os::raw::c_uint = 101000;
pub const __MAC_10_10_2: ::std::os::raw::c_uint = 101002;
pub const __MAC_10_10_3: ::std::os::raw::c_uint = 101003;
pub const __MAC_10_11: ::std::os::raw::c_uint = 101100;
pub const __MAC_10_11_2: ::std::os::raw::c_uint = 101102;
pub const __MAC_10_11_3: ::std::os::raw::c_uint = 101103;
pub const __MAC_10_11_4: ::std::os::raw::c_uint = 101104;
pub const __IPHONE_2_0: ::std::os::raw::c_uint = 20000;
pub const __IPHONE_2_1: ::std::os::raw::c_uint = 20100;
pub const __IPHONE_2_2: ::std::os::raw::c_uint = 20200;
pub const __IPHONE_3_0: ::std::os::raw::c_uint = 30000;
pub const __IPHONE_3_1: ::std::os::raw::c_uint = 30100;
pub const __IPHONE_3_2: ::std::os::raw::c_uint = 30200;
pub const __IPHONE_4_0: ::std::os::raw::c_uint = 40000;
pub const __IPHONE_4_1: ::std::os::raw::c_uint = 40100;
pub const __IPHONE_4_2: ::std::os::raw::c_uint = 40200;
pub const __IPHONE_4_3: ::std::os::raw::c_uint = 40300;
pub const __IPHONE_5_0: ::std::os::raw::c_uint = 50000;
pub const __IPHONE_5_1: ::std::os::raw::c_uint = 50100;
pub const __IPHONE_6_0: ::std::os::raw::c_uint = 60000;
pub const __IPHONE_6_1: ::std::os::raw::c_uint = 60100;
pub const __IPHONE_7_0: ::std::os::raw::c_uint = 70000;
pub const __IPHONE_7_1: ::std::os::raw::c_uint = 70100;
pub const __IPHONE_8_0: ::std::os::raw::c_uint = 80000;
pub const __IPHONE_8_1: ::std::os::raw::c_uint = 80100;
pub const __IPHONE_8_2: ::std::os::raw::c_uint = 80200;
pub const __IPHONE_8_3: ::std::os::raw::c_uint = 80300;
pub const __IPHONE_8_4: ::std::os::raw::c_uint = 80400;
pub const __IPHONE_9_0: ::std::os::raw::c_uint = 90000;
pub const __IPHONE_9_1: ::std::os::raw::c_uint = 90100;
pub const __IPHONE_9_2: ::std::os::raw::c_uint = 90200;
pub const __IPHONE_9_3: ::std::os::raw::c_uint = 90300;
pub const __TVOS_9_0: ::std::os::raw::c_uint = 90000;
pub const __TVOS_9_1: ::std::os::raw::c_uint = 90100;
pub const __TVOS_9_2: ::std::os::raw::c_uint = 90200;
pub const __WATCHOS_1_0: ::std::os::raw::c_uint = 10000;
pub const __WATCHOS_2_0: ::std::os::raw::c_uint = 20000;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: ::std::os::raw::c_uint = 101104;
pub const __SLBF: ::std::os::raw::c_uint = 1;
pub const __SNBF: ::std::os::raw::c_uint = 2;
pub const __SRD: ::std::os::raw::c_uint = 4;
pub const __SWR: ::std::os::raw::c_uint = 8;
pub const __SRW: ::std::os::raw::c_uint = 16;
pub const __SEOF: ::std::os::raw::c_uint = 32;
pub const __SERR: ::std::os::raw::c_uint = 64;
pub const __SMBF: ::std::os::raw::c_uint = 128;
pub const __SAPP: ::std::os::raw::c_uint = 256;
pub const __SSTR: ::std::os::raw::c_uint = 512;
pub const __SOPT: ::std::os::raw::c_uint = 1024;
pub const __SNPT: ::std::os::raw::c_uint = 2048;
pub const __SOFF: ::std::os::raw::c_uint = 4096;
pub const __SMOD: ::std::os::raw::c_uint = 8192;
pub const __SALC: ::std::os::raw::c_uint = 16384;
pub const __SIGN: ::std::os::raw::c_uint = 32768;
pub const _IOFBF: ::std::os::raw::c_uint = 0;
pub const _IOLBF: ::std::os::raw::c_uint = 1;
pub const _IONBF: ::std::os::raw::c_uint = 2;
pub const BUFSIZ: ::std::os::raw::c_uint = 1024;
pub const EOF: ::std::os::raw::c_int = -1;
pub const FOPEN_MAX: ::std::os::raw::c_uint = 20;
pub const FILENAME_MAX: ::std::os::raw::c_uint = 1024;
pub const P_tmpdir: &'static [u8; 10usize] = b"/var/tmp/\x00";
pub const L_tmpnam: ::std::os::raw::c_uint = 1024;
pub const TMP_MAX: ::std::os::raw::c_uint = 308915776;
pub const SEEK_SET: ::std::os::raw::c_uint = 0;
pub const SEEK_CUR: ::std::os::raw::c_uint = 1;
pub const SEEK_END: ::std::os::raw::c_uint = 2;
pub const L_ctermid: ::std::os::raw::c_uint = 1024;
pub const __CTERMID_DEFINED: ::std::os::raw::c_uint = 1;
pub const _USE_FORTIFY_LEVEL: ::std::os::raw::c_uint = 2;
pub const _QUAD_HIGHWORD: ::std::os::raw::c_uint = 1;
pub const _QUAD_LOWWORD: ::std::os::raw::c_uint = 0;
pub const __DARWIN_LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const __DARWIN_BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const __DARWIN_PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const __DARWIN_BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const __DARWIN_FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const __DARWIN_NBBY: ::std::os::raw::c_uint = 8;
pub const NBBY: ::std::os::raw::c_uint = 8;
pub const FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const __WORDSIZE: ::std::os::raw::c_uint = 64;
pub const INT8_MAX: ::std::os::raw::c_uint = 127;
pub const INT16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const INT8_MIN: ::std::os::raw::c_int = -128;
pub const INT16_MIN: ::std::os::raw::c_int = -32768;
pub const INT32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const UINT8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT64_MAX: ::std::os::raw::c_int = -1;
pub const INT_LEAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_LEAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_LEAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_LEAST64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_LEAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_LEAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_LEAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT_LEAST64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_LEAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_LEAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_LEAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT_LEAST64_MAX: ::std::os::raw::c_int = -1;
pub const INT_FAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_FAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_FAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_FAST64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_FAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_FAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT_FAST64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_FAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_FAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_FAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT_FAST64_MAX: ::std::os::raw::c_int = -1;
pub const INTPTR_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTPTR_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTPTR_MAX: ::std::os::raw::c_int = -1;
pub const INTMAX_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTMAX_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTMAX_MAX: ::std::os::raw::c_int = -1;
pub const PTRDIFF_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const SIZE_MAX: ::std::os::raw::c_int = -1;
pub const RSIZE_MAX: ::std::os::raw::c_int = -1;
pub const WINT_MIN: ::std::os::raw::c_int = -2147483648;
pub const WINT_MAX: ::std::os::raw::c_uint = 2147483647;
pub const SIG_ATOMIC_MIN: ::std::os::raw::c_int = -2147483648;
pub const SIG_ATOMIC_MAX: ::std::os::raw::c_uint = 2147483647;
pub const LIBCOUCHBASE_ASSERT_H: ::std::os::raw::c_uint = 1;
pub const LIBCOUCHBASE_ERROR_H: ::std::os::raw::c_uint = 1;
pub const LCB__ERR_USEDETAILS: &'static [u8; 160usize] =
    b"Enable detailed error codes (via LCB_CNTL_DETAILED_ERRCODES, or via `detailed_errcodes` in the connection string) and/or enable logging to get more information\x00";
pub const LCB_READ_EVENT: ::std::os::raw::c_uint = 2;
pub const LCB_WRITE_EVENT: ::std::os::raw::c_uint = 4;
pub const LCB_ERROR_EVENT: ::std::os::raw::c_uint = 8;
pub const LCB_RW_EVENT: ::std::os::raw::c_uint = 6;
pub const LCB_IO_SOCKCHECK_PEND_IS_ERROR: ::std::os::raw::c_uint = 1;
pub const LCB_IO_SOCKCHECK_STATUS_CLOSED: ::std::os::raw::c_uint = 1;
pub const LCB_IO_SOCKCHECK_STATUS_OK: ::std::os::raw::c_uint = 0;
pub const LCB_IO_SOCKCHECK_STATUS_UNKNOWN: ::std::os::raw::c_int = -1;
pub const LCB_IO_CNTL_GET: ::std::os::raw::c_uint = 0;
pub const LCB_IO_CNTL_SET: ::std::os::raw::c_uint = 1;
pub const LCB_IO_CNTL_TCP_NODELAY: ::std::os::raw::c_uint = 1;
pub const LCB_IO_CNTL_TCP_KEEPALIVE: ::std::os::raw::c_uint = 2;
pub const LCB_IOPROCS_VERSION: ::std::os::raw::c_uint = 4;
pub const LIBCOUCHBASE_CONFIGURATION_H: ::std::os::raw::c_uint = 1;
pub const LCB_VERSION_STRING: &'static [u8; 6usize] = b"2.7.6\x00";
pub const LCB_VERSION: ::std::os::raw::c_uint = 132870;
pub const LCB_VERSION_CHANGESET: &'static [u8; 41usize] =
    b"e15b267765913f110fd1bbf65749c54b56875ebf\x00";
pub const LCB_CMD_F_INTERNAL_CALLBACK: ::std::os::raw::c_uint = 1;
pub const LCB_CMD_F_MULTIAUTH: ::std::os::raw::c_uint = 2;
pub const LCB_CALLBACK_VIEWQUERY: ::std::os::raw::c_int = -1;
pub const LCB_CALLBACK_N1QL: ::std::os::raw::c_int = -2;
pub const LCB_CALLBACK_IXMGMT: ::std::os::raw::c_int = -3;
pub const LCB_CMDGET_F_CLEAREXP: ::std::os::raw::c_uint = 65536;
pub const LCB_CMDENDURE_F_MUTATION_TOKEN: ::std::os::raw::c_uint = 65536;
pub const LCB_DURABILITY_VALIDATE_CAPMAX: ::std::os::raw::c_uint = 2;
pub const LCB_CMDOBSERVE_F_MASTER_ONLY: ::std::os::raw::c_uint = 65536;
pub const LCB_CMDSTATS_F_KV: ::std::os::raw::c_uint = 65536;
pub const LCB_CMDHTTP_F_STREAM: ::std::os::raw::c_uint = 65536;
pub const LCB_CMDHTTP_F_CASTMO: ::std::os::raw::c_uint = 131072;
pub const LCB_CMDHTTP_F_NOUPASS: ::std::os::raw::c_uint = 262144;
pub const LCB_DATATYPE_JSON: ::std::os::raw::c_uint = 1;
pub const LCB_GETNODE_UNAVAILABLE: &'static [u8; 15usize] =
    b"invalid_host:0\x00";
pub const LCB_SUPPORTS_SSL: ::std::os::raw::c_uint = 1;
pub const LCB_SUPPORTS_SNAPPY: ::std::os::raw::c_uint = 2;
pub const LCB_SDSPEC_F_MKINTERMEDIATES: ::std::os::raw::c_uint = 65536;
pub const LCB_SDSPEC_F_XATTRPATH: ::std::os::raw::c_uint = 262144;
pub const LCB_SDSPEC_F_XATTR_MACROVALUES: ::std::os::raw::c_uint = 524288;
pub const LCB_SDSPEC_F_XATTR_DELETED_OK: ::std::os::raw::c_uint = 1048576;
pub const LCB_SDMULTI_MODE_INVALID: ::std::os::raw::c_uint = 0;
pub const LCB_SDMULTI_MODE_LOOKUP: ::std::os::raw::c_uint = 1;
pub const LCB_SDMULTI_MODE_MUTATE: ::std::os::raw::c_uint = 2;
pub const LCB_CMDSUBDOC_F_UPSERT_DOC: ::std::os::raw::c_uint = 65536;
pub const LCB_CMDSUBDOC_F_INSERT_DOC: ::std::os::raw::c_uint = 131072;
pub const LCB_CMDSUBDOC_F_ACCESS_DELETED: ::std::os::raw::c_uint = 262144;
pub const LCB_CNTL_SET: ::std::os::raw::c_uint = 1;
pub const LCB_CNTL_GET: ::std::os::raw::c_uint = 0;
pub const LCB_CNTL_OP_TIMEOUT: ::std::os::raw::c_uint = 0;
pub const LCB_CNTL_VIEW_TIMEOUT: ::std::os::raw::c_uint = 1;
pub const LCB_CNTL_N1QL_TIMEOUT: ::std::os::raw::c_uint = 61;
pub const LCB_CNTL_BUCKETNAME: ::std::os::raw::c_uint = 48;
pub const LCB_CNTL_HANDLETYPE: ::std::os::raw::c_uint = 4;
pub const LCB_CNTL_VBCONFIG: ::std::os::raw::c_uint = 5;
pub const LCB_CNTL_IOPS: ::std::os::raw::c_uint = 6;
pub const LCB_CNTL_VBMAP: ::std::os::raw::c_uint = 7;
pub const LCB_CNTL_CONFERRTHRESH: ::std::os::raw::c_uint = 12;
pub const LCB_CNTL_DURABILITY_TIMEOUT: ::std::os::raw::c_uint = 13;
pub const LCB_CNTL_DURABILITY_INTERVAL: ::std::os::raw::c_uint = 14;
pub const LCB_CNTL_HTTP_TIMEOUT: ::std::os::raw::c_uint = 15;
pub const LCB_CNTL_IOPS_DLOPEN_DEBUG: ::std::os::raw::c_uint = 17;
pub const LCB_CNTL_CONFIGURATION_TIMEOUT: ::std::os::raw::c_uint = 18;
pub const LCB_CNTL_RANDOMIZE_BOOTSTRAP_HOSTS: ::std::os::raw::c_uint = 20;
pub const LCB_CNTL_CONFIG_CACHE_LOADED: ::std::os::raw::c_uint = 21;
pub const LCB_CNTL_FORCE_SASL_MECH: ::std::os::raw::c_uint = 22;
pub const LCB_CNTL_MAX_REDIRECTS: ::std::os::raw::c_uint = 23;
pub const LCB_CNTL_LOGGER: ::std::os::raw::c_uint = 24;
pub const LCB_CNTL_CONFDELAY_THRESH: ::std::os::raw::c_uint = 25;
pub const LCB_CNTL_CONFIG_TRANSPORT: ::std::os::raw::c_uint = 26;
pub const LCB_CNTL_CONFIG_NODE_TIMEOUT: ::std::os::raw::c_uint = 27;
pub const LCB_CNTL_HTCONFIG_IDLE_TIMEOUT: ::std::os::raw::c_uint = 28;
pub const LCB_CNTL_CHANGESET: ::std::os::raw::c_uint = 31;
pub const LCB_CNTL_CONFIGCACHE: ::std::os::raw::c_uint = 33;
pub const LCB_CNTL_CONFIGCACHE_RO: ::std::os::raw::c_uint = 54;
pub const LCB_CNTL_SSL_MODE: ::std::os::raw::c_uint = 34;
pub const LCB_CNTL_SSL_CERT: ::std::os::raw::c_uint = 35;
pub const LCB_CNTL_SSL_CACERT: ::std::os::raw::c_uint = 35;
pub const LCB_CNTL_RETRYMODE: ::std::os::raw::c_uint = 36;
pub const LCB_CNTL_HTCONFIG_URLTYPE: ::std::os::raw::c_uint = 37;
pub const LCB_CNTL_SYNCDESTROY: ::std::os::raw::c_uint = 40;
pub const LCB_CNTL_CONLOGGER_LEVEL: ::std::os::raw::c_uint = 41;
pub const LCB_CNTL_CONLOGGER_FP: ::std::os::raw::c_uint = 59;
pub const LCB_CNTL_DETAILED_ERRCODES: ::std::os::raw::c_uint = 42;
pub const LCB_CNTL_RETRY_INTERVAL: ::std::os::raw::c_uint = 44;
pub const LCB_CNTL_RETRY_BACKOFF: ::std::os::raw::c_uint = 45;
pub const LCB_CNTL_RETRY_NMV_IMM: ::std::os::raw::c_uint = 55;
pub const LCB_CNTL_HTTP_POOLSIZE: ::std::os::raw::c_uint = 46;
pub const LCB_CNTL_HTTP_REFRESH_CONFIG_ON_ERROR: ::std::os::raw::c_uint = 47;
pub const LCB_CNTL_SCHED_IMPLICIT_FLUSH: ::std::os::raw::c_uint = 49;
pub const LCB_CNTL_FETCH_MUTATION_TOKENS: ::std::os::raw::c_uint = 52;
pub const LCB_CNTL_DURABILITY_MUTATION_TOKENS: ::std::os::raw::c_uint = 53;
pub const LCB_CNTL_MUTATION_TOKENS_SUPPORTED: ::std::os::raw::c_uint = 56;
pub const LCB_CNTL_RESET_TIMEOUT_ON_WAIT: ::std::os::raw::c_uint = 58;
pub const LCB_CNTL_N1QL_CLEARACHE: ::std::os::raw::c_uint = 62;
pub const LCB_CNTL_CLIENT_STRING: ::std::os::raw::c_uint = 63;
pub const LCB_CNTL_BUCKET_CRED: ::std::os::raw::c_uint = 64;
pub const LCB_CNTL_RETRY_NMV_INTERVAL: ::std::os::raw::c_uint = 65;
pub const LCB_CNTL_READ_CHUNKSIZE: ::std::os::raw::c_uint = 66;
pub const LCB_CNTL_ENABLE_ERRMAP: ::std::os::raw::c_uint = 67;
pub const LCB_CNTL_SELECT_BUCKET: ::std::os::raw::c_uint = 68;
pub const LCB_CNTL_TCP_KEEPALIVE: ::std::os::raw::c_uint = 69;
pub const LCB_CNTL_CONFIG_POLL_INTERVAL: ::std::os::raw::c_uint = 70;
pub const LCB_CNTL_SEND_HELLO: ::std::os::raw::c_uint = 71;
pub const LCB_CNTL__MAX: ::std::os::raw::c_uint = 72;
pub const LCB_CNTL_MEMDNODE_INFO: ::std::os::raw::c_uint = 8;
pub const LCB_CNTL_CONFIGNODE_INFO: ::std::os::raw::c_uint = 9;
pub const LCB_CNTL_IOPS_DEFAULT_TYPES: ::std::os::raw::c_uint = 16;
pub const LCB_CNTL_CONFIG_HTTP_NODES: ::std::os::raw::c_uint = 29;
pub const LCB_CNTL_CONFIG_CCCP_NODES: ::std::os::raw::c_uint = 30;
pub const LCB_CNTL_CONFIG_ALL_NODES: ::std::os::raw::c_uint = 32;
pub const LCB_CNTL_REINIT_CONNSTR: ::std::os::raw::c_uint = 43;
pub const LCB_CNTL_COMPRESSION_OPTS: ::std::os::raw::c_uint = 38;
pub const LCB_CNTL_RDBALLOCFACTORY: ::std::os::raw::c_uint = 39;
pub const LCB_CNTL_IP6POLICY: ::std::os::raw::c_uint = 11;
pub const LCB_CNTL_VBGUESS_PERSIST: ::std::os::raw::c_uint = 50;
pub const LCB_CNTL_UNSAFE_OPTIMIZE: ::std::os::raw::c_uint = 51;
pub const LCB_CNTL_TCP_NODELAY: ::std::os::raw::c_uint = 57;
pub const LCB_CNTL_KVTIMINGS: ::std::os::raw::c_uint = 60;
pub const LCB_CNTL_RBUFSIZE: ::std::os::raw::c_uint = 2;
pub const LCB_CNTL_WBUFSIZE: ::std::os::raw::c_uint = 3;
pub const LCB_CNTL_SYNCMODE: ::std::os::raw::c_uint = 10;
pub const LCB_CNTL_SKIP_CONFIGURATION_ERRORS_ON_CONNECT:
          ::std::os::raw::c_uint =
    19;
pub const LCB_N1P_QUERY_STATEMENT: ::std::os::raw::c_uint = 1;
pub const LCB_N1P_QUERY_PREPARED: ::std::os::raw::c_uint = 2;
pub const LCB_N1P_CONSISTENCY_NONE: ::std::os::raw::c_uint = 0;
pub const LCB_N1P_CONSISTENCY_RYOW: ::std::os::raw::c_uint = 1;
pub const LCB_N1P_CONSISTENCY_REQUEST: ::std::os::raw::c_uint = 2;
pub const LCB_N1P_CONSISTENCY_STATEMENT: ::std::os::raw::c_uint = 3;
pub const LCB_CMDN1QL_F_PREPCACHE: ::std::os::raw::c_uint = 65536;
pub const LCB_CMDN1QL_F_JSONQUERY: ::std::os::raw::c_uint = 131072;
pub const LCB_CMDN1QL_F_CBASQUERY: ::std::os::raw::c_uint = 262144;
pub const LCB_CMDVIEWQUERY_F_INCLUDE_DOCS: ::std::os::raw::c_uint = 65536;
pub const LCB_CMDVIEWQUERY_F_NOROWPARSE: ::std::os::raw::c_uint = 131072;
pub const LCB_CMDVIEWQUERY_F_SPATIAL: ::std::os::raw::c_uint = 262144;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lcb_st {
    _unused: [u8; 0],
}
pub type lcb_t = *mut lcb_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lcb_http_request_st {
    _unused: [u8; 0],
}
pub type lcb_http_request_t = *mut lcb_http_request_st;
pub type wchar_t = ::std::os::raw::c_int;
pub type max_align_t = f64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __mbstate_t {
    pub __mbstate8: __BindgenUnionField<[::std::os::raw::c_char; 128usize]>,
    pub _mbstateL: __BindgenUnionField<::std::os::raw::c_longlong>,
    pub bindgen_union_field: [u64; 16usize],
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(::std::mem::size_of::<__mbstate_t>() , 128usize , concat ! (
               "Size of: " , stringify ! ( __mbstate_t ) ));
    assert_eq! (::std::mem::align_of::<__mbstate_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __mbstate_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . __mbstate8 as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( __mbstate8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . _mbstateL as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( _mbstateL ) ));
}
impl Clone for __mbstate_t {
    fn clone(&self) -> Self { *self }
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    assert_eq!(::std::mem::size_of::<__darwin_pthread_handler_rec>() , 24usize
               , concat ! (
               "Size of: " , stringify ! ( __darwin_pthread_handler_rec ) ));
    assert_eq! (::std::mem::align_of::<__darwin_pthread_handler_rec>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( __darwin_pthread_handler_rec )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_pthread_handler_rec ) ) .
                __routine as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_pthread_handler_rec ) , "::" , stringify ! (
                __routine ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_pthread_handler_rec ) ) . __arg
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_pthread_handler_rec ) , "::" , stringify ! ( __arg )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_pthread_handler_rec ) ) . __next
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_pthread_handler_rec ) , "::" , stringify ! ( __next )
                ));
}
impl Clone for __darwin_pthread_handler_rec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_attr_t>() , 64usize ,
               concat ! ( "Size of: " , stringify ! ( _opaque_pthread_attr_t )
               ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_attr_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_attr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_attr_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_attr_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_attr_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_attr_t
                ) , "::" , stringify ! ( __opaque ) ));
}
#[repr(C)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_cond_t>() , 48usize ,
               concat ! ( "Size of: " , stringify ! ( _opaque_pthread_cond_t )
               ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_cond_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_cond_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_cond_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_cond_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_cond_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_cond_t
                ) , "::" , stringify ! ( __opaque ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_condattr_t>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_condattr_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_condattr_t>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_condattr_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_condattr_t ) ) . __sig as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_condattr_t ) , "::" , stringify ! ( __sig )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_condattr_t ) ) . __opaque
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_condattr_t ) , "::" , stringify ! ( __opaque )
                ));
}
impl Clone for _opaque_pthread_condattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_mutex_t>() , 64usize ,
               concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_mutex_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_mutex_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_mutex_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutex_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_mutex_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutex_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_mutex_t
                ) , "::" , stringify ! ( __opaque ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_mutexattr_t>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_mutexattr_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_mutexattr_t>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_mutexattr_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutexattr_t ) ) . __sig
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_mutexattr_t ) , "::" , stringify ! ( __sig )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutexattr_t ) ) .
                __opaque as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_mutexattr_t ) , "::" , stringify ! ( __opaque
                ) ));
}
impl Clone for _opaque_pthread_mutexattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_once_t>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( _opaque_pthread_once_t )
               ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_once_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_once_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_once_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_once_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_once_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_once_t
                ) , "::" , stringify ! ( __opaque ) ));
}
impl Clone for _opaque_pthread_once_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_rwlock_t>() , 200usize ,
               concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_rwlock_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_rwlock_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_rwlock_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlock_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlock_t ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlock_t ) ) . __opaque
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlock_t ) , "::" , stringify ! ( __opaque )
                ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_rwlockattr_t>() , 24usize
               , concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_rwlockattr_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_rwlockattr_t>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_rwlockattr_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlockattr_t ) ) . __sig
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlockattr_t ) , "::" , stringify ! ( __sig )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlockattr_t ) ) .
                __opaque as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlockattr_t ) , "::" , stringify ! ( __opaque
                ) ));
}
impl Clone for _opaque_pthread_rwlockattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_t>() , 8192usize , concat
               ! ( "Size of: " , stringify ! ( _opaque_pthread_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_t>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( _opaque_pthread_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_t ) ) . __sig as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_t ) ,
                "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_t ) ) . __cleanup_stack
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_t ) ,
                "::" , stringify ! ( __cleanup_stack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_t ) ) . __opaque as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_t ) ,
                "::" , stringify ! ( __opaque ) ));
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
pub type clock_t = __darwin_clock_t;
pub type time_t = __darwin_time_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timespec {
    pub tv_sec: __darwin_time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(::std::mem::size_of::<timespec>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timespec ) ));
    assert_eq! (::std::mem::align_of::<timespec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timespec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_nsec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_nsec ) ));
}
impl Clone for timespec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(::std::mem::size_of::<tm>() , 56usize , concat ! (
               "Size of: " , stringify ! ( tm ) ));
    assert_eq! (::std::mem::align_of::<tm>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( tm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_sec as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_min as * const _ as usize } ,
                4usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_min ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_hour as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_hour ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_mday as * const _ as usize }
                , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_mday ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_mon as * const _ as usize } ,
                16usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_mon ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_year as * const _ as usize }
                , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_year ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_wday as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_wday ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_yday as * const _ as usize }
                , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_yday ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_isdst as * const _ as usize }
                , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_isdst ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_gmtoff as * const _ as usize
                } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_gmtoff ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tm ) ) . tm_zone as * const _ as usize }
                , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( tm ) , "::" , stringify
                ! ( tm_zone ) ));
}
impl Clone for tm {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "tzname"]
    pub static mut tzname: [*mut ::std::os::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "getdate_err"]
    pub static mut getdate_err: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "timezone"]
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "daylight"]
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub fn asctime(arg1: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn ctime(arg1: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn difftime(arg1: time_t, arg2: time_t) -> f64;
}
extern "C" {
    pub fn getdate(arg1: *const ::std::os::raw::c_char) -> *mut tm;
}
extern "C" {
    pub fn gmtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn mktime(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(arg1: *mut ::std::os::raw::c_char, arg2: usize,
                    arg3: *const ::std::os::raw::c_char, arg4: *const tm)
     -> usize;
}
extern "C" {
    pub fn strptime(arg1: *const ::std::os::raw::c_char,
                    arg2: *const ::std::os::raw::c_char, arg3: *mut tm)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn time(arg1: *mut time_t) -> time_t;
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub fn asctime_r(arg1: *const tm, arg2: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(arg1: *const time_t, arg2: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gmtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn posix2time(arg1: time_t) -> time_t;
}
extern "C" {
    pub fn tzsetwall();
}
extern "C" {
    pub fn time2posix(arg1: time_t) -> time_t;
}
extern "C" {
    pub fn timelocal(arg1: *const tm) -> time_t;
}
extern "C" {
    pub fn timegm(arg1: *const tm) -> time_t;
}
extern "C" {
    pub fn nanosleep(arg1: *const timespec, arg2: *mut timespec)
     -> ::std::os::raw::c_int;
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
extern "C" {
    pub fn renameat(arg1: ::std::os::raw::c_int,
                    arg2: *const ::std::os::raw::c_char,
                    arg3: ::std::os::raw::c_int,
                    arg4: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
pub type fpos_t = __darwin_off_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __sbuf {
    pub _base: *mut ::std::os::raw::c_uchar,
    pub _size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    assert_eq!(::std::mem::size_of::<__sbuf>() , 16usize , concat ! (
               "Size of: " , stringify ! ( __sbuf ) ));
    assert_eq! (::std::mem::align_of::<__sbuf>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __sbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sbuf ) ) . _base as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sbuf ) , "::" ,
                stringify ! ( _base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sbuf ) ) . _size as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __sbuf ) , "::" ,
                stringify ! ( _size ) ));
}
impl Clone for __sbuf {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILEX {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __sFILE {
    pub _p: *mut ::std::os::raw::c_uchar,
    pub _r: ::std::os::raw::c_int,
    pub _w: ::std::os::raw::c_int,
    pub _flags: ::std::os::raw::c_short,
    pub _file: ::std::os::raw::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::std::os::raw::c_int,
    pub _cookie: *mut ::std::os::raw::c_void,
    pub _close: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                               *mut ::std::os::raw::c_void)
                                          -> ::std::os::raw::c_int>,
    pub _read: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                              *mut ::std::os::raw::c_void,
                                                          arg2:
                                                              *mut ::std::os::raw::c_char,
                                                          arg3:
                                                              ::std::os::raw::c_int)
                                         -> ::std::os::raw::c_int>,
    pub _seek: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                              *mut ::std::os::raw::c_void,
                                                          arg2: fpos_t,
                                                          arg3:
                                                              ::std::os::raw::c_int)
                                         -> fpos_t>,
    pub _write: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                               *mut ::std::os::raw::c_void,
                                                           arg2:
                                                               *const ::std::os::raw::c_char,
                                                           arg3:
                                                               ::std::os::raw::c_int)
                                          -> ::std::os::raw::c_int>,
    pub _ub: __sbuf,
    pub _extra: *mut __sFILEX,
    pub _ur: ::std::os::raw::c_int,
    pub _ubuf: [::std::os::raw::c_uchar; 3usize],
    pub _nbuf: [::std::os::raw::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::std::os::raw::c_int,
    pub _offset: fpos_t,
}
#[test]
fn bindgen_test_layout___sFILE() {
    assert_eq!(::std::mem::size_of::<__sFILE>() , 152usize , concat ! (
               "Size of: " , stringify ! ( __sFILE ) ));
    assert_eq! (::std::mem::align_of::<__sFILE>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __sFILE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _p as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _p ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _r as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _r ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _w as * const _ as usize }
                , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _w ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _flags as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _file as * const _ as usize
                } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _file ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _bf as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _bf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _lbfsize as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _lbfsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _cookie as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _cookie ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _close as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _close ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _read as * const _ as usize
                } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _read ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _seek as * const _ as usize
                } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _seek ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _write as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _write ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _ub as * const _ as usize }
                , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _ub ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _extra as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _extra ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _ur as * const _ as usize }
                , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _ur ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _ubuf as * const _ as usize
                } , 116usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _ubuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _nbuf as * const _ as usize
                } , 119usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _nbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _lb as * const _ as usize }
                , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _lb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _blksize as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _blksize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sFILE ) ) . _offset as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( __sFILE ) , "::" ,
                stringify ! ( _offset ) ));
}
impl Clone for __sFILE {
    fn clone(&self) -> Self { *self }
}
pub type FILE = __sFILE;
extern "C" {
    #[link_name = "__stdinp"]
    pub static mut __stdinp: *mut FILE;
}
extern "C" {
    #[link_name = "__stdoutp"]
    pub static mut __stdoutp: *mut FILE;
}
extern "C" {
    #[link_name = "__stderrp"]
    pub static mut __stderrp: *mut FILE;
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(arg1: *mut ::std::os::raw::c_char,
                 arg2: ::std::os::raw::c_int, arg3: *mut FILE)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fopen(arg1: *const ::std::os::raw::c_char,
                 arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fprintf(arg1: *mut FILE, arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const ::std::os::raw::c_char, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(arg1: *mut ::std::os::raw::c_void, arg2: usize, arg3: usize,
                 arg4: *mut FILE) -> usize;
}
extern "C" {
    pub fn freopen(arg1: *const ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char, arg3: *mut FILE)
     -> *mut FILE;
}
extern "C" {
    pub fn fscanf(arg1: *mut FILE, arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseek(arg1: *mut FILE, arg2: ::std::os::raw::c_long,
                 arg3: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fwrite(arg1: *const ::std::os::raw::c_void, arg2: usize,
                  arg3: usize, arg4: *mut FILE) -> usize;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn perror(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn printf(arg1: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(arg1: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(arg1: *const ::std::os::raw::c_char,
                  arg2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn scanf(arg1: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char,
                   arg3: ::std::os::raw::c_int, arg4: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(arg1: *mut ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(arg1: *const ::std::os::raw::c_char,
                  arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ungetc(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(arg1: *mut FILE, arg2: *const ::std::os::raw::c_char,
                    arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(arg1: *const ::std::os::raw::c_char,
                   arg2: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(arg1: *mut ::std::os::raw::c_char,
                    arg2: *const ::std::os::raw::c_char,
                    arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(arg1: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fdopen(arg1: ::std::os::raw::c_int,
                  arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(arg1: *const ::std::os::raw::c_char,
                 arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn __srget(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __svfscanf(arg1: *mut FILE, arg2: *const ::std::os::raw::c_char,
                      arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __swbuf(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(arg1: ::std::os::raw::c_int, arg2: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tempnam(arg1: *const ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
pub type off_t = __darwin_off_t;
extern "C" {
    pub fn fseeko(arg1: *mut FILE, arg2: off_t, arg3: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(arg1: *mut FILE) -> off_t;
}
extern "C" {
    pub fn snprintf(arg1: *mut ::std::os::raw::c_char, arg2: usize,
                    arg3: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(arg1: *mut FILE, arg2: *const ::std::os::raw::c_char,
                   arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(arg1: *const ::std::os::raw::c_char,
                  arg2: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(arg1: *mut ::std::os::raw::c_char, arg2: usize,
                     arg3: *const ::std::os::raw::c_char,
                     arg4: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(arg1: *const ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char,
                   arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(arg1: ::std::os::raw::c_int,
                   arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(arg1: ::std::os::raw::c_int,
                    arg2: *const ::std::os::raw::c_char,
                    arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdelim(arg1: *mut *mut ::std::os::raw::c_char, arg2: *mut usize,
                    arg3: ::std::os::raw::c_int, arg4: *mut FILE) -> isize;
}
extern "C" {
    pub fn getline(arg1: *mut *mut ::std::os::raw::c_char, arg2: *mut usize,
                   arg3: *mut FILE) -> isize;
}
extern "C" {
    #[link_name = "sys_nerr"]
    pub static sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "sys_errlist"]
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn asprintf(arg1: *mut *mut ::std::os::raw::c_char,
                    arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid_r(arg1: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fgetln(arg1: *mut FILE, arg2: *mut usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fmtcheck(arg1: *const ::std::os::raw::c_char,
                    arg2: *const ::std::os::raw::c_char)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char,
                     arg3: ::std::os::raw::c_int);
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(arg1: *mut *mut ::std::os::raw::c_char,
                     arg2: *const ::std::os::raw::c_char,
                     arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zopen(arg1: *const ::std::os::raw::c_char,
                 arg2: *const ::std::os::raw::c_char,
                 arg3: ::std::os::raw::c_int) -> *mut FILE;
}
extern "C" {
    pub fn funopen(arg1: *const ::std::os::raw::c_void,
                   arg2:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void,
                                                                  arg2:
                                                                      *mut ::std::os::raw::c_char,
                                                                  arg3:
                                                                      ::std::os::raw::c_int)
                                                 -> ::std::os::raw::c_int>,
                   arg3:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void,
                                                                  arg2:
                                                                      *const ::std::os::raw::c_char,
                                                                  arg3:
                                                                      ::std::os::raw::c_int)
                                                 -> ::std::os::raw::c_int>,
                   arg4:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void,
                                                                  arg2:
                                                                      fpos_t,
                                                                  arg3:
                                                                      ::std::os::raw::c_int)
                                                 -> fpos_t>,
                   arg5:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void)
                                                 -> ::std::os::raw::c_int>)
     -> *mut FILE;
}
extern "C" {
    pub fn __sprintf_chk(arg1: *mut ::std::os::raw::c_char,
                         arg2: ::std::os::raw::c_int, arg3: usize,
                         arg4: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __snprintf_chk(arg1: *mut ::std::os::raw::c_char, arg2: usize,
                          arg3: ::std::os::raw::c_int, arg4: usize,
                          arg5: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsprintf_chk(arg1: *mut ::std::os::raw::c_char,
                          arg2: ::std::os::raw::c_int, arg3: usize,
                          arg4: *const ::std::os::raw::c_char,
                          arg5: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsnprintf_chk(arg1: *mut ::std::os::raw::c_char, arg2: usize,
                           arg3: ::std::os::raw::c_int, arg4: usize,
                           arg5: *const ::std::os::raw::c_char,
                           arg6: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type u_long = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_quad_t = u_int64_t;
pub type quad_t = i64;
pub type qaddr_t = *mut quad_t;
pub type caddr_t = *mut ::std::os::raw::c_char;
pub type daddr_t = i32;
pub type dev_t = __darwin_dev_t;
pub type fixpt_t = u_int32_t;
pub type blkcnt_t = __darwin_blkcnt_t;
pub type blksize_t = __darwin_blksize_t;
pub type gid_t = __darwin_gid_t;
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type ino_t = __darwin_ino_t;
pub type ino64_t = __darwin_ino64_t;
pub type key_t = __int32_t;
pub type mode_t = __darwin_mode_t;
pub type nlink_t = __uint16_t;
pub type id_t = __darwin_id_t;
pub type pid_t = __darwin_pid_t;
pub type segsz_t = i32;
pub type swblk_t = i32;
pub type uid_t = __darwin_uid_t;
pub type useconds_t = __darwin_useconds_t;
pub type suseconds_t = __darwin_suseconds_t;
pub type rsize_t = __darwin_size_t;
pub type errno_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct fd_set {
    pub fds_bits: [__int32_t; 32usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(::std::mem::size_of::<fd_set>() , 128usize , concat ! (
               "Size of: " , stringify ! ( fd_set ) ));
    assert_eq! (::std::mem::align_of::<fd_set>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( fd_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fd_set ) ) . fds_bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( fd_set ) , "::" ,
                stringify ! ( fds_bits ) ));
}
impl Clone for fd_set {
    fn clone(&self) -> Self { *self }
}
pub type fd_mask = __int32_t;
pub type pthread_attr_t = __darwin_pthread_attr_t;
pub type pthread_cond_t = __darwin_pthread_cond_t;
pub type pthread_condattr_t = __darwin_pthread_condattr_t;
pub type pthread_mutex_t = __darwin_pthread_mutex_t;
pub type pthread_mutexattr_t = __darwin_pthread_mutexattr_t;
pub type pthread_once_t = __darwin_pthread_once_t;
pub type pthread_rwlock_t = __darwin_pthread_rwlock_t;
pub type pthread_rwlockattr_t = __darwin_pthread_rwlockattr_t;
pub type pthread_t = __darwin_pthread_t;
pub type pthread_key_t = __darwin_pthread_key_t;
pub type fsblkcnt_t = __darwin_fsblkcnt_t;
pub type fsfilcnt_t = __darwin_fsfilcnt_t;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type lcb_int64_t = i64;
pub type lcb_int32_t = i32;
pub type lcb_size_t = usize;
pub type lcb_ssize_t = isize;
pub type lcb_vbucket_t = u16;
pub type lcb_uint8_t = u8;
pub type lcb_uint16_t = u16;
pub type lcb_uint32_t = u32;
pub type lcb_cas_t = u64;
pub type lcb_uint64_t = u64;
pub type lcb_time_t = time_t;
pub type lcb_S64 = lcb_int64_t;
pub type lcb_U64 = lcb_uint64_t;
pub type lcb_U32 = lcb_uint32_t;
pub type lcb_S32 = lcb_int32_t;
pub type lcb_U16 = lcb_uint16_t;
pub type lcb_U8 = lcb_uint8_t;
pub type lcb_SIZE = lcb_size_t;
pub type lcb_SSIZE = lcb_ssize_t;
pub type lcb_SECS = lcb_time_t;
pub type lcb_CAS = lcb_cas_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum lcb_errflags_t {
    LCB_ERRTYPE_INPUT = 1,
    LCB_ERRTYPE_NETWORK = 2,
    LCB_ERRTYPE_FATAL = 4,
    LCB_ERRTYPE_TRANSIENT = 8,
    LCB_ERRTYPE_DATAOP = 16,
    LCB_ERRTYPE_INTERNAL = 32,
    LCB_ERRTYPE_PLUGIN = 64,
    LCB_ERRTYPE_SRVLOAD = 128,
    LCB_ERRTYPE_SRVGEN = 256,
    LCB_ERRTYPE_SUBDOC = 512,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum lcb_error_t {
    LCB_SUCCESS = 0,
    LCB_AUTH_CONTINUE = 1,
    LCB_AUTH_ERROR = 2,
    LCB_DELTA_BADVAL = 3,
    LCB_E2BIG = 4,
    LCB_EBUSY = 5,
    LCB_EINTERNAL = 6,
    LCB_EINVAL = 7,
    LCB_ENOMEM = 8,
    LCB_ERANGE = 9,
    LCB_ERROR = 10,
    LCB_ETMPFAIL = 11,
    LCB_KEY_EEXISTS = 12,
    LCB_KEY_ENOENT = 13,
    LCB_DLOPEN_FAILED = 14,
    LCB_DLSYM_FAILED = 15,
    LCB_NETWORK_ERROR = 16,
    LCB_NOT_MY_VBUCKET = 17,
    LCB_NOT_STORED = 18,
    LCB_NOT_SUPPORTED = 19,
    LCB_UNKNOWN_COMMAND = 20,
    LCB_UNKNOWN_HOST = 21,
    LCB_PROTOCOL_ERROR = 22,
    LCB_ETIMEDOUT = 23,
    LCB_CONNECT_ERROR = 24,
    LCB_BUCKET_ENOENT = 25,
    LCB_CLIENT_ENOMEM = 26,
    LCB_CLIENT_ENOCONF = 27,
    LCB_EBADHANDLE = 28,
    LCB_SERVER_BUG = 29,
    LCB_PLUGIN_VERSION_MISMATCH = 30,
    LCB_INVALID_HOST_FORMAT = 31,
    LCB_INVALID_CHAR = 32,
    LCB_DURABILITY_ETOOMANY = 33,
    LCB_DUPLICATE_COMMANDS = 34,
    LCB_NO_MATCHING_SERVER = 35,
    LCB_BAD_ENVIRONMENT = 36,
    LCB_BUSY = 37,
    LCB_INVALID_USERNAME = 38,
    LCB_CONFIG_CACHE_INVALID = 39,
    LCB_SASLMECH_UNAVAILABLE = 40,
    LCB_TOO_MANY_REDIRECTS = 41,
    LCB_MAP_CHANGED = 42,
    LCB_INCOMPLETE_PACKET = 43,
    LCB_ECONNREFUSED = 44,
    LCB_ESOCKSHUTDOWN = 45,
    LCB_ECONNRESET = 46,
    LCB_ECANTGETPORT = 47,
    LCB_EFDLIMITREACHED = 48,
    LCB_ENETUNREACH = 49,
    LCB_ECTL_UNKNOWN = 50,
    LCB_ECTL_UNSUPPMODE = 51,
    LCB_ECTL_BADARG = 52,
    LCB_EMPTY_KEY = 53,
    LCB_SSL_ERROR = 54,
    LCB_SSL_CANTVERIFY = 55,
    LCB_SCHEDFAIL_INTERNAL = 56,
    LCB_CLIENT_FEATURE_UNAVAILABLE = 57,
    LCB_OPTIONS_CONFLICT = 58,
    LCB_HTTP_ERROR = 59,
    LCB_DURABILITY_NO_MUTATION_TOKENS = 60,
    LCB_UNKNOWN_MEMCACHED_ERROR = 61,
    LCB_MUTATION_LOST = 62,
    LCB_SUBDOC_PATH_ENOENT = 63,
    LCB_SUBDOC_PATH_MISMATCH = 64,
    LCB_SUBDOC_PATH_EINVAL = 65,
    LCB_SUBDOC_PATH_E2BIG = 66,
    LCB_SUBDOC_DOC_E2DEEP = 67,
    LCB_SUBDOC_VALUE_CANTINSERT = 68,
    LCB_SUBDOC_DOC_NOTJSON = 69,
    LCB_SUBDOC_NUM_ERANGE = 70,
    LCB_SUBDOC_BAD_DELTA = 71,
    LCB_SUBDOC_PATH_EEXISTS = 72,
    LCB_SUBDOC_MULTI_FAILURE = 73,
    LCB_SUBDOC_VALUE_E2DEEP = 74,
    LCB_EINVAL_MCD = 75,
    LCB_EMPTY_PATH = 76,
    LCB_UNKNOWN_SDCMD = 77,
    LCB_ENO_COMMANDS = 78,
    LCB_QUERY_ERROR = 79,
    LCB_GENERIC_TMPERR = 80,
    LCB_GENERIC_SUBDOCERR = 81,
    LCB_GENERIC_CONSTRAINT_ERR = 82,
    LCB_NAMESERVER_ERROR = 83,
    LCB_NOT_AUTHORIZED = 84,
    LCB_MAX_ERROR = 4096,
}
extern "C" {
    pub fn lcb_get_errtype(err: lcb_error_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcb_strerror(instance: lcb_t, error: lcb_error_t)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn lcb_strerror_short(error: lcb_error_t)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn lcb_errmap_default(instance: lcb_t, code: lcb_U16) -> lcb_error_t;
}
pub type lcb_errmap_callback =
    ::std::option::Option<unsafe extern "C" fn(instance: lcb_t,
                                               bincode: lcb_U16)
                              -> lcb_error_t>;
extern "C" {
    pub fn lcb_set_errmap_callback(arg1: lcb_t, arg2: lcb_errmap_callback)
     -> lcb_errmap_callback;
}
pub type lcb_socket_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_iovec_st {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: usize,
}
#[test]
fn bindgen_test_layout_lcb_iovec_st() {
    assert_eq!(::std::mem::size_of::<lcb_iovec_st>() , 16usize , concat ! (
               "Size of: " , stringify ! ( lcb_iovec_st ) ));
    assert_eq! (::std::mem::align_of::<lcb_iovec_st>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_iovec_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_iovec_st ) ) . iov_base as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_iovec_st ) , "::" ,
                stringify ! ( iov_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_iovec_st ) ) . iov_len as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_iovec_st ) , "::" ,
                stringify ! ( iov_len ) ));
}
impl Clone for lcb_iovec_st {
    fn clone(&self) -> Self { *self }
}
pub type lcb_IOV = lcb_iovec_st;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_nameinfo_st {
    pub local: lcb_nameinfo_st__bindgen_ty_1,
    pub remote: lcb_nameinfo_st__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_nameinfo_st__bindgen_ty_1 {
    pub name: *mut sockaddr,
    pub len: *mut ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_lcb_nameinfo_st__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<lcb_nameinfo_st__bindgen_ty_1>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( lcb_nameinfo_st__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<lcb_nameinfo_st__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_nameinfo_st__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_nameinfo_st__bindgen_ty_1 ) ) . name
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_nameinfo_st__bindgen_ty_1 ) , "::" , stringify ! ( name )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_nameinfo_st__bindgen_ty_1 ) ) . len
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_nameinfo_st__bindgen_ty_1 ) , "::" , stringify ! ( len )
                ));
}
impl Clone for lcb_nameinfo_st__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_nameinfo_st__bindgen_ty_2 {
    pub name: *mut sockaddr,
    pub len: *mut ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_lcb_nameinfo_st__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<lcb_nameinfo_st__bindgen_ty_2>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( lcb_nameinfo_st__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<lcb_nameinfo_st__bindgen_ty_2>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_nameinfo_st__bindgen_ty_2
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_nameinfo_st__bindgen_ty_2 ) ) . name
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_nameinfo_st__bindgen_ty_2 ) , "::" , stringify ! ( name )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_nameinfo_st__bindgen_ty_2 ) ) . len
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_nameinfo_st__bindgen_ty_2 ) , "::" , stringify ! ( len )
                ));
}
impl Clone for lcb_nameinfo_st__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_lcb_nameinfo_st() {
    assert_eq!(::std::mem::size_of::<lcb_nameinfo_st>() , 32usize , concat ! (
               "Size of: " , stringify ! ( lcb_nameinfo_st ) ));
    assert_eq! (::std::mem::align_of::<lcb_nameinfo_st>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( lcb_nameinfo_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_nameinfo_st ) ) . local as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_nameinfo_st ) ,
                "::" , stringify ! ( local ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_nameinfo_st ) ) . remote as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_nameinfo_st ) ,
                "::" , stringify ! ( remote ) ));
}
impl Clone for lcb_nameinfo_st {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_io_opt_st {
    pub version: ::std::os::raw::c_int,
    pub dlhandle: *mut ::std::os::raw::c_void,
    pub destructor: ::std::option::Option<unsafe extern "C" fn(iops:
                                                                   *mut lcb_io_opt_st)>,
    pub v: lcb_io_opt_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_io_opt_st__bindgen_ty_1 {
    pub base: __BindgenUnionField<lcb_io_opt_st__bindgen_ty_1__bindgen_ty_1>,
    pub v0: __BindgenUnionField<lcb_iops_evented_st>,
    pub v1: __BindgenUnionField<lcb_iops_completion_st>,
    pub v2: __BindgenUnionField<lcb_iops2_st>,
    pub v3: __BindgenUnionField<lcb_iops3_st>,
    pub bindgen_union_field: [u64; 21usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_io_opt_st__bindgen_ty_1__bindgen_ty_1 {
    pub cookie: *mut ::std::os::raw::c_void,
    pub error: ::std::os::raw::c_int,
    pub need_cleanup: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_lcb_io_opt_st__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<lcb_io_opt_st__bindgen_ty_1__bindgen_ty_1>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               lcb_io_opt_st__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<lcb_io_opt_st__bindgen_ty_1__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                lcb_io_opt_st__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const lcb_io_opt_st__bindgen_ty_1__bindgen_ty_1 ) )
                . cookie as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_io_opt_st__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify
                ! ( cookie ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const lcb_io_opt_st__bindgen_ty_1__bindgen_ty_1 ) )
                . error as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_io_opt_st__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify
                ! ( error ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const lcb_io_opt_st__bindgen_ty_1__bindgen_ty_1 ) )
                . need_cleanup as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_io_opt_st__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify
                ! ( need_cleanup ) ));
}
impl Clone for lcb_io_opt_st__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_lcb_io_opt_st__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<lcb_io_opt_st__bindgen_ty_1>() , 168usize
               , concat ! (
               "Size of: " , stringify ! ( lcb_io_opt_st__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<lcb_io_opt_st__bindgen_ty_1>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( lcb_io_opt_st__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_io_opt_st__bindgen_ty_1 ) ) . base as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_io_opt_st__bindgen_ty_1 ) , "::" , stringify ! ( base )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_io_opt_st__bindgen_ty_1 ) ) . v0 as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_io_opt_st__bindgen_ty_1 ) , "::" , stringify ! ( v0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_io_opt_st__bindgen_ty_1 ) ) . v1 as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_io_opt_st__bindgen_ty_1 ) , "::" , stringify ! ( v1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_io_opt_st__bindgen_ty_1 ) ) . v2 as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_io_opt_st__bindgen_ty_1 ) , "::" , stringify ! ( v2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_io_opt_st__bindgen_ty_1 ) ) . v3 as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_io_opt_st__bindgen_ty_1 ) , "::" , stringify ! ( v3 ) ));
}
impl Clone for lcb_io_opt_st__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_lcb_io_opt_st() {
    assert_eq!(::std::mem::size_of::<lcb_io_opt_st>() , 192usize , concat ! (
               "Size of: " , stringify ! ( lcb_io_opt_st ) ));
    assert_eq! (::std::mem::align_of::<lcb_io_opt_st>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_io_opt_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_io_opt_st ) ) . version as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_io_opt_st ) , "::"
                , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_io_opt_st ) ) . dlhandle as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_io_opt_st ) , "::"
                , stringify ! ( dlhandle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_io_opt_st ) ) . destructor as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_io_opt_st ) , "::"
                , stringify ! ( destructor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_io_opt_st ) ) . v as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_io_opt_st ) , "::"
                , stringify ! ( v ) ));
}
impl Clone for lcb_io_opt_st {
    fn clone(&self) -> Self { *self }
}
pub type lcb_io_opt_t = *mut lcb_io_opt_st;
pub type lcb_ioE_callback =
    ::std::option::Option<unsafe extern "C" fn(sock: lcb_socket_t,
                                               events:
                                                   ::std::os::raw::c_short,
                                               uarg:
                                                   *mut ::std::os::raw::c_void)>;
pub type lcb_io_timer_create_fn =
    ::std::option::Option<unsafe extern "C" fn(iops: lcb_io_opt_t)
                              -> *mut ::std::os::raw::c_void>;
pub type lcb_io_timer_destroy_fn =
    ::std::option::Option<unsafe extern "C" fn(iops: lcb_io_opt_t,
                                               timer:
                                                   *mut ::std::os::raw::c_void)>;
pub type lcb_io_timer_cancel_fn =
    ::std::option::Option<unsafe extern "C" fn(iops: lcb_io_opt_t,
                                               timer:
                                                   *mut ::std::os::raw::c_void)>;
pub type lcb_io_timer_schedule_fn =
    ::std::option::Option<unsafe extern "C" fn(iops: lcb_io_opt_t,
                                               timer:
                                                   *mut ::std::os::raw::c_void,
                                               usecs: lcb_U32,
                                               uarg:
                                                   *mut ::std::os::raw::c_void,
                                               callback: lcb_ioE_callback)
                              -> ::std::os::raw::c_int>;
pub type lcb_ioE_event_create_fn =
    ::std::option::Option<unsafe extern "C" fn(iops: lcb_io_opt_t)
                              -> *mut ::std::os::raw::c_void>;
pub type lcb_ioE_event_destroy_fn =
    ::std::option::Option<unsafe extern "C" fn(iops: lcb_io_opt_t,
                                               event:
                                                   *mut ::std::os::raw::c_void)>;
pub type lcb_ioE_event_cancel_fn =
    ::std::option::Option<unsafe extern "C" fn(iops: lcb_io_opt_t,
                                               sock: lcb_socket_t,
                                               event:
                                                   *mut ::std::os::raw::c_void)>;
pub type lcb_ioE_event_watch_fn =
    ::std::option::Option<unsafe extern "C" fn(iops: lcb_io_opt_t,
                                               socket: lcb_socket_t,
                                               event:
                                                   *mut ::std::os::raw::c_void,
                                               evflags:
                                                   ::std::os::raw::c_short,
                                               uarg:
                                                   *mut ::std::os::raw::c_void,
                                               callback: lcb_ioE_callback)
                              -> ::std::os::raw::c_int>;
pub type lcb_ioE_recv_fn =
    ::std::option::Option<unsafe extern "C" fn(iops: lcb_io_opt_t,
                                               sock: lcb_socket_t,
                                               target_buf:
                                                   *mut ::std::os::raw::c_void,
                                               buflen: lcb_SIZE,
                                               _unused_flags:
                                                   ::std::os::raw::c_int)
                              -> lcb_SSIZE>;
pub type lcb_ioE_send_fn =
    ::std::option::Option<unsafe extern "C" fn(iops: lcb_io_opt_t,
                                               sock: lcb_socket_t,
                                               srcbuf:
                                                   *const ::std::os::raw::c_void,
                                               buflen: lcb_SIZE,
                                               _ignored:
                                                   ::std::os::raw::c_int)
                              -> lcb_SSIZE>;
pub type lcb_ioE_recvv_fn =
    ::std::option::Option<unsafe extern "C" fn(iops: lcb_io_opt_t,
                                               sock: lcb_socket_t,
                                               iov: *mut lcb_IOV,
                                               niov: lcb_SIZE) -> lcb_SSIZE>;
pub type lcb_ioE_sendv_fn =
    ::std::option::Option<unsafe extern "C" fn(iops: lcb_io_opt_t,
                                               sock: lcb_socket_t,
                                               iov: *mut lcb_IOV,
                                               niov: lcb_SIZE) -> lcb_SSIZE>;
pub type lcb_ioE_socket_fn =
    ::std::option::Option<unsafe extern "C" fn(iops: lcb_io_opt_t,
                                               domain: ::std::os::raw::c_int,
                                               type_: ::std::os::raw::c_int,
                                               protocol:
                                                   ::std::os::raw::c_int)
                              -> lcb_socket_t>;
pub type lcb_ioE_connect_fn =
    ::std::option::Option<unsafe extern "C" fn(iops: lcb_io_opt_t,
                                               sock: lcb_socket_t,
                                               dst: *const sockaddr,
                                               addrlen:
                                                   ::std::os::raw::c_uint)
                              -> ::std::os::raw::c_int>;
pub type lcb_ioE_bind_fn =
    ::std::option::Option<unsafe extern "C" fn(iops: lcb_io_opt_t,
                                               sock: lcb_socket_t,
                                               srcaddr: *const sockaddr,
                                               addrlen:
                                                   ::std::os::raw::c_uint)
                              -> ::std::os::raw::c_int>;
pub type lcb_ioE_listen_fn =
    ::std::option::Option<unsafe extern "C" fn(iops: lcb_io_opt_t,
                                               bound_sock: lcb_socket_t,
                                               queuelen:
                                                   ::std::os::raw::c_uint)
                              -> ::std::os::raw::c_int>;
pub type lcb_ioE_accept_fn =
    ::std::option::Option<unsafe extern "C" fn(iops: lcb_io_opt_t,
                                               lsnsock: lcb_socket_t)
                              -> lcb_socket_t>;
pub type lcb_ioE_close_fn =
    ::std::option::Option<unsafe extern "C" fn(iops: lcb_io_opt_t,
                                               sock: lcb_socket_t)>;
pub type lcb_ioE_chkclosed_fn =
    ::std::option::Option<unsafe extern "C" fn(iops: lcb_io_opt_t,
                                               sock: lcb_socket_t,
                                               flags: ::std::os::raw::c_int)
                              -> ::std::os::raw::c_int>;
pub type lcb_ioE_cntl_fn =
    ::std::option::Option<unsafe extern "C" fn(iops: lcb_io_opt_t,
                                               sock: lcb_socket_t,
                                               mode: ::std::os::raw::c_int,
                                               option: ::std::os::raw::c_int,
                                               arg:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ringbuffer_st {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lcb_connection_st {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lcbio_SOCKET {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_buf_info {
    pub root: *mut ::std::os::raw::c_char,
    pub size: lcb_SIZE,
    pub ringbuffer: *mut ringbuffer_st,
    pub iov: [lcb_iovec_st; 2usize],
}
#[test]
fn bindgen_test_layout_lcb_buf_info() {
    assert_eq!(::std::mem::size_of::<lcb_buf_info>() , 56usize , concat ! (
               "Size of: " , stringify ! ( lcb_buf_info ) ));
    assert_eq! (::std::mem::align_of::<lcb_buf_info>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_buf_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_buf_info ) ) . root as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_buf_info ) , "::" ,
                stringify ! ( root ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_buf_info ) ) . size as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_buf_info ) , "::" ,
                stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_buf_info ) ) . ringbuffer as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_buf_info ) , "::" ,
                stringify ! ( ringbuffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_buf_info ) ) . iov as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_buf_info ) , "::" ,
                stringify ! ( iov ) ));
}
impl Clone for lcb_buf_info {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_sockdata_st {
    pub socket: lcb_socket_t,
    pub parent: lcb_io_opt_t,
    pub lcbconn: *mut lcbio_SOCKET,
    pub closed: ::std::os::raw::c_int,
    pub is_reading: ::std::os::raw::c_int,
    pub read_buffer: lcb_buf_info,
}
#[test]
fn bindgen_test_layout_lcb_sockdata_st() {
    assert_eq!(::std::mem::size_of::<lcb_sockdata_st>() , 88usize , concat ! (
               "Size of: " , stringify ! ( lcb_sockdata_st ) ));
    assert_eq! (::std::mem::align_of::<lcb_sockdata_st>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( lcb_sockdata_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_sockdata_st ) ) . socket as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_sockdata_st ) ,
                "::" , stringify ! ( socket ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_sockdata_st ) ) . parent as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_sockdata_st ) ,
                "::" , stringify ! ( parent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_sockdata_st ) ) . lcbconn as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_sockdata_st ) ,
                "::" , stringify ! ( lcbconn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_sockdata_st ) ) . closed as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_sockdata_st ) ,
                "::" , stringify ! ( closed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_sockdata_st ) ) . is_reading as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_sockdata_st ) ,
                "::" , stringify ! ( is_reading ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_sockdata_st ) ) . read_buffer as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_sockdata_st ) ,
                "::" , stringify ! ( read_buffer ) ));
}
impl Clone for lcb_sockdata_st {
    fn clone(&self) -> Self { *self }
}
pub type lcb_sockdata_t = lcb_sockdata_st;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_io_writebuf_st {
    pub parent: *mut lcb_io_opt_st,
    pub buffer: lcb_buf_info,
}
#[test]
fn bindgen_test_layout_lcb_io_writebuf_st() {
    assert_eq!(::std::mem::size_of::<lcb_io_writebuf_st>() , 64usize , concat
               ! ( "Size of: " , stringify ! ( lcb_io_writebuf_st ) ));
    assert_eq! (::std::mem::align_of::<lcb_io_writebuf_st>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( lcb_io_writebuf_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_io_writebuf_st ) ) . parent as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_io_writebuf_st ) ,
                "::" , stringify ! ( parent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_io_writebuf_st ) ) . buffer as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_io_writebuf_st ) ,
                "::" , stringify ! ( buffer ) ));
}
impl Clone for lcb_io_writebuf_st {
    fn clone(&self) -> Self { *self }
}
pub type lcb_io_writebuf_t = lcb_io_writebuf_st;
pub type lcb_ioC_socket_fn =
    ::std::option::Option<unsafe extern "C" fn(iops: lcb_io_opt_t,
                                               domain: ::std::os::raw::c_int,
                                               type_: ::std::os::raw::c_int,
                                               protocol:
                                                   ::std::os::raw::c_int)
                              -> *mut lcb_sockdata_t>;
pub type lcb_io_connect_cb =
    ::std::option::Option<unsafe extern "C" fn(socket: *mut lcb_sockdata_t,
                                               status:
                                                   ::std::os::raw::c_int)>;
pub type lcb_ioC_connect_fn =
    ::std::option::Option<unsafe extern "C" fn(iops: lcb_io_opt_t,
                                               sd: *mut lcb_sockdata_t,
                                               dst: *const sockaddr,
                                               naddr: ::std::os::raw::c_uint,
                                               callback: lcb_io_connect_cb)
                              -> ::std::os::raw::c_int>;
pub type lcb_ioC_serve_callback =
    ::std::option::Option<unsafe extern "C" fn(sd_server: *mut lcb_sockdata_t,
                                               sd_client: *mut lcb_sockdata_t,
                                               status:
                                                   ::std::os::raw::c_int)>;
pub type lcb_ioC_serve_fn =
    ::std::option::Option<unsafe extern "C" fn(iops: lcb_io_opt_t,
                                               server_socket:
                                                   *mut lcb_sockdata_t,
                                               listen_addr: *const sockaddr,
                                               callback:
                                                   lcb_ioC_serve_callback)
                              -> ::std::os::raw::c_int>;
pub type lcb_ioC_nameinfo_fn =
    ::std::option::Option<unsafe extern "C" fn(iops: lcb_io_opt_t,
                                               sock: *mut lcb_sockdata_t,
                                               ni: *mut lcb_nameinfo_st)
                              -> ::std::os::raw::c_int>;
pub type lcb_ioC_read_callback =
    ::std::option::Option<unsafe extern "C" fn(sd: *mut lcb_sockdata_t,
                                               nread: lcb_SSIZE)>;
pub type lcb_ioC_read_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1: lcb_io_opt_t,
                                               arg2: *mut lcb_sockdata_t,
                                               arg3: lcb_ioC_read_callback)
                              -> ::std::os::raw::c_int>;
pub type lcb_ioC_wballoc_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1: lcb_io_opt_t,
                                               arg2: *mut lcb_sockdata_t)
                              -> *mut lcb_io_writebuf_t>;
pub type lcb_ioC_wbfree_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1: lcb_io_opt_t,
                                               arg2: *mut lcb_sockdata_t,
                                               arg3: *mut lcb_io_writebuf_t)>;
pub type lcb_ioC_write_callback =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut lcb_sockdata_t,
                                               arg2: *mut lcb_io_writebuf_t,
                                               arg3: ::std::os::raw::c_int)>;
pub type lcb_ioC_write_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1: lcb_io_opt_t,
                                               arg2: *mut lcb_sockdata_t,
                                               arg3: *mut lcb_io_writebuf_t,
                                               arg4: lcb_ioC_write_callback)
                              -> ::std::os::raw::c_int>;
pub type lcb_ioC_write2_callback =
    ::std::option::Option<unsafe extern "C" fn(sd: *mut lcb_sockdata_t,
                                               status: ::std::os::raw::c_int,
                                               arg:
                                                   *mut ::std::os::raw::c_void)>;
pub type lcb_ioC_write2_fn =
    ::std::option::Option<unsafe extern "C" fn(iops: lcb_io_opt_t,
                                               sd: *mut lcb_sockdata_t,
                                               iov: *mut lcb_IOV,
                                               niov: lcb_SIZE,
                                               uarg:
                                                   *mut ::std::os::raw::c_void,
                                               callback:
                                                   lcb_ioC_write2_callback)
                              -> ::std::os::raw::c_int>;
pub type lcb_ioC_read2_callback =
    ::std::option::Option<unsafe extern "C" fn(sd: *mut lcb_sockdata_t,
                                               nread: lcb_SSIZE,
                                               arg:
                                                   *mut ::std::os::raw::c_void)>;
pub type lcb_ioC_read2_fn =
    ::std::option::Option<unsafe extern "C" fn(iops: lcb_io_opt_t,
                                               sd: *mut lcb_sockdata_t,
                                               iov: *mut lcb_IOV,
                                               niov: lcb_SIZE,
                                               uarg:
                                                   *mut ::std::os::raw::c_void,
                                               callback:
                                                   lcb_ioC_read2_callback)
                              -> ::std::os::raw::c_int>;
pub type lcb_ioC_close_fn =
    ::std::option::Option<unsafe extern "C" fn(iops: lcb_io_opt_t,
                                               sd: *mut lcb_sockdata_t)
                              -> ::std::os::raw::c_uint>;
pub type lcb_ioC_chkclosed_fn =
    ::std::option::Option<unsafe extern "C" fn(iops: lcb_io_opt_t,
                                               sd: *mut lcb_sockdata_t,
                                               flags: ::std::os::raw::c_int)
                              -> ::std::os::raw::c_int>;
pub type lcb_ioC_cntl_fn =
    ::std::option::Option<unsafe extern "C" fn(iops: lcb_io_opt_t,
                                               sd: *mut lcb_sockdata_t,
                                               mode: ::std::os::raw::c_int,
                                               option: ::std::os::raw::c_int,
                                               arg:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
pub type lcb_io_start_fn =
    ::std::option::Option<unsafe extern "C" fn(iops: lcb_io_opt_t)>;
pub type lcb_io_tick_fn =
    ::std::option::Option<unsafe extern "C" fn(iops: lcb_io_opt_t)>;
pub type lcb_io_stop_fn =
    ::std::option::Option<unsafe extern "C" fn(iops: lcb_io_opt_t)>;
pub type lcb_io_error_cb =
    ::std::option::Option<unsafe extern "C" fn(socket: *mut lcb_sockdata_t)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_iops_evented_st {
    pub cookie: *mut ::std::os::raw::c_void,
    pub error: ::std::os::raw::c_int,
    pub need_cleanup: ::std::os::raw::c_int,
    pub socket: lcb_ioE_socket_fn,
    pub connect: lcb_ioE_connect_fn,
    pub recv: lcb_ioE_recv_fn,
    pub send: lcb_ioE_send_fn,
    pub recvv: lcb_ioE_recvv_fn,
    pub sendv: lcb_ioE_sendv_fn,
    pub close: lcb_ioE_close_fn,
    pub create_timer: lcb_io_timer_create_fn,
    pub destroy_timer: lcb_io_timer_destroy_fn,
    pub delete_timer: lcb_io_timer_cancel_fn,
    pub update_timer: lcb_io_timer_schedule_fn,
    pub create_event: lcb_ioE_event_create_fn,
    pub destroy_event: lcb_ioE_event_destroy_fn,
    pub update_event: lcb_ioE_event_watch_fn,
    pub delete_event: lcb_ioE_event_cancel_fn,
    pub stop_event_loop: lcb_io_stop_fn,
    pub run_event_loop: lcb_io_start_fn,
}
#[test]
fn bindgen_test_layout_lcb_iops_evented_st() {
    assert_eq!(::std::mem::size_of::<lcb_iops_evented_st>() , 152usize ,
               concat ! ( "Size of: " , stringify ! ( lcb_iops_evented_st )
               ));
    assert_eq! (::std::mem::align_of::<lcb_iops_evented_st>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( lcb_iops_evented_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_iops_evented_st ) ) . cookie as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_iops_evented_st ) ,
                "::" , stringify ! ( cookie ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_iops_evented_st ) ) . error as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_iops_evented_st ) ,
                "::" , stringify ! ( error ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_iops_evented_st ) ) . need_cleanup as
                * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_iops_evented_st ) ,
                "::" , stringify ! ( need_cleanup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_iops_evented_st ) ) . socket as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_iops_evented_st ) ,
                "::" , stringify ! ( socket ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_iops_evented_st ) ) . connect as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_iops_evented_st ) ,
                "::" , stringify ! ( connect ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_iops_evented_st ) ) . recv as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_iops_evented_st ) ,
                "::" , stringify ! ( recv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_iops_evented_st ) ) . send as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_iops_evented_st ) ,
                "::" , stringify ! ( send ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_iops_evented_st ) ) . recvv as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_iops_evented_st ) ,
                "::" , stringify ! ( recvv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_iops_evented_st ) ) . sendv as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_iops_evented_st ) ,
                "::" , stringify ! ( sendv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_iops_evented_st ) ) . close as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_iops_evented_st ) ,
                "::" , stringify ! ( close ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_iops_evented_st ) ) . create_timer as
                * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_iops_evented_st ) ,
                "::" , stringify ! ( create_timer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_iops_evented_st ) ) . destroy_timer
                as * const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_iops_evented_st ) ,
                "::" , stringify ! ( destroy_timer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_iops_evented_st ) ) . delete_timer as
                * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_iops_evented_st ) ,
                "::" , stringify ! ( delete_timer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_iops_evented_st ) ) . update_timer as
                * const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_iops_evented_st ) ,
                "::" , stringify ! ( update_timer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_iops_evented_st ) ) . create_event as
                * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_iops_evented_st ) ,
                "::" , stringify ! ( create_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_iops_evented_st ) ) . destroy_event
                as * const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_iops_evented_st ) ,
                "::" , stringify ! ( destroy_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_iops_evented_st ) ) . update_event as
                * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_iops_evented_st ) ,
                "::" , stringify ! ( update_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_iops_evented_st ) ) . delete_event as
                * const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_iops_evented_st ) ,
                "::" , stringify ! ( delete_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_iops_evented_st ) ) . stop_event_loop
                as * const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_iops_evented_st ) ,
                "::" , stringify ! ( stop_event_loop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_iops_evented_st ) ) . run_event_loop
                as * const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_iops_evented_st ) ,
                "::" , stringify ! ( run_event_loop ) ));
}
impl Clone for lcb_iops_evented_st {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_iops_completion_st {
    pub cookie: *mut ::std::os::raw::c_void,
    pub error: ::std::os::raw::c_int,
    pub need_cleanup: ::std::os::raw::c_int,
    pub create_socket: lcb_ioC_socket_fn,
    pub start_connect: lcb_ioC_connect_fn,
    pub create_writebuf: lcb_ioC_wballoc_fn,
    pub release_writebuf: lcb_ioC_wbfree_fn,
    pub start_write: lcb_ioC_write_fn,
    pub start_read: lcb_ioC_read_fn,
    pub close_socket: lcb_ioC_close_fn,
    pub create_timer: lcb_io_timer_create_fn,
    pub destroy_timer: lcb_io_timer_destroy_fn,
    pub delete_timer: lcb_io_timer_cancel_fn,
    pub update_timer: lcb_io_timer_schedule_fn,
    pub get_nameinfo: lcb_ioC_nameinfo_fn,
    pub pad1: ::std::option::Option<unsafe extern "C" fn()>,
    pub pad2: ::std::option::Option<unsafe extern "C" fn()>,
    pub send_error: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                   *mut lcb_io_opt_st,
                                                               arg2:
                                                                   *mut lcb_sockdata_t,
                                                               arg3:
                                                                   ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                                                  *mut lcb_sockdata_t)>)>,
    pub stop_event_loop: lcb_io_stop_fn,
    pub run_event_loop: lcb_io_start_fn,
}
#[test]
fn bindgen_test_layout_lcb_iops_completion_st() {
    assert_eq!(::std::mem::size_of::<lcb_iops_completion_st>() , 152usize ,
               concat ! ( "Size of: " , stringify ! ( lcb_iops_completion_st )
               ));
    assert_eq! (::std::mem::align_of::<lcb_iops_completion_st>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( lcb_iops_completion_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_iops_completion_st ) ) . cookie as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_iops_completion_st
                ) , "::" , stringify ! ( cookie ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_iops_completion_st ) ) . error as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_iops_completion_st
                ) , "::" , stringify ! ( error ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_iops_completion_st ) ) . need_cleanup
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_iops_completion_st
                ) , "::" , stringify ! ( need_cleanup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_iops_completion_st ) ) .
                create_socket as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_iops_completion_st
                ) , "::" , stringify ! ( create_socket ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_iops_completion_st ) ) .
                start_connect as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_iops_completion_st
                ) , "::" , stringify ! ( start_connect ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_iops_completion_st ) ) .
                create_writebuf as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_iops_completion_st
                ) , "::" , stringify ! ( create_writebuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_iops_completion_st ) ) .
                release_writebuf as * const _ as usize } , 40usize , concat !
                (
                "Alignment of field: " , stringify ! ( lcb_iops_completion_st
                ) , "::" , stringify ! ( release_writebuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_iops_completion_st ) ) . start_write
                as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_iops_completion_st
                ) , "::" , stringify ! ( start_write ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_iops_completion_st ) ) . start_read
                as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_iops_completion_st
                ) , "::" , stringify ! ( start_read ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_iops_completion_st ) ) . close_socket
                as * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_iops_completion_st
                ) , "::" , stringify ! ( close_socket ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_iops_completion_st ) ) . create_timer
                as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_iops_completion_st
                ) , "::" , stringify ! ( create_timer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_iops_completion_st ) ) .
                destroy_timer as * const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_iops_completion_st
                ) , "::" , stringify ! ( destroy_timer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_iops_completion_st ) ) . delete_timer
                as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_iops_completion_st
                ) , "::" , stringify ! ( delete_timer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_iops_completion_st ) ) . update_timer
                as * const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_iops_completion_st
                ) , "::" , stringify ! ( update_timer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_iops_completion_st ) ) . get_nameinfo
                as * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_iops_completion_st
                ) , "::" , stringify ! ( get_nameinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_iops_completion_st ) ) . pad1 as *
                const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_iops_completion_st
                ) , "::" , stringify ! ( pad1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_iops_completion_st ) ) . pad2 as *
                const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_iops_completion_st
                ) , "::" , stringify ! ( pad2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_iops_completion_st ) ) . send_error
                as * const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_iops_completion_st
                ) , "::" , stringify ! ( send_error ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_iops_completion_st ) ) .
                stop_event_loop as * const _ as usize } , 136usize , concat !
                (
                "Alignment of field: " , stringify ! ( lcb_iops_completion_st
                ) , "::" , stringify ! ( stop_event_loop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_iops_completion_st ) ) .
                run_event_loop as * const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_iops_completion_st
                ) , "::" , stringify ! ( run_event_loop ) ));
}
impl Clone for lcb_iops_completion_st {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_timerprocs_st {
    pub create: lcb_io_timer_create_fn,
    pub destroy: lcb_io_timer_destroy_fn,
    pub cancel: lcb_io_timer_cancel_fn,
    pub schedule: lcb_io_timer_schedule_fn,
}
#[test]
fn bindgen_test_layout_lcb_timerprocs_st() {
    assert_eq!(::std::mem::size_of::<lcb_timerprocs_st>() , 32usize , concat !
               ( "Size of: " , stringify ! ( lcb_timerprocs_st ) ));
    assert_eq! (::std::mem::align_of::<lcb_timerprocs_st>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( lcb_timerprocs_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_timerprocs_st ) ) . create as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_timerprocs_st ) ,
                "::" , stringify ! ( create ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_timerprocs_st ) ) . destroy as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_timerprocs_st ) ,
                "::" , stringify ! ( destroy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_timerprocs_st ) ) . cancel as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_timerprocs_st ) ,
                "::" , stringify ! ( cancel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_timerprocs_st ) ) . schedule as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_timerprocs_st ) ,
                "::" , stringify ! ( schedule ) ));
}
impl Clone for lcb_timerprocs_st {
    fn clone(&self) -> Self { *self }
}
pub type lcb_timer_procs = lcb_timerprocs_st;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_loopprocs_st {
    pub start: lcb_io_start_fn,
    pub stop: lcb_io_stop_fn,
    pub tick: lcb_io_tick_fn,
}
#[test]
fn bindgen_test_layout_lcb_loopprocs_st() {
    assert_eq!(::std::mem::size_of::<lcb_loopprocs_st>() , 24usize , concat !
               ( "Size of: " , stringify ! ( lcb_loopprocs_st ) ));
    assert_eq! (::std::mem::align_of::<lcb_loopprocs_st>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( lcb_loopprocs_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_loopprocs_st ) ) . start as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_loopprocs_st ) ,
                "::" , stringify ! ( start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_loopprocs_st ) ) . stop as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_loopprocs_st ) ,
                "::" , stringify ! ( stop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_loopprocs_st ) ) . tick as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_loopprocs_st ) ,
                "::" , stringify ! ( tick ) ));
}
impl Clone for lcb_loopprocs_st {
    fn clone(&self) -> Self { *self }
}
pub type lcb_loop_procs = lcb_loopprocs_st;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_bsdprocs_st {
    pub socket0: lcb_ioE_socket_fn,
    pub connect0: lcb_ioE_connect_fn,
    pub recv: lcb_ioE_recv_fn,
    pub recvv: lcb_ioE_recvv_fn,
    pub send: lcb_ioE_send_fn,
    pub sendv: lcb_ioE_sendv_fn,
    pub close: lcb_ioE_close_fn,
    pub bind: lcb_ioE_bind_fn,
    pub listen: lcb_ioE_listen_fn,
    pub accept: lcb_ioE_accept_fn,
    pub is_closed: lcb_ioE_chkclosed_fn,
    pub cntl: lcb_ioE_cntl_fn,
}
#[test]
fn bindgen_test_layout_lcb_bsdprocs_st() {
    assert_eq!(::std::mem::size_of::<lcb_bsdprocs_st>() , 96usize , concat ! (
               "Size of: " , stringify ! ( lcb_bsdprocs_st ) ));
    assert_eq! (::std::mem::align_of::<lcb_bsdprocs_st>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( lcb_bsdprocs_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_bsdprocs_st ) ) . socket0 as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_bsdprocs_st ) ,
                "::" , stringify ! ( socket0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_bsdprocs_st ) ) . connect0 as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_bsdprocs_st ) ,
                "::" , stringify ! ( connect0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_bsdprocs_st ) ) . recv as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_bsdprocs_st ) ,
                "::" , stringify ! ( recv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_bsdprocs_st ) ) . recvv as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_bsdprocs_st ) ,
                "::" , stringify ! ( recvv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_bsdprocs_st ) ) . send as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_bsdprocs_st ) ,
                "::" , stringify ! ( send ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_bsdprocs_st ) ) . sendv as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_bsdprocs_st ) ,
                "::" , stringify ! ( sendv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_bsdprocs_st ) ) . close as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_bsdprocs_st ) ,
                "::" , stringify ! ( close ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_bsdprocs_st ) ) . bind as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_bsdprocs_st ) ,
                "::" , stringify ! ( bind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_bsdprocs_st ) ) . listen as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_bsdprocs_st ) ,
                "::" , stringify ! ( listen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_bsdprocs_st ) ) . accept as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_bsdprocs_st ) ,
                "::" , stringify ! ( accept ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_bsdprocs_st ) ) . is_closed as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_bsdprocs_st ) ,
                "::" , stringify ! ( is_closed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_bsdprocs_st ) ) . cntl as * const _
                as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_bsdprocs_st ) ,
                "::" , stringify ! ( cntl ) ));
}
impl Clone for lcb_bsdprocs_st {
    fn clone(&self) -> Self { *self }
}
pub type lcb_bsd_procs = lcb_bsdprocs_st;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_evprocs_st {
    pub create: lcb_ioE_event_create_fn,
    pub destroy: lcb_ioE_event_destroy_fn,
    pub cancel: lcb_ioE_event_cancel_fn,
    pub watch: lcb_ioE_event_watch_fn,
}
#[test]
fn bindgen_test_layout_lcb_evprocs_st() {
    assert_eq!(::std::mem::size_of::<lcb_evprocs_st>() , 32usize , concat ! (
               "Size of: " , stringify ! ( lcb_evprocs_st ) ));
    assert_eq! (::std::mem::align_of::<lcb_evprocs_st>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_evprocs_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_evprocs_st ) ) . create as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_evprocs_st ) , "::"
                , stringify ! ( create ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_evprocs_st ) ) . destroy as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_evprocs_st ) , "::"
                , stringify ! ( destroy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_evprocs_st ) ) . cancel as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_evprocs_st ) , "::"
                , stringify ! ( cancel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_evprocs_st ) ) . watch as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_evprocs_st ) , "::"
                , stringify ! ( watch ) ));
}
impl Clone for lcb_evprocs_st {
    fn clone(&self) -> Self { *self }
}
pub type lcb_ev_procs = lcb_evprocs_st;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_completion_procs {
    pub socket: lcb_ioC_socket_fn,
    pub close: lcb_ioC_close_fn,
    pub read: lcb_ioC_read_fn,
    pub connect: lcb_ioC_connect_fn,
    pub wballoc: lcb_ioC_wballoc_fn,
    pub wbfree: lcb_ioC_wbfree_fn,
    pub write: lcb_ioC_write_fn,
    pub write2: lcb_ioC_write2_fn,
    pub read2: lcb_ioC_read2_fn,
    pub serve: lcb_ioC_serve_fn,
    pub nameinfo: lcb_ioC_nameinfo_fn,
    pub is_closed: lcb_ioC_chkclosed_fn,
    pub cntl: lcb_ioC_cntl_fn,
}
#[test]
fn bindgen_test_layout_lcb_completion_procs() {
    assert_eq!(::std::mem::size_of::<lcb_completion_procs>() , 104usize ,
               concat ! ( "Size of: " , stringify ! ( lcb_completion_procs )
               ));
    assert_eq! (::std::mem::align_of::<lcb_completion_procs>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( lcb_completion_procs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_completion_procs ) ) . socket as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_completion_procs )
                , "::" , stringify ! ( socket ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_completion_procs ) ) . close as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_completion_procs )
                , "::" , stringify ! ( close ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_completion_procs ) ) . read as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_completion_procs )
                , "::" , stringify ! ( read ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_completion_procs ) ) . connect as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_completion_procs )
                , "::" , stringify ! ( connect ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_completion_procs ) ) . wballoc as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_completion_procs )
                , "::" , stringify ! ( wballoc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_completion_procs ) ) . wbfree as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_completion_procs )
                , "::" , stringify ! ( wbfree ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_completion_procs ) ) . write as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_completion_procs )
                , "::" , stringify ! ( write ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_completion_procs ) ) . write2 as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_completion_procs )
                , "::" , stringify ! ( write2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_completion_procs ) ) . read2 as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_completion_procs )
                , "::" , stringify ! ( read2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_completion_procs ) ) . serve as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_completion_procs )
                , "::" , stringify ! ( serve ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_completion_procs ) ) . nameinfo as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_completion_procs )
                , "::" , stringify ! ( nameinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_completion_procs ) ) . is_closed as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_completion_procs )
                , "::" , stringify ! ( is_closed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_completion_procs ) ) . cntl as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_completion_procs )
                , "::" , stringify ! ( cntl ) ));
}
impl Clone for lcb_completion_procs {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum lcb_iomodel_t { LCB_IOMODEL_EVENT = 0, LCB_IOMODEL_COMPLETION = 1, }
pub type lcb_io_procs_fn =
    ::std::option::Option<unsafe extern "C" fn(version: ::std::os::raw::c_int,
                                               loop_procs:
                                                   *mut lcb_loop_procs,
                                               timer_procs:
                                                   *mut lcb_timer_procs,
                                               bsd_procs: *mut lcb_bsd_procs,
                                               ev_procs: *mut lcb_ev_procs,
                                               completion_procs:
                                                   *mut lcb_completion_procs,
                                               iomodel: *mut lcb_iomodel_t)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lcbio_TABLE {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_iops2_st {
    pub cookie: *mut ::std::os::raw::c_void,
    pub error: ::std::os::raw::c_int,
    pub need_cleanup: ::std::os::raw::c_int,
    pub get_procs: lcb_io_procs_fn,
    pub iot: *mut lcbio_TABLE,
}
#[test]
fn bindgen_test_layout_lcb_iops2_st() {
    assert_eq!(::std::mem::size_of::<lcb_iops2_st>() , 32usize , concat ! (
               "Size of: " , stringify ! ( lcb_iops2_st ) ));
    assert_eq! (::std::mem::align_of::<lcb_iops2_st>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_iops2_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_iops2_st ) ) . cookie as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_iops2_st ) , "::" ,
                stringify ! ( cookie ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_iops2_st ) ) . error as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_iops2_st ) , "::" ,
                stringify ! ( error ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_iops2_st ) ) . need_cleanup as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_iops2_st ) , "::" ,
                stringify ! ( need_cleanup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_iops2_st ) ) . get_procs as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_iops2_st ) , "::" ,
                stringify ! ( get_procs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_iops2_st ) ) . iot as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_iops2_st ) , "::" ,
                stringify ! ( iot ) ));
}
impl Clone for lcb_iops2_st {
    fn clone(&self) -> Self { *self }
}
pub type lcb__iops3fndummy = ::std::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_iops3_st {
    pub cookie: *mut ::std::os::raw::c_void,
    pub error: ::std::os::raw::c_int,
    pub need_cleanup: ::std::os::raw::c_int,
    pub pads: [lcb__iops3fndummy; 17usize],
    pub get_procs: lcb_io_procs_fn,
    pub iot: *mut lcbio_TABLE,
}
#[test]
fn bindgen_test_layout_lcb_iops3_st() {
    assert_eq!(::std::mem::size_of::<lcb_iops3_st>() , 168usize , concat ! (
               "Size of: " , stringify ! ( lcb_iops3_st ) ));
    assert_eq! (::std::mem::align_of::<lcb_iops3_st>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_iops3_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_iops3_st ) ) . cookie as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_iops3_st ) , "::" ,
                stringify ! ( cookie ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_iops3_st ) ) . error as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_iops3_st ) , "::" ,
                stringify ! ( error ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_iops3_st ) ) . need_cleanup as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_iops3_st ) , "::" ,
                stringify ! ( need_cleanup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_iops3_st ) ) . pads as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_iops3_st ) , "::" ,
                stringify ! ( pads ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_iops3_st ) ) . get_procs as * const _
                as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_iops3_st ) , "::" ,
                stringify ! ( get_procs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_iops3_st ) ) . iot as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_iops3_st ) , "::" ,
                stringify ! ( iot ) ));
}
impl Clone for lcb_iops3_st {
    fn clone(&self) -> Self { *self }
}
pub type lcb_io_create_fn =
    ::std::option::Option<unsafe extern "C" fn(version: ::std::os::raw::c_int,
                                               io: *mut lcb_io_opt_t,
                                               cookie:
                                                   *mut ::std::os::raw::c_void)
                              -> lcb_error_t>;
extern "C" {
    pub fn lcb_iops_wire_bsd_impl2(procs: *mut lcb_bsd_procs,
                                   version: ::std::os::raw::c_int);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum lcb_io_ops_type_t {
    LCB_IO_OPS_INVALID = 0,
    LCB_IO_OPS_DEFAULT = 1,
    LCB_IO_OPS_LIBEVENT = 2,
    LCB_IO_OPS_WINSOCK = 3,
    LCB_IO_OPS_LIBEV = 4,
    LCB_IO_OPS_SELECT = 5,
    LCB_IO_OPS_WINIOCP = 6,
    LCB_IO_OPS_LIBUV = 7,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_IOCREATEOPTS_BUILTIN {
    pub type_: lcb_io_ops_type_t,
    pub cookie: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_lcb_IOCREATEOPTS_BUILTIN() {
    assert_eq!(::std::mem::size_of::<lcb_IOCREATEOPTS_BUILTIN>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( lcb_IOCREATEOPTS_BUILTIN ) ));
    assert_eq! (::std::mem::align_of::<lcb_IOCREATEOPTS_BUILTIN>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( lcb_IOCREATEOPTS_BUILTIN ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_IOCREATEOPTS_BUILTIN ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_IOCREATEOPTS_BUILTIN ) , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_IOCREATEOPTS_BUILTIN ) ) . cookie as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_IOCREATEOPTS_BUILTIN ) , "::" , stringify ! ( cookie ) ));
}
impl Clone for lcb_IOCREATEOPTS_BUILTIN {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_IOCREATEOPTS_DSO {
    pub sofile: *const ::std::os::raw::c_char,
    pub symbol: *const ::std::os::raw::c_char,
    pub cookie: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_lcb_IOCREATEOPTS_DSO() {
    assert_eq!(::std::mem::size_of::<lcb_IOCREATEOPTS_DSO>() , 24usize ,
               concat ! ( "Size of: " , stringify ! ( lcb_IOCREATEOPTS_DSO )
               ));
    assert_eq! (::std::mem::align_of::<lcb_IOCREATEOPTS_DSO>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( lcb_IOCREATEOPTS_DSO ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_IOCREATEOPTS_DSO ) ) . sofile as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_IOCREATEOPTS_DSO )
                , "::" , stringify ! ( sofile ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_IOCREATEOPTS_DSO ) ) . symbol as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_IOCREATEOPTS_DSO )
                , "::" , stringify ! ( symbol ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_IOCREATEOPTS_DSO ) ) . cookie as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_IOCREATEOPTS_DSO )
                , "::" , stringify ! ( cookie ) ));
}
impl Clone for lcb_IOCREATEOPTS_DSO {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_IOCREATEOPS_FUNCTIONPOINTER {
    pub create: lcb_io_create_fn,
    pub cookie: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_lcb_IOCREATEOPS_FUNCTIONPOINTER() {
    assert_eq!(::std::mem::size_of::<lcb_IOCREATEOPS_FUNCTIONPOINTER>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( lcb_IOCREATEOPS_FUNCTIONPOINTER )
               ));
    assert_eq! (::std::mem::align_of::<lcb_IOCREATEOPS_FUNCTIONPOINTER>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                lcb_IOCREATEOPS_FUNCTIONPOINTER ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_IOCREATEOPS_FUNCTIONPOINTER ) ) .
                create as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_IOCREATEOPS_FUNCTIONPOINTER ) , "::" , stringify ! (
                create ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_IOCREATEOPS_FUNCTIONPOINTER ) ) .
                cookie as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_IOCREATEOPS_FUNCTIONPOINTER ) , "::" , stringify ! (
                cookie ) ));
}
impl Clone for lcb_IOCREATEOPS_FUNCTIONPOINTER {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_create_io_ops_st {
    pub version: ::std::os::raw::c_int,
    pub v: lcb_create_io_ops_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_create_io_ops_st__bindgen_ty_1 {
    pub v0: __BindgenUnionField<lcb_IOCREATEOPTS_BUILTIN>,
    pub v1: __BindgenUnionField<lcb_IOCREATEOPTS_DSO>,
    pub v2: __BindgenUnionField<lcb_IOCREATEOPS_FUNCTIONPOINTER>,
    pub bindgen_union_field: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_lcb_create_io_ops_st__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<lcb_create_io_ops_st__bindgen_ty_1>() ,
               24usize , concat ! (
               "Size of: " , stringify ! ( lcb_create_io_ops_st__bindgen_ty_1
               ) ));
    assert_eq! (::std::mem::align_of::<lcb_create_io_ops_st__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                lcb_create_io_ops_st__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_create_io_ops_st__bindgen_ty_1 ) ) .
                v0 as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_create_io_ops_st__bindgen_ty_1 ) , "::" , stringify ! ( v0
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_create_io_ops_st__bindgen_ty_1 ) ) .
                v1 as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_create_io_ops_st__bindgen_ty_1 ) , "::" , stringify ! ( v1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_create_io_ops_st__bindgen_ty_1 ) ) .
                v2 as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_create_io_ops_st__bindgen_ty_1 ) , "::" , stringify ! ( v2
                ) ));
}
impl Clone for lcb_create_io_ops_st__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_lcb_create_io_ops_st() {
    assert_eq!(::std::mem::size_of::<lcb_create_io_ops_st>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( lcb_create_io_ops_st )
               ));
    assert_eq! (::std::mem::align_of::<lcb_create_io_ops_st>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( lcb_create_io_ops_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_create_io_ops_st ) ) . version as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_create_io_ops_st )
                , "::" , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_create_io_ops_st ) ) . v as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_create_io_ops_st )
                , "::" , stringify ! ( v ) ));
}
impl Clone for lcb_create_io_ops_st {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn lcb_create_io_ops(op: *mut lcb_io_opt_t,
                             options: *const lcb_create_io_ops_st)
     -> lcb_error_t;
}
extern "C" {
    pub fn lcb_destroy_io_ops(op: lcb_io_opt_t) -> lcb_error_t;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum lcb_KVBUFTYPE {
    LCB_KV_COPY = 0,
    LCB_KV_CONTIG = 1,
    LCB_KV_IOV = 2,
    LCB_KV_VBID = 3,
    LCB_KV_IOVCOPY = 4,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_CONTIGBUF {
    pub bytes: *const ::std::os::raw::c_void,
    pub nbytes: lcb_size_t,
}
#[test]
fn bindgen_test_layout_lcb_CONTIGBUF() {
    assert_eq!(::std::mem::size_of::<lcb_CONTIGBUF>() , 16usize , concat ! (
               "Size of: " , stringify ! ( lcb_CONTIGBUF ) ));
    assert_eq! (::std::mem::align_of::<lcb_CONTIGBUF>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_CONTIGBUF ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CONTIGBUF ) ) . bytes as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CONTIGBUF ) , "::"
                , stringify ! ( bytes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CONTIGBUF ) ) . nbytes as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CONTIGBUF ) , "::"
                , stringify ! ( nbytes ) ));
}
impl Clone for lcb_CONTIGBUF {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_KEYBUF {
    pub type_: lcb_KVBUFTYPE,
    pub contig: lcb_CONTIGBUF,
}
#[test]
fn bindgen_test_layout_lcb_KEYBUF() {
    assert_eq!(::std::mem::size_of::<lcb_KEYBUF>() , 24usize , concat ! (
               "Size of: " , stringify ! ( lcb_KEYBUF ) ));
    assert_eq! (::std::mem::align_of::<lcb_KEYBUF>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_KEYBUF ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_KEYBUF ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_KEYBUF ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_KEYBUF ) ) . contig as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_KEYBUF ) , "::" ,
                stringify ! ( contig ) ));
}
impl Clone for lcb_KEYBUF {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_FRAGBUF {
    pub iov: *mut lcb_IOV,
    pub niov: ::std::os::raw::c_uint,
    pub total_length: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_lcb_FRAGBUF() {
    assert_eq!(::std::mem::size_of::<lcb_FRAGBUF>() , 16usize , concat ! (
               "Size of: " , stringify ! ( lcb_FRAGBUF ) ));
    assert_eq! (::std::mem::align_of::<lcb_FRAGBUF>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_FRAGBUF ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_FRAGBUF ) ) . iov as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_FRAGBUF ) , "::" ,
                stringify ! ( iov ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_FRAGBUF ) ) . niov as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_FRAGBUF ) , "::" ,
                stringify ! ( niov ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_FRAGBUF ) ) . total_length as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_FRAGBUF ) , "::" ,
                stringify ! ( total_length ) ));
}
impl Clone for lcb_FRAGBUF {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_VALBUF {
    pub vtype: lcb_KVBUFTYPE,
    pub u_buf: lcb_VALBUF__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_VALBUF__bindgen_ty_1 {
    pub contig: __BindgenUnionField<lcb_CONTIGBUF>,
    pub multi: __BindgenUnionField<lcb_FRAGBUF>,
    pub bindgen_union_field: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_lcb_VALBUF__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<lcb_VALBUF__bindgen_ty_1>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( lcb_VALBUF__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<lcb_VALBUF__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( lcb_VALBUF__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_VALBUF__bindgen_ty_1 ) ) . contig as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_VALBUF__bindgen_ty_1 ) , "::" , stringify ! ( contig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_VALBUF__bindgen_ty_1 ) ) . multi as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_VALBUF__bindgen_ty_1 ) , "::" , stringify ! ( multi ) ));
}
impl Clone for lcb_VALBUF__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_lcb_VALBUF() {
    assert_eq!(::std::mem::size_of::<lcb_VALBUF>() , 24usize , concat ! (
               "Size of: " , stringify ! ( lcb_VALBUF ) ));
    assert_eq! (::std::mem::align_of::<lcb_VALBUF>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_VALBUF ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_VALBUF ) ) . vtype as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_VALBUF ) , "::" ,
                stringify ! ( vtype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_VALBUF ) ) . u_buf as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_VALBUF ) , "::" ,
                stringify ! ( u_buf ) ));
}
impl Clone for lcb_VALBUF {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lcb_AUTHENTICATOR_Cdummy {
    _unused: [u8; 0],
}
pub type lcb_AUTHENTICATOR = lcb_AUTHENTICATOR_Cdummy;
extern "C" {
    pub fn lcbauth_new() -> *mut lcb_AUTHENTICATOR;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum lcbauth_ADDPASSFLAGS { LCBAUTH_F_CLUSTER = 2, LCBAUTH_F_BUCKET = 4, }
extern "C" {
    pub fn lcbauth_add_pass(auth: *mut lcb_AUTHENTICATOR,
                            user: *const ::std::os::raw::c_char,
                            pass: *const ::std::os::raw::c_char,
                            flags: ::std::os::raw::c_int) -> lcb_error_t;
}
extern "C" {
    pub fn lcbauth_ref(auth: *mut lcb_AUTHENTICATOR);
}
extern "C" {
    pub fn lcbauth_unref(auth: *mut lcb_AUTHENTICATOR);
}
extern "C" {
    pub fn lcbauth_clone(src: *const lcb_AUTHENTICATOR)
     -> *mut lcb_AUTHENTICATOR;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum lcbauth_MODE { LCBAUTH_MODE_CLASSIC = 0, LCBAUTH_MODE_RBAC = 1, }
extern "C" {
    pub fn lcbauth_set_mode(src: *mut lcb_AUTHENTICATOR, mode: lcbauth_MODE)
     -> lcb_error_t;
}
pub type lcb_datatype_t = lcb_U8;
pub type lcb_USECS = lcb_U32;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum lcb_type_t { LCB_TYPE_BUCKET = 0, LCB_TYPE_CLUSTER = 1, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum lcb_config_transport_t {
    LCB_CONFIG_TRANSPORT_LIST_END = 0,
    LCB_CONFIG_TRANSPORT_HTTP = 1,
    LCB_CONFIG_TRANSPORT_CCCP = 2,
    LCB_CONFIG_TRANSPORT_MAX = 3,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_create_st0 {
    pub host: *const ::std::os::raw::c_char,
    pub user: *const ::std::os::raw::c_char,
    pub passwd: *const ::std::os::raw::c_char,
    pub bucket: *const ::std::os::raw::c_char,
    pub io: *mut lcb_io_opt_st,
}
#[test]
fn bindgen_test_layout_lcb_create_st0() {
    assert_eq!(::std::mem::size_of::<lcb_create_st0>() , 40usize , concat ! (
               "Size of: " , stringify ! ( lcb_create_st0 ) ));
    assert_eq! (::std::mem::align_of::<lcb_create_st0>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_create_st0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_create_st0 ) ) . host as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_create_st0 ) , "::"
                , stringify ! ( host ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_create_st0 ) ) . user as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_create_st0 ) , "::"
                , stringify ! ( user ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_create_st0 ) ) . passwd as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_create_st0 ) , "::"
                , stringify ! ( passwd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_create_st0 ) ) . bucket as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_create_st0 ) , "::"
                , stringify ! ( bucket ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_create_st0 ) ) . io as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_create_st0 ) , "::"
                , stringify ! ( io ) ));
}
impl Clone for lcb_create_st0 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_create_st1 {
    pub host: *const ::std::os::raw::c_char,
    pub user: *const ::std::os::raw::c_char,
    pub passwd: *const ::std::os::raw::c_char,
    pub bucket: *const ::std::os::raw::c_char,
    pub io: *mut lcb_io_opt_st,
    pub type_: lcb_type_t,
}
#[test]
fn bindgen_test_layout_lcb_create_st1() {
    assert_eq!(::std::mem::size_of::<lcb_create_st1>() , 48usize , concat ! (
               "Size of: " , stringify ! ( lcb_create_st1 ) ));
    assert_eq! (::std::mem::align_of::<lcb_create_st1>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_create_st1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_create_st1 ) ) . host as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_create_st1 ) , "::"
                , stringify ! ( host ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_create_st1 ) ) . user as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_create_st1 ) , "::"
                , stringify ! ( user ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_create_st1 ) ) . passwd as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_create_st1 ) , "::"
                , stringify ! ( passwd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_create_st1 ) ) . bucket as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_create_st1 ) , "::"
                , stringify ! ( bucket ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_create_st1 ) ) . io as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_create_st1 ) , "::"
                , stringify ! ( io ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_create_st1 ) ) . type_ as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_create_st1 ) , "::"
                , stringify ! ( type_ ) ));
}
impl Clone for lcb_create_st1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_create_st2 {
    pub host: *const ::std::os::raw::c_char,
    pub user: *const ::std::os::raw::c_char,
    pub passwd: *const ::std::os::raw::c_char,
    pub bucket: *const ::std::os::raw::c_char,
    pub io: *mut lcb_io_opt_st,
    pub type_: lcb_type_t,
    pub mchosts: *const ::std::os::raw::c_char,
    pub transports: *const lcb_config_transport_t,
}
#[test]
fn bindgen_test_layout_lcb_create_st2() {
    assert_eq!(::std::mem::size_of::<lcb_create_st2>() , 64usize , concat ! (
               "Size of: " , stringify ! ( lcb_create_st2 ) ));
    assert_eq! (::std::mem::align_of::<lcb_create_st2>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_create_st2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_create_st2 ) ) . host as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_create_st2 ) , "::"
                , stringify ! ( host ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_create_st2 ) ) . user as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_create_st2 ) , "::"
                , stringify ! ( user ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_create_st2 ) ) . passwd as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_create_st2 ) , "::"
                , stringify ! ( passwd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_create_st2 ) ) . bucket as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_create_st2 ) , "::"
                , stringify ! ( bucket ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_create_st2 ) ) . io as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_create_st2 ) , "::"
                , stringify ! ( io ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_create_st2 ) ) . type_ as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_create_st2 ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_create_st2 ) ) . mchosts as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_create_st2 ) , "::"
                , stringify ! ( mchosts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_create_st2 ) ) . transports as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_create_st2 ) , "::"
                , stringify ! ( transports ) ));
}
impl Clone for lcb_create_st2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_create_st3 {
    pub connstr: *const ::std::os::raw::c_char,
    pub username: *const ::std::os::raw::c_char,
    pub passwd: *const ::std::os::raw::c_char,
    pub _pad_bucket: *mut ::std::os::raw::c_void,
    pub io: *mut lcb_io_opt_st,
    pub type_: lcb_type_t,
}
#[test]
fn bindgen_test_layout_lcb_create_st3() {
    assert_eq!(::std::mem::size_of::<lcb_create_st3>() , 48usize , concat ! (
               "Size of: " , stringify ! ( lcb_create_st3 ) ));
    assert_eq! (::std::mem::align_of::<lcb_create_st3>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_create_st3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_create_st3 ) ) . connstr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_create_st3 ) , "::"
                , stringify ! ( connstr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_create_st3 ) ) . username as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_create_st3 ) , "::"
                , stringify ! ( username ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_create_st3 ) ) . passwd as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_create_st3 ) , "::"
                , stringify ! ( passwd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_create_st3 ) ) . _pad_bucket as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_create_st3 ) , "::"
                , stringify ! ( _pad_bucket ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_create_st3 ) ) . io as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_create_st3 ) , "::"
                , stringify ! ( io ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_create_st3 ) ) . type_ as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_create_st3 ) , "::"
                , stringify ! ( type_ ) ));
}
impl Clone for lcb_create_st3 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_create_st {
    pub version: ::std::os::raw::c_int,
    pub v: lcb_create_st_lcb_CRST_u,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_create_st_lcb_CRST_u {
    pub v0: __BindgenUnionField<lcb_create_st0>,
    pub v1: __BindgenUnionField<lcb_create_st1>,
    pub v2: __BindgenUnionField<lcb_create_st2>,
    pub v3: __BindgenUnionField<lcb_create_st3>,
    pub bindgen_union_field: [u64; 8usize],
}
#[test]
fn bindgen_test_layout_lcb_create_st_lcb_CRST_u() {
    assert_eq!(::std::mem::size_of::<lcb_create_st_lcb_CRST_u>() , 64usize ,
               concat ! (
               "Size of: " , stringify ! ( lcb_create_st_lcb_CRST_u ) ));
    assert_eq! (::std::mem::align_of::<lcb_create_st_lcb_CRST_u>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( lcb_create_st_lcb_CRST_u ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_create_st_lcb_CRST_u ) ) . v0 as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_create_st_lcb_CRST_u ) , "::" , stringify ! ( v0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_create_st_lcb_CRST_u ) ) . v1 as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_create_st_lcb_CRST_u ) , "::" , stringify ! ( v1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_create_st_lcb_CRST_u ) ) . v2 as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_create_st_lcb_CRST_u ) , "::" , stringify ! ( v2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_create_st_lcb_CRST_u ) ) . v3 as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_create_st_lcb_CRST_u ) , "::" , stringify ! ( v3 ) ));
}
impl Clone for lcb_create_st_lcb_CRST_u {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_lcb_create_st() {
    assert_eq!(::std::mem::size_of::<lcb_create_st>() , 72usize , concat ! (
               "Size of: " , stringify ! ( lcb_create_st ) ));
    assert_eq! (::std::mem::align_of::<lcb_create_st>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_create_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_create_st ) ) . version as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_create_st ) , "::"
                , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_create_st ) ) . v as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_create_st ) , "::"
                , stringify ! ( v ) ));
}
impl Clone for lcb_create_st {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn lcb_create(instance: *mut lcb_t, options: *const lcb_create_st)
     -> lcb_error_t;
}
extern "C" {
    pub fn lcb_connect(instance: lcb_t) -> lcb_error_t;
}
pub type lcb_bootstrap_callback =
    ::std::option::Option<unsafe extern "C" fn(instance: lcb_t,
                                               err: lcb_error_t)>;
extern "C" {
    pub fn lcb_set_bootstrap_callback(instance: lcb_t,
                                      callback: lcb_bootstrap_callback)
     -> lcb_bootstrap_callback;
}
extern "C" {
    pub fn lcb_get_bootstrap_status(instance: lcb_t) -> lcb_error_t;
}
extern "C" {
    pub fn lcb_set_auth(instance: lcb_t, auth: *mut lcb_AUTHENTICATOR);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_CMDBASE {
    pub cmdflags: lcb_U32,
    pub exptime: lcb_U32,
    pub cas: lcb_U64,
    pub key: lcb_KEYBUF,
    pub _hashkey: lcb_KEYBUF,
}
#[test]
fn bindgen_test_layout_lcb_CMDBASE() {
    assert_eq!(::std::mem::size_of::<lcb_CMDBASE>() , 64usize , concat ! (
               "Size of: " , stringify ! ( lcb_CMDBASE ) ));
    assert_eq! (::std::mem::align_of::<lcb_CMDBASE>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_CMDBASE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDBASE ) ) . cmdflags as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDBASE ) , "::" ,
                stringify ! ( cmdflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDBASE ) ) . exptime as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDBASE ) , "::" ,
                stringify ! ( exptime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDBASE ) ) . cas as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDBASE ) , "::" ,
                stringify ! ( cas ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDBASE ) ) . key as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDBASE ) , "::" ,
                stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDBASE ) ) . _hashkey as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDBASE ) , "::" ,
                stringify ! ( _hashkey ) ));
}
impl Clone for lcb_CMDBASE {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_RESPBASE {
    pub cookie: *mut ::std::os::raw::c_void,
    pub key: *const ::std::os::raw::c_void,
    pub nkey: lcb_SIZE,
    pub cas: lcb_CAS,
    pub rc: lcb_error_t,
    pub version: lcb_U16,
    pub rflags: lcb_U16,
}
#[test]
fn bindgen_test_layout_lcb_RESPBASE() {
    assert_eq!(::std::mem::size_of::<lcb_RESPBASE>() , 40usize , concat ! (
               "Size of: " , stringify ! ( lcb_RESPBASE ) ));
    assert_eq! (::std::mem::align_of::<lcb_RESPBASE>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_RESPBASE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPBASE ) ) . cookie as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPBASE ) , "::" ,
                stringify ! ( cookie ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPBASE ) ) . key as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPBASE ) , "::" ,
                stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPBASE ) ) . nkey as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPBASE ) , "::" ,
                stringify ! ( nkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPBASE ) ) . cas as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPBASE ) , "::" ,
                stringify ! ( cas ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPBASE ) ) . rc as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPBASE ) , "::" ,
                stringify ! ( rc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPBASE ) ) . version as * const _
                as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPBASE ) , "::" ,
                stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPBASE ) ) . rflags as * const _ as
                usize } , 38usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPBASE ) , "::" ,
                stringify ! ( rflags ) ));
}
impl Clone for lcb_RESPBASE {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_RESPSERVERBASE {
    pub cookie: *mut ::std::os::raw::c_void,
    pub key: *const ::std::os::raw::c_void,
    pub nkey: lcb_SIZE,
    pub cas: lcb_CAS,
    pub rc: lcb_error_t,
    pub version: lcb_U16,
    pub rflags: lcb_U16,
    pub server: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_lcb_RESPSERVERBASE() {
    assert_eq!(::std::mem::size_of::<lcb_RESPSERVERBASE>() , 48usize , concat
               ! ( "Size of: " , stringify ! ( lcb_RESPSERVERBASE ) ));
    assert_eq! (::std::mem::align_of::<lcb_RESPSERVERBASE>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( lcb_RESPSERVERBASE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPSERVERBASE ) ) . cookie as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPSERVERBASE ) ,
                "::" , stringify ! ( cookie ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPSERVERBASE ) ) . key as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPSERVERBASE ) ,
                "::" , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPSERVERBASE ) ) . nkey as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPSERVERBASE ) ,
                "::" , stringify ! ( nkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPSERVERBASE ) ) . cas as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPSERVERBASE ) ,
                "::" , stringify ! ( cas ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPSERVERBASE ) ) . rc as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPSERVERBASE ) ,
                "::" , stringify ! ( rc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPSERVERBASE ) ) . version as *
                const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPSERVERBASE ) ,
                "::" , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPSERVERBASE ) ) . rflags as *
                const _ as usize } , 38usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPSERVERBASE ) ,
                "::" , stringify ! ( rflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPSERVERBASE ) ) . server as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPSERVERBASE ) ,
                "::" , stringify ! ( server ) ));
}
impl Clone for lcb_RESPSERVERBASE {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_MUTATION_TOKEN {
    pub uuid_: lcb_U64,
    pub seqno_: lcb_U64,
    pub vbid_: lcb_U16,
}
#[test]
fn bindgen_test_layout_lcb_MUTATION_TOKEN() {
    assert_eq!(::std::mem::size_of::<lcb_MUTATION_TOKEN>() , 24usize , concat
               ! ( "Size of: " , stringify ! ( lcb_MUTATION_TOKEN ) ));
    assert_eq! (::std::mem::align_of::<lcb_MUTATION_TOKEN>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( lcb_MUTATION_TOKEN ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_MUTATION_TOKEN ) ) . uuid_ as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_MUTATION_TOKEN ) ,
                "::" , stringify ! ( uuid_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_MUTATION_TOKEN ) ) . seqno_ as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_MUTATION_TOKEN ) ,
                "::" , stringify ! ( seqno_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_MUTATION_TOKEN ) ) . vbid_ as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_MUTATION_TOKEN ) ,
                "::" , stringify ! ( vbid_ ) ));
}
impl Clone for lcb_MUTATION_TOKEN {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum lcb_RESPFLAGS {
    LCB_RESP_F_FINAL = 1,
    LCB_RESP_F_CLIENTGEN = 2,
    LCB_RESP_F_NMVGEN = 4,
    LCB_RESP_F_EXTDATA = 8,
    LCB_RESP_F_SDSINGLE = 16,
    LCB_RESP_F_ERRINFO = 32,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum lcb_CALLBACKTYPE {
    LCB_CALLBACK_DEFAULT = 0,
    LCB_CALLBACK_GET = 1,
    LCB_CALLBACK_STORE = 2,
    LCB_CALLBACK_COUNTER = 3,
    LCB_CALLBACK_TOUCH = 4,
    LCB_CALLBACK_REMOVE = 5,
    LCB_CALLBACK_UNLOCK = 6,
    LCB_CALLBACK_STATS = 7,
    LCB_CALLBACK_VERSIONS = 8,
    LCB_CALLBACK_VERBOSITY = 9,
    LCB_CALLBACK_FLUSH = 10,
    LCB_CALLBACK_OBSERVE = 11,
    LCB_CALLBACK_GETREPLICA = 12,
    LCB_CALLBACK_ENDURE = 13,
    LCB_CALLBACK_HTTP = 14,
    LCB_CALLBACK_CBFLUSH = 15,
    LCB_CALLBACK_OBSEQNO = 16,
    LCB_CALLBACK_STOREDUR = 17,
    LCB_CALLBACK_SDLOOKUP = 18,
    LCB_CALLBACK_SDMUTATE = 19,
    LCB_CALLBACK__MAX = 20,
}
pub type lcb_RESPCALLBACK =
    ::std::option::Option<unsafe extern "C" fn(instance: lcb_t,
                                               cbtype: ::std::os::raw::c_int,
                                               resp: *const lcb_RESPBASE)>;
extern "C" {
    pub fn lcb_install_callback3(instance: lcb_t,
                                 cbtype: ::std::os::raw::c_int,
                                 cb: lcb_RESPCALLBACK) -> lcb_RESPCALLBACK;
}
extern "C" {
    pub fn lcb_get_callback3(instance: lcb_t, cbtype: ::std::os::raw::c_int)
     -> lcb_RESPCALLBACK;
}
extern "C" {
    pub fn lcb_strcbtype(cbtype: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_CMDGET {
    pub cmdflags: lcb_U32,
    pub exptime: lcb_U32,
    pub cas: lcb_U64,
    pub key: lcb_KEYBUF,
    pub _hashkey: lcb_KEYBUF,
    pub lock: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_lcb_CMDGET() {
    assert_eq!(::std::mem::size_of::<lcb_CMDGET>() , 72usize , concat ! (
               "Size of: " , stringify ! ( lcb_CMDGET ) ));
    assert_eq! (::std::mem::align_of::<lcb_CMDGET>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_CMDGET ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDGET ) ) . cmdflags as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDGET ) , "::" ,
                stringify ! ( cmdflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDGET ) ) . exptime as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDGET ) , "::" ,
                stringify ! ( exptime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDGET ) ) . cas as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDGET ) , "::" ,
                stringify ! ( cas ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDGET ) ) . key as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDGET ) , "::" ,
                stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDGET ) ) . _hashkey as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDGET ) , "::" ,
                stringify ! ( _hashkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDGET ) ) . lock as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDGET ) , "::" ,
                stringify ! ( lock ) ));
}
impl Clone for lcb_CMDGET {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_RESPGET {
    pub cookie: *mut ::std::os::raw::c_void,
    pub key: *const ::std::os::raw::c_void,
    pub nkey: lcb_SIZE,
    pub cas: lcb_CAS,
    pub rc: lcb_error_t,
    pub version: lcb_U16,
    pub rflags: lcb_U16,
    pub value: *const ::std::os::raw::c_void,
    pub nvalue: lcb_SIZE,
    pub bufh: *mut ::std::os::raw::c_void,
    pub datatype: lcb_datatype_t,
    pub itmflags: lcb_U32,
}
#[test]
fn bindgen_test_layout_lcb_RESPGET() {
    assert_eq!(::std::mem::size_of::<lcb_RESPGET>() , 72usize , concat ! (
               "Size of: " , stringify ! ( lcb_RESPGET ) ));
    assert_eq! (::std::mem::align_of::<lcb_RESPGET>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_RESPGET ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPGET ) ) . cookie as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPGET ) , "::" ,
                stringify ! ( cookie ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPGET ) ) . key as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPGET ) , "::" ,
                stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPGET ) ) . nkey as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPGET ) , "::" ,
                stringify ! ( nkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPGET ) ) . cas as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPGET ) , "::" ,
                stringify ! ( cas ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPGET ) ) . rc as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPGET ) , "::" ,
                stringify ! ( rc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPGET ) ) . version as * const _ as
                usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPGET ) , "::" ,
                stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPGET ) ) . rflags as * const _ as
                usize } , 38usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPGET ) , "::" ,
                stringify ! ( rflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPGET ) ) . value as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPGET ) , "::" ,
                stringify ! ( value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPGET ) ) . nvalue as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPGET ) , "::" ,
                stringify ! ( nvalue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPGET ) ) . bufh as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPGET ) , "::" ,
                stringify ! ( bufh ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPGET ) ) . datatype as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPGET ) , "::" ,
                stringify ! ( datatype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPGET ) ) . itmflags as * const _
                as usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPGET ) , "::" ,
                stringify ! ( itmflags ) ));
}
impl Clone for lcb_RESPGET {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn lcb_get3(instance: lcb_t, cookie: *const ::std::os::raw::c_void,
                    cmd: *const lcb_CMDGET) -> lcb_error_t;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum lcb_replica_t {
    LCB_REPLICA_FIRST = 0,
    LCB_REPLICA_ALL = 1,
    LCB_REPLICA_SELECT = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_CMDGETREPLICA {
    pub cmdflags: lcb_U32,
    pub exptime: lcb_U32,
    pub cas: lcb_U64,
    pub key: lcb_KEYBUF,
    pub _hashkey: lcb_KEYBUF,
    pub strategy: lcb_replica_t,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_lcb_CMDGETREPLICA() {
    assert_eq!(::std::mem::size_of::<lcb_CMDGETREPLICA>() , 72usize , concat !
               ( "Size of: " , stringify ! ( lcb_CMDGETREPLICA ) ));
    assert_eq! (::std::mem::align_of::<lcb_CMDGETREPLICA>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( lcb_CMDGETREPLICA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDGETREPLICA ) ) . cmdflags as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDGETREPLICA ) ,
                "::" , stringify ! ( cmdflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDGETREPLICA ) ) . exptime as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDGETREPLICA ) ,
                "::" , stringify ! ( exptime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDGETREPLICA ) ) . cas as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDGETREPLICA ) ,
                "::" , stringify ! ( cas ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDGETREPLICA ) ) . key as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDGETREPLICA ) ,
                "::" , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDGETREPLICA ) ) . _hashkey as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDGETREPLICA ) ,
                "::" , stringify ! ( _hashkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDGETREPLICA ) ) . strategy as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDGETREPLICA ) ,
                "::" , stringify ! ( strategy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDGETREPLICA ) ) . index as * const
                _ as usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDGETREPLICA ) ,
                "::" , stringify ! ( index ) ));
}
impl Clone for lcb_CMDGETREPLICA {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn lcb_rget3(instance: lcb_t, cookie: *const ::std::os::raw::c_void,
                     cmd: *const lcb_CMDGETREPLICA) -> lcb_error_t;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum lcb_storage_t {
    LCB_ADD = 1,
    LCB_REPLACE = 2,
    LCB_SET = 3,
    LCB_UPSERT = 0,
    LCB_APPEND = 4,
    LCB_PREPEND = 5,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_CMDSTORE {
    pub cmdflags: lcb_U32,
    pub exptime: lcb_U32,
    pub cas: lcb_U64,
    pub key: lcb_KEYBUF,
    pub _hashkey: lcb_KEYBUF,
    pub value: lcb_VALBUF,
    pub flags: lcb_U32,
    pub datatype: lcb_datatype_t,
    pub operation: lcb_storage_t,
}
#[test]
fn bindgen_test_layout_lcb_CMDSTORE() {
    assert_eq!(::std::mem::size_of::<lcb_CMDSTORE>() , 104usize , concat ! (
               "Size of: " , stringify ! ( lcb_CMDSTORE ) ));
    assert_eq! (::std::mem::align_of::<lcb_CMDSTORE>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_CMDSTORE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDSTORE ) ) . cmdflags as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDSTORE ) , "::" ,
                stringify ! ( cmdflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDSTORE ) ) . exptime as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDSTORE ) , "::" ,
                stringify ! ( exptime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDSTORE ) ) . cas as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDSTORE ) , "::" ,
                stringify ! ( cas ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDSTORE ) ) . key as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDSTORE ) , "::" ,
                stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDSTORE ) ) . _hashkey as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDSTORE ) , "::" ,
                stringify ! ( _hashkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDSTORE ) ) . value as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDSTORE ) , "::" ,
                stringify ! ( value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDSTORE ) ) . flags as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDSTORE ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDSTORE ) ) . datatype as * const _
                as usize } , 92usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDSTORE ) , "::" ,
                stringify ! ( datatype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDSTORE ) ) . operation as * const _
                as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDSTORE ) , "::" ,
                stringify ! ( operation ) ));
}
impl Clone for lcb_CMDSTORE {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_RESPSTORE {
    pub cookie: *mut ::std::os::raw::c_void,
    pub key: *const ::std::os::raw::c_void,
    pub nkey: lcb_SIZE,
    pub cas: lcb_CAS,
    pub rc: lcb_error_t,
    pub version: lcb_U16,
    pub rflags: lcb_U16,
    pub op: lcb_storage_t,
}
#[test]
fn bindgen_test_layout_lcb_RESPSTORE() {
    assert_eq!(::std::mem::size_of::<lcb_RESPSTORE>() , 48usize , concat ! (
               "Size of: " , stringify ! ( lcb_RESPSTORE ) ));
    assert_eq! (::std::mem::align_of::<lcb_RESPSTORE>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_RESPSTORE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPSTORE ) ) . cookie as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPSTORE ) , "::"
                , stringify ! ( cookie ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPSTORE ) ) . key as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPSTORE ) , "::"
                , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPSTORE ) ) . nkey as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPSTORE ) , "::"
                , stringify ! ( nkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPSTORE ) ) . cas as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPSTORE ) , "::"
                , stringify ! ( cas ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPSTORE ) ) . rc as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPSTORE ) , "::"
                , stringify ! ( rc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPSTORE ) ) . version as * const _
                as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPSTORE ) , "::"
                , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPSTORE ) ) . rflags as * const _
                as usize } , 38usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPSTORE ) , "::"
                , stringify ! ( rflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPSTORE ) ) . op as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPSTORE ) , "::"
                , stringify ! ( op ) ));
}
impl Clone for lcb_RESPSTORE {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn lcb_store3(instance: lcb_t, cookie: *const ::std::os::raw::c_void,
                      cmd: *const lcb_CMDSTORE) -> lcb_error_t;
}
pub type lcb_CMDREMOVE = lcb_CMDBASE;
pub type lcb_RESPREMOVE = lcb_RESPBASE;
extern "C" {
    pub fn lcb_remove3(instance: lcb_t, cookie: *const ::std::os::raw::c_void,
                       cmd: *const lcb_CMDREMOVE) -> lcb_error_t;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_MULTICMD_CTX_st {
    pub addcmd: ::std::option::Option<unsafe extern "C" fn(ctx:
                                                               *mut lcb_MULTICMD_CTX_st,
                                                           cmd:
                                                               *const lcb_CMDBASE)
                                          -> lcb_error_t>,
    pub done: ::std::option::Option<unsafe extern "C" fn(ctx:
                                                             *mut lcb_MULTICMD_CTX_st,
                                                         cookie:
                                                             *const ::std::os::raw::c_void)
                                        -> lcb_error_t>,
    pub fail: ::std::option::Option<unsafe extern "C" fn(ctx:
                                                             *mut lcb_MULTICMD_CTX_st)>,
}
#[test]
fn bindgen_test_layout_lcb_MULTICMD_CTX_st() {
    assert_eq!(::std::mem::size_of::<lcb_MULTICMD_CTX_st>() , 24usize , concat
               ! ( "Size of: " , stringify ! ( lcb_MULTICMD_CTX_st ) ));
    assert_eq! (::std::mem::align_of::<lcb_MULTICMD_CTX_st>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( lcb_MULTICMD_CTX_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_MULTICMD_CTX_st ) ) . addcmd as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_MULTICMD_CTX_st ) ,
                "::" , stringify ! ( addcmd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_MULTICMD_CTX_st ) ) . done as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_MULTICMD_CTX_st ) ,
                "::" , stringify ! ( done ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_MULTICMD_CTX_st ) ) . fail as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_MULTICMD_CTX_st ) ,
                "::" , stringify ! ( fail ) ));
}
impl Clone for lcb_MULTICMD_CTX_st {
    fn clone(&self) -> Self { *self }
}
pub type lcb_MULTICMD_CTX = lcb_MULTICMD_CTX_st;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum lcb_DURMODE {
    LCB_DURABILITY_MODE_DEFAULT = 0,
    LCB_DURABILITY_MODE_CAS = 1,
    LCB_DURABILITY_MODE_SEQNO = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_DURABILITYOPTSv0 {
    pub timeout: lcb_U32,
    pub interval: lcb_U32,
    pub persist_to: lcb_U16,
    pub replicate_to: lcb_U16,
    pub check_delete: lcb_U8,
    pub cap_max: lcb_U8,
    pub pollopts: lcb_U8,
}
#[test]
fn bindgen_test_layout_lcb_DURABILITYOPTSv0() {
    assert_eq!(::std::mem::size_of::<lcb_DURABILITYOPTSv0>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( lcb_DURABILITYOPTSv0 )
               ));
    assert_eq! (::std::mem::align_of::<lcb_DURABILITYOPTSv0>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( lcb_DURABILITYOPTSv0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_DURABILITYOPTSv0 ) ) . timeout as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_DURABILITYOPTSv0 )
                , "::" , stringify ! ( timeout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_DURABILITYOPTSv0 ) ) . interval as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_DURABILITYOPTSv0 )
                , "::" , stringify ! ( interval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_DURABILITYOPTSv0 ) ) . persist_to as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_DURABILITYOPTSv0 )
                , "::" , stringify ! ( persist_to ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_DURABILITYOPTSv0 ) ) . replicate_to
                as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_DURABILITYOPTSv0 )
                , "::" , stringify ! ( replicate_to ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_DURABILITYOPTSv0 ) ) . check_delete
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_DURABILITYOPTSv0 )
                , "::" , stringify ! ( check_delete ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_DURABILITYOPTSv0 ) ) . cap_max as *
                const _ as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_DURABILITYOPTSv0 )
                , "::" , stringify ! ( cap_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_DURABILITYOPTSv0 ) ) . pollopts as *
                const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_DURABILITYOPTSv0 )
                , "::" , stringify ! ( pollopts ) ));
}
impl Clone for lcb_DURABILITYOPTSv0 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_durability_opts_st {
    pub version: ::std::os::raw::c_int,
    pub v: lcb_durability_opts_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_durability_opts_st__bindgen_ty_1 {
    pub v0: __BindgenUnionField<lcb_DURABILITYOPTSv0>,
    pub bindgen_union_field: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_lcb_durability_opts_st__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<lcb_durability_opts_st__bindgen_ty_1>() ,
               16usize , concat ! (
               "Size of: " , stringify ! (
               lcb_durability_opts_st__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<lcb_durability_opts_st__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                lcb_durability_opts_st__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_durability_opts_st__bindgen_ty_1 ) )
                . v0 as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_durability_opts_st__bindgen_ty_1 ) , "::" , stringify ! (
                v0 ) ));
}
impl Clone for lcb_durability_opts_st__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_lcb_durability_opts_st() {
    assert_eq!(::std::mem::size_of::<lcb_durability_opts_st>() , 20usize ,
               concat ! ( "Size of: " , stringify ! ( lcb_durability_opts_st )
               ));
    assert_eq! (::std::mem::align_of::<lcb_durability_opts_st>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( lcb_durability_opts_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_durability_opts_st ) ) . version as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_durability_opts_st
                ) , "::" , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_durability_opts_st ) ) . v as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_durability_opts_st
                ) , "::" , stringify ! ( v ) ));
}
impl Clone for lcb_durability_opts_st {
    fn clone(&self) -> Self { *self }
}
pub type lcb_durability_opts_t = lcb_durability_opts_st;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_CMDENDURE {
    pub cmdflags: lcb_U32,
    pub exptime: lcb_U32,
    pub cas: lcb_U64,
    pub key: lcb_KEYBUF,
    pub _hashkey: lcb_KEYBUF,
    pub mutation_token: *const lcb_MUTATION_TOKEN,
}
#[test]
fn bindgen_test_layout_lcb_CMDENDURE() {
    assert_eq!(::std::mem::size_of::<lcb_CMDENDURE>() , 72usize , concat ! (
               "Size of: " , stringify ! ( lcb_CMDENDURE ) ));
    assert_eq! (::std::mem::align_of::<lcb_CMDENDURE>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_CMDENDURE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDENDURE ) ) . cmdflags as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDENDURE ) , "::"
                , stringify ! ( cmdflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDENDURE ) ) . exptime as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDENDURE ) , "::"
                , stringify ! ( exptime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDENDURE ) ) . cas as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDENDURE ) , "::"
                , stringify ! ( cas ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDENDURE ) ) . key as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDENDURE ) , "::"
                , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDENDURE ) ) . _hashkey as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDENDURE ) , "::"
                , stringify ! ( _hashkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDENDURE ) ) . mutation_token as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDENDURE ) , "::"
                , stringify ! ( mutation_token ) ));
}
impl Clone for lcb_CMDENDURE {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_RESPENDURE {
    pub cookie: *mut ::std::os::raw::c_void,
    pub key: *const ::std::os::raw::c_void,
    pub nkey: lcb_SIZE,
    pub cas: lcb_CAS,
    pub rc: lcb_error_t,
    pub version: lcb_U16,
    pub rflags: lcb_U16,
    pub nresponses: lcb_U16,
    pub exists_master: lcb_U8,
    pub persisted_master: lcb_U8,
    pub npersisted: lcb_U8,
    pub nreplicated: lcb_U8,
}
#[test]
fn bindgen_test_layout_lcb_RESPENDURE() {
    assert_eq!(::std::mem::size_of::<lcb_RESPENDURE>() , 48usize , concat ! (
               "Size of: " , stringify ! ( lcb_RESPENDURE ) ));
    assert_eq! (::std::mem::align_of::<lcb_RESPENDURE>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_RESPENDURE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPENDURE ) ) . cookie as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPENDURE ) , "::"
                , stringify ! ( cookie ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPENDURE ) ) . key as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPENDURE ) , "::"
                , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPENDURE ) ) . nkey as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPENDURE ) , "::"
                , stringify ! ( nkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPENDURE ) ) . cas as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPENDURE ) , "::"
                , stringify ! ( cas ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPENDURE ) ) . rc as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPENDURE ) , "::"
                , stringify ! ( rc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPENDURE ) ) . version as * const _
                as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPENDURE ) , "::"
                , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPENDURE ) ) . rflags as * const _
                as usize } , 38usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPENDURE ) , "::"
                , stringify ! ( rflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPENDURE ) ) . nresponses as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPENDURE ) , "::"
                , stringify ! ( nresponses ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPENDURE ) ) . exists_master as *
                const _ as usize } , 42usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPENDURE ) , "::"
                , stringify ! ( exists_master ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPENDURE ) ) . persisted_master as
                * const _ as usize } , 43usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPENDURE ) , "::"
                , stringify ! ( persisted_master ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPENDURE ) ) . npersisted as *
                const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPENDURE ) , "::"
                , stringify ! ( npersisted ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPENDURE ) ) . nreplicated as *
                const _ as usize } , 45usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPENDURE ) , "::"
                , stringify ! ( nreplicated ) ));
}
impl Clone for lcb_RESPENDURE {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn lcb_endure3_ctxnew(instance: lcb_t,
                              options: *const lcb_durability_opts_t,
                              err: *mut lcb_error_t) -> *mut lcb_MULTICMD_CTX;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_CMDSTOREDUR {
    pub cmdflags: lcb_U32,
    pub exptime: lcb_U32,
    pub cas: lcb_U64,
    pub key: lcb_KEYBUF,
    pub _hashkey: lcb_KEYBUF,
    pub value: lcb_VALBUF,
    pub flags: lcb_U32,
    pub datatype: lcb_datatype_t,
    pub operation: lcb_storage_t,
    pub persist_to: ::std::os::raw::c_char,
    pub replicate_to: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_lcb_CMDSTOREDUR() {
    assert_eq!(::std::mem::size_of::<lcb_CMDSTOREDUR>() , 104usize , concat !
               ( "Size of: " , stringify ! ( lcb_CMDSTOREDUR ) ));
    assert_eq! (::std::mem::align_of::<lcb_CMDSTOREDUR>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( lcb_CMDSTOREDUR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDSTOREDUR ) ) . cmdflags as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDSTOREDUR ) ,
                "::" , stringify ! ( cmdflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDSTOREDUR ) ) . exptime as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDSTOREDUR ) ,
                "::" , stringify ! ( exptime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDSTOREDUR ) ) . cas as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDSTOREDUR ) ,
                "::" , stringify ! ( cas ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDSTOREDUR ) ) . key as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDSTOREDUR ) ,
                "::" , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDSTOREDUR ) ) . _hashkey as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDSTOREDUR ) ,
                "::" , stringify ! ( _hashkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDSTOREDUR ) ) . value as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDSTOREDUR ) ,
                "::" , stringify ! ( value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDSTOREDUR ) ) . flags as * const _
                as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDSTOREDUR ) ,
                "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDSTOREDUR ) ) . datatype as * const
                _ as usize } , 92usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDSTOREDUR ) ,
                "::" , stringify ! ( datatype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDSTOREDUR ) ) . operation as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDSTOREDUR ) ,
                "::" , stringify ! ( operation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDSTOREDUR ) ) . persist_to as *
                const _ as usize } , 100usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDSTOREDUR ) ,
                "::" , stringify ! ( persist_to ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDSTOREDUR ) ) . replicate_to as *
                const _ as usize } , 101usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDSTOREDUR ) ,
                "::" , stringify ! ( replicate_to ) ));
}
impl Clone for lcb_CMDSTOREDUR {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_RESPSTOREDUR {
    pub cookie: *mut ::std::os::raw::c_void,
    pub key: *const ::std::os::raw::c_void,
    pub nkey: lcb_SIZE,
    pub cas: lcb_CAS,
    pub rc: lcb_error_t,
    pub version: lcb_U16,
    pub rflags: lcb_U16,
    pub dur_resp: *const lcb_RESPENDURE,
    pub store_ok: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_lcb_RESPSTOREDUR() {
    assert_eq!(::std::mem::size_of::<lcb_RESPSTOREDUR>() , 56usize , concat !
               ( "Size of: " , stringify ! ( lcb_RESPSTOREDUR ) ));
    assert_eq! (::std::mem::align_of::<lcb_RESPSTOREDUR>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( lcb_RESPSTOREDUR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPSTOREDUR ) ) . cookie as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPSTOREDUR ) ,
                "::" , stringify ! ( cookie ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPSTOREDUR ) ) . key as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPSTOREDUR ) ,
                "::" , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPSTOREDUR ) ) . nkey as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPSTOREDUR ) ,
                "::" , stringify ! ( nkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPSTOREDUR ) ) . cas as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPSTOREDUR ) ,
                "::" , stringify ! ( cas ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPSTOREDUR ) ) . rc as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPSTOREDUR ) ,
                "::" , stringify ! ( rc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPSTOREDUR ) ) . version as * const
                _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPSTOREDUR ) ,
                "::" , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPSTOREDUR ) ) . rflags as * const
                _ as usize } , 38usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPSTOREDUR ) ,
                "::" , stringify ! ( rflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPSTOREDUR ) ) . dur_resp as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPSTOREDUR ) ,
                "::" , stringify ! ( dur_resp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPSTOREDUR ) ) . store_ok as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPSTOREDUR ) ,
                "::" , stringify ! ( store_ok ) ));
}
impl Clone for lcb_RESPSTOREDUR {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn lcb_storedur3(instance: lcb_t,
                         cookie: *const ::std::os::raw::c_void,
                         cmd: *const lcb_CMDSTOREDUR) -> lcb_error_t;
}
extern "C" {
    pub fn lcb_durability_validate(instance: lcb_t, persist_to: *mut lcb_U16,
                                   replicate_to: *mut lcb_U16,
                                   options: ::std::os::raw::c_int)
     -> lcb_error_t;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_CMDOBSERVE {
    pub cmdflags: lcb_U32,
    pub exptime: lcb_U32,
    pub cas: lcb_U64,
    pub key: lcb_KEYBUF,
    pub _hashkey: lcb_KEYBUF,
    pub servers_: *const lcb_U16,
    pub nservers_: usize,
}
#[test]
fn bindgen_test_layout_lcb_CMDOBSERVE() {
    assert_eq!(::std::mem::size_of::<lcb_CMDOBSERVE>() , 80usize , concat ! (
               "Size of: " , stringify ! ( lcb_CMDOBSERVE ) ));
    assert_eq! (::std::mem::align_of::<lcb_CMDOBSERVE>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_CMDOBSERVE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDOBSERVE ) ) . cmdflags as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDOBSERVE ) , "::"
                , stringify ! ( cmdflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDOBSERVE ) ) . exptime as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDOBSERVE ) , "::"
                , stringify ! ( exptime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDOBSERVE ) ) . cas as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDOBSERVE ) , "::"
                , stringify ! ( cas ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDOBSERVE ) ) . key as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDOBSERVE ) , "::"
                , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDOBSERVE ) ) . _hashkey as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDOBSERVE ) , "::"
                , stringify ! ( _hashkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDOBSERVE ) ) . servers_ as * const
                _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDOBSERVE ) , "::"
                , stringify ! ( servers_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDOBSERVE ) ) . nservers_ as * const
                _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDOBSERVE ) , "::"
                , stringify ! ( nservers_ ) ));
}
impl Clone for lcb_CMDOBSERVE {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum lcb_observe_t {
    LCB_OBSERVE_FOUND = 0,
    LCB_OBSERVE_PERSISTED = 1,
    LCB_OBSERVE_NOT_FOUND = 128,
    LCB_OBSERVE_LOGICALLY_DELETED = 129,
    LCB_OBSERVE_MAX = 130,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_RESPOBSERVE {
    pub cookie: *mut ::std::os::raw::c_void,
    pub key: *const ::std::os::raw::c_void,
    pub nkey: lcb_SIZE,
    pub cas: lcb_CAS,
    pub rc: lcb_error_t,
    pub version: lcb_U16,
    pub rflags: lcb_U16,
    pub status: lcb_U8,
    pub ismaster: lcb_U8,
    pub ttp: lcb_U32,
    pub ttr: lcb_U32,
}
#[test]
fn bindgen_test_layout_lcb_RESPOBSERVE() {
    assert_eq!(::std::mem::size_of::<lcb_RESPOBSERVE>() , 56usize , concat ! (
               "Size of: " , stringify ! ( lcb_RESPOBSERVE ) ));
    assert_eq! (::std::mem::align_of::<lcb_RESPOBSERVE>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( lcb_RESPOBSERVE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPOBSERVE ) ) . cookie as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPOBSERVE ) ,
                "::" , stringify ! ( cookie ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPOBSERVE ) ) . key as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPOBSERVE ) ,
                "::" , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPOBSERVE ) ) . nkey as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPOBSERVE ) ,
                "::" , stringify ! ( nkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPOBSERVE ) ) . cas as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPOBSERVE ) ,
                "::" , stringify ! ( cas ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPOBSERVE ) ) . rc as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPOBSERVE ) ,
                "::" , stringify ! ( rc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPOBSERVE ) ) . version as * const
                _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPOBSERVE ) ,
                "::" , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPOBSERVE ) ) . rflags as * const _
                as usize } , 38usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPOBSERVE ) ,
                "::" , stringify ! ( rflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPOBSERVE ) ) . status as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPOBSERVE ) ,
                "::" , stringify ! ( status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPOBSERVE ) ) . ismaster as * const
                _ as usize } , 41usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPOBSERVE ) ,
                "::" , stringify ! ( ismaster ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPOBSERVE ) ) . ttp as * const _ as
                usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPOBSERVE ) ,
                "::" , stringify ! ( ttp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPOBSERVE ) ) . ttr as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPOBSERVE ) ,
                "::" , stringify ! ( ttr ) ));
}
impl Clone for lcb_RESPOBSERVE {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn lcb_observe3_ctxnew(instance: lcb_t) -> *mut lcb_MULTICMD_CTX;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_CMDOBSEQNO {
    pub cmdflags: lcb_U32,
    pub exptime: lcb_U32,
    pub cas: lcb_U64,
    pub key: lcb_KEYBUF,
    pub _hashkey: lcb_KEYBUF,
    pub server_index: lcb_U16,
    pub vbid: lcb_U16,
    pub uuid: lcb_U64,
}
#[test]
fn bindgen_test_layout_lcb_CMDOBSEQNO() {
    assert_eq!(::std::mem::size_of::<lcb_CMDOBSEQNO>() , 80usize , concat ! (
               "Size of: " , stringify ! ( lcb_CMDOBSEQNO ) ));
    assert_eq! (::std::mem::align_of::<lcb_CMDOBSEQNO>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_CMDOBSEQNO ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDOBSEQNO ) ) . cmdflags as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDOBSEQNO ) , "::"
                , stringify ! ( cmdflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDOBSEQNO ) ) . exptime as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDOBSEQNO ) , "::"
                , stringify ! ( exptime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDOBSEQNO ) ) . cas as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDOBSEQNO ) , "::"
                , stringify ! ( cas ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDOBSEQNO ) ) . key as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDOBSEQNO ) , "::"
                , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDOBSEQNO ) ) . _hashkey as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDOBSEQNO ) , "::"
                , stringify ! ( _hashkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDOBSEQNO ) ) . server_index as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDOBSEQNO ) , "::"
                , stringify ! ( server_index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDOBSEQNO ) ) . vbid as * const _ as
                usize } , 66usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDOBSEQNO ) , "::"
                , stringify ! ( vbid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDOBSEQNO ) ) . uuid as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDOBSEQNO ) , "::"
                , stringify ! ( uuid ) ));
}
impl Clone for lcb_CMDOBSEQNO {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_RESPOBSEQNO {
    pub cookie: *mut ::std::os::raw::c_void,
    pub key: *const ::std::os::raw::c_void,
    pub nkey: lcb_SIZE,
    pub cas: lcb_CAS,
    pub rc: lcb_error_t,
    pub version: lcb_U16,
    pub rflags: lcb_U16,
    pub vbid: lcb_U16,
    pub server_index: lcb_U16,
    pub cur_uuid: lcb_U64,
    pub persisted_seqno: lcb_U64,
    pub mem_seqno: lcb_U64,
    pub old_uuid: lcb_U64,
    pub old_seqno: lcb_U64,
}
#[test]
fn bindgen_test_layout_lcb_RESPOBSEQNO() {
    assert_eq!(::std::mem::size_of::<lcb_RESPOBSEQNO>() , 88usize , concat ! (
               "Size of: " , stringify ! ( lcb_RESPOBSEQNO ) ));
    assert_eq! (::std::mem::align_of::<lcb_RESPOBSEQNO>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( lcb_RESPOBSEQNO ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPOBSEQNO ) ) . cookie as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPOBSEQNO ) ,
                "::" , stringify ! ( cookie ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPOBSEQNO ) ) . key as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPOBSEQNO ) ,
                "::" , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPOBSEQNO ) ) . nkey as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPOBSEQNO ) ,
                "::" , stringify ! ( nkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPOBSEQNO ) ) . cas as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPOBSEQNO ) ,
                "::" , stringify ! ( cas ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPOBSEQNO ) ) . rc as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPOBSEQNO ) ,
                "::" , stringify ! ( rc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPOBSEQNO ) ) . version as * const
                _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPOBSEQNO ) ,
                "::" , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPOBSEQNO ) ) . rflags as * const _
                as usize } , 38usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPOBSEQNO ) ,
                "::" , stringify ! ( rflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPOBSEQNO ) ) . vbid as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPOBSEQNO ) ,
                "::" , stringify ! ( vbid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPOBSEQNO ) ) . server_index as *
                const _ as usize } , 42usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPOBSEQNO ) ,
                "::" , stringify ! ( server_index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPOBSEQNO ) ) . cur_uuid as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPOBSEQNO ) ,
                "::" , stringify ! ( cur_uuid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPOBSEQNO ) ) . persisted_seqno as
                * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPOBSEQNO ) ,
                "::" , stringify ! ( persisted_seqno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPOBSEQNO ) ) . mem_seqno as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPOBSEQNO ) ,
                "::" , stringify ! ( mem_seqno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPOBSEQNO ) ) . old_uuid as * const
                _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPOBSEQNO ) ,
                "::" , stringify ! ( old_uuid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPOBSEQNO ) ) . old_seqno as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPOBSEQNO ) ,
                "::" , stringify ! ( old_seqno ) ));
}
impl Clone for lcb_RESPOBSEQNO {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn lcb_observe_seqno3(instance: lcb_t,
                              cookie: *const ::std::os::raw::c_void,
                              cmd: *const lcb_CMDOBSEQNO) -> lcb_error_t;
}
extern "C" {
    pub fn lcb_resp_get_mutation_token(cbtype: ::std::os::raw::c_int,
                                       rb: *const lcb_RESPBASE)
     -> *const lcb_MUTATION_TOKEN;
}
extern "C" {
    pub fn lcb_get_mutation_token(instance: lcb_t, kb: *const lcb_KEYBUF,
                                  errp: *mut lcb_error_t)
     -> *const lcb_MUTATION_TOKEN;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_CMDCOUNTER {
    pub cmdflags: lcb_U32,
    pub exptime: lcb_U32,
    pub cas: lcb_U64,
    pub key: lcb_KEYBUF,
    pub _hashkey: lcb_KEYBUF,
    pub delta: lcb_int64_t,
    pub initial: lcb_U64,
    pub create: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_lcb_CMDCOUNTER() {
    assert_eq!(::std::mem::size_of::<lcb_CMDCOUNTER>() , 88usize , concat ! (
               "Size of: " , stringify ! ( lcb_CMDCOUNTER ) ));
    assert_eq! (::std::mem::align_of::<lcb_CMDCOUNTER>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_CMDCOUNTER ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDCOUNTER ) ) . cmdflags as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDCOUNTER ) , "::"
                , stringify ! ( cmdflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDCOUNTER ) ) . exptime as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDCOUNTER ) , "::"
                , stringify ! ( exptime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDCOUNTER ) ) . cas as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDCOUNTER ) , "::"
                , stringify ! ( cas ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDCOUNTER ) ) . key as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDCOUNTER ) , "::"
                , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDCOUNTER ) ) . _hashkey as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDCOUNTER ) , "::"
                , stringify ! ( _hashkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDCOUNTER ) ) . delta as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDCOUNTER ) , "::"
                , stringify ! ( delta ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDCOUNTER ) ) . initial as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDCOUNTER ) , "::"
                , stringify ! ( initial ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDCOUNTER ) ) . create as * const _
                as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDCOUNTER ) , "::"
                , stringify ! ( create ) ));
}
impl Clone for lcb_CMDCOUNTER {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_RESPCOUNTER {
    pub cookie: *mut ::std::os::raw::c_void,
    pub key: *const ::std::os::raw::c_void,
    pub nkey: lcb_SIZE,
    pub cas: lcb_CAS,
    pub rc: lcb_error_t,
    pub version: lcb_U16,
    pub rflags: lcb_U16,
    pub value: lcb_U64,
}
#[test]
fn bindgen_test_layout_lcb_RESPCOUNTER() {
    assert_eq!(::std::mem::size_of::<lcb_RESPCOUNTER>() , 48usize , concat ! (
               "Size of: " , stringify ! ( lcb_RESPCOUNTER ) ));
    assert_eq! (::std::mem::align_of::<lcb_RESPCOUNTER>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( lcb_RESPCOUNTER ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPCOUNTER ) ) . cookie as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPCOUNTER ) ,
                "::" , stringify ! ( cookie ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPCOUNTER ) ) . key as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPCOUNTER ) ,
                "::" , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPCOUNTER ) ) . nkey as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPCOUNTER ) ,
                "::" , stringify ! ( nkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPCOUNTER ) ) . cas as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPCOUNTER ) ,
                "::" , stringify ! ( cas ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPCOUNTER ) ) . rc as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPCOUNTER ) ,
                "::" , stringify ! ( rc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPCOUNTER ) ) . version as * const
                _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPCOUNTER ) ,
                "::" , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPCOUNTER ) ) . rflags as * const _
                as usize } , 38usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPCOUNTER ) ,
                "::" , stringify ! ( rflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPCOUNTER ) ) . value as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPCOUNTER ) ,
                "::" , stringify ! ( value ) ));
}
impl Clone for lcb_RESPCOUNTER {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn lcb_counter3(instance: lcb_t,
                        cookie: *const ::std::os::raw::c_void,
                        cmd: *const lcb_CMDCOUNTER) -> lcb_error_t;
}
pub type lcb_CMDUNLOCK = lcb_CMDBASE;
pub type lcb_RESPUNLOCK = lcb_RESPBASE;
extern "C" {
    pub fn lcb_unlock3(instance: lcb_t, cookie: *const ::std::os::raw::c_void,
                       cmd: *const lcb_CMDUNLOCK) -> lcb_error_t;
}
pub type lcb_CMDTOUCH = lcb_CMDBASE;
pub type lcb_RESPTOUCH = lcb_RESPBASE;
extern "C" {
    pub fn lcb_touch3(instance: lcb_t, cookie: *const ::std::os::raw::c_void,
                      cmd: *const lcb_CMDTOUCH) -> lcb_error_t;
}
pub type lcb_CMDSTATS = lcb_CMDBASE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_RESPSTATS {
    pub cookie: *mut ::std::os::raw::c_void,
    pub key: *const ::std::os::raw::c_void,
    pub nkey: lcb_SIZE,
    pub cas: lcb_CAS,
    pub rc: lcb_error_t,
    pub version: lcb_U16,
    pub rflags: lcb_U16,
    pub server: *const ::std::os::raw::c_char,
    pub value: *const ::std::os::raw::c_char,
    pub nvalue: lcb_SIZE,
}
#[test]
fn bindgen_test_layout_lcb_RESPSTATS() {
    assert_eq!(::std::mem::size_of::<lcb_RESPSTATS>() , 64usize , concat ! (
               "Size of: " , stringify ! ( lcb_RESPSTATS ) ));
    assert_eq! (::std::mem::align_of::<lcb_RESPSTATS>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_RESPSTATS ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPSTATS ) ) . cookie as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPSTATS ) , "::"
                , stringify ! ( cookie ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPSTATS ) ) . key as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPSTATS ) , "::"
                , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPSTATS ) ) . nkey as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPSTATS ) , "::"
                , stringify ! ( nkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPSTATS ) ) . cas as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPSTATS ) , "::"
                , stringify ! ( cas ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPSTATS ) ) . rc as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPSTATS ) , "::"
                , stringify ! ( rc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPSTATS ) ) . version as * const _
                as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPSTATS ) , "::"
                , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPSTATS ) ) . rflags as * const _
                as usize } , 38usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPSTATS ) , "::"
                , stringify ! ( rflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPSTATS ) ) . server as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPSTATS ) , "::"
                , stringify ! ( server ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPSTATS ) ) . value as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPSTATS ) , "::"
                , stringify ! ( value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPSTATS ) ) . nvalue as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPSTATS ) , "::"
                , stringify ! ( nvalue ) ));
}
impl Clone for lcb_RESPSTATS {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn lcb_stats3(instance: lcb_t, cookie: *const ::std::os::raw::c_void,
                      cmd: *const lcb_CMDSTATS) -> lcb_error_t;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_RESPMCVERSION {
    pub cookie: *mut ::std::os::raw::c_void,
    pub key: *const ::std::os::raw::c_void,
    pub nkey: lcb_SIZE,
    pub cas: lcb_CAS,
    pub rc: lcb_error_t,
    pub version: lcb_U16,
    pub rflags: lcb_U16,
    pub server: *const ::std::os::raw::c_char,
    pub mcversion: *const ::std::os::raw::c_char,
    pub nversion: lcb_SIZE,
}
#[test]
fn bindgen_test_layout_lcb_RESPMCVERSION() {
    assert_eq!(::std::mem::size_of::<lcb_RESPMCVERSION>() , 64usize , concat !
               ( "Size of: " , stringify ! ( lcb_RESPMCVERSION ) ));
    assert_eq! (::std::mem::align_of::<lcb_RESPMCVERSION>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( lcb_RESPMCVERSION ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPMCVERSION ) ) . cookie as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPMCVERSION ) ,
                "::" , stringify ! ( cookie ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPMCVERSION ) ) . key as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPMCVERSION ) ,
                "::" , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPMCVERSION ) ) . nkey as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPMCVERSION ) ,
                "::" , stringify ! ( nkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPMCVERSION ) ) . cas as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPMCVERSION ) ,
                "::" , stringify ! ( cas ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPMCVERSION ) ) . rc as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPMCVERSION ) ,
                "::" , stringify ! ( rc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPMCVERSION ) ) . version as *
                const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPMCVERSION ) ,
                "::" , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPMCVERSION ) ) . rflags as * const
                _ as usize } , 38usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPMCVERSION ) ,
                "::" , stringify ! ( rflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPMCVERSION ) ) . server as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPMCVERSION ) ,
                "::" , stringify ! ( server ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPMCVERSION ) ) . mcversion as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPMCVERSION ) ,
                "::" , stringify ! ( mcversion ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPMCVERSION ) ) . nversion as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPMCVERSION ) ,
                "::" , stringify ! ( nversion ) ));
}
impl Clone for lcb_RESPMCVERSION {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn lcb_server_versions3(instance: lcb_t,
                                cookie: *const ::std::os::raw::c_void,
                                cmd: *const lcb_CMDBASE) -> lcb_error_t;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum lcb_verbosity_level_t {
    LCB_VERBOSITY_DETAIL = 0,
    LCB_VERBOSITY_DEBUG = 1,
    LCB_VERBOSITY_INFO = 2,
    LCB_VERBOSITY_WARNING = 3,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_CMDVERBOSITY {
    pub cmdflags: lcb_U32,
    pub exptime: lcb_U32,
    pub cas: lcb_U64,
    pub key: lcb_KEYBUF,
    pub _hashkey: lcb_KEYBUF,
    pub server: *const ::std::os::raw::c_char,
    pub level: lcb_verbosity_level_t,
}
#[test]
fn bindgen_test_layout_lcb_CMDVERBOSITY() {
    assert_eq!(::std::mem::size_of::<lcb_CMDVERBOSITY>() , 80usize , concat !
               ( "Size of: " , stringify ! ( lcb_CMDVERBOSITY ) ));
    assert_eq! (::std::mem::align_of::<lcb_CMDVERBOSITY>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( lcb_CMDVERBOSITY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDVERBOSITY ) ) . cmdflags as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDVERBOSITY ) ,
                "::" , stringify ! ( cmdflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDVERBOSITY ) ) . exptime as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDVERBOSITY ) ,
                "::" , stringify ! ( exptime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDVERBOSITY ) ) . cas as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDVERBOSITY ) ,
                "::" , stringify ! ( cas ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDVERBOSITY ) ) . key as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDVERBOSITY ) ,
                "::" , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDVERBOSITY ) ) . _hashkey as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDVERBOSITY ) ,
                "::" , stringify ! ( _hashkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDVERBOSITY ) ) . server as * const
                _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDVERBOSITY ) ,
                "::" , stringify ! ( server ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDVERBOSITY ) ) . level as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDVERBOSITY ) ,
                "::" , stringify ! ( level ) ));
}
impl Clone for lcb_CMDVERBOSITY {
    fn clone(&self) -> Self { *self }
}
pub type lcb_RESPVERBOSITY = lcb_RESPSERVERBASE;
extern "C" {
    pub fn lcb_server_verbosity3(instance: lcb_t,
                                 cookie: *const ::std::os::raw::c_void,
                                 cmd: *const lcb_CMDVERBOSITY) -> lcb_error_t;
}
pub type lcb_CMDCBFLUSH = lcb_CMDBASE;
pub type lcb_RESPCBFLUSH = lcb_RESPBASE;
extern "C" {
    pub fn lcb_cbflush3(instance: lcb_t,
                        cookie: *const ::std::os::raw::c_void,
                        cmd: *const lcb_CMDCBFLUSH) -> lcb_error_t;
}
pub type lcb_CMDFLUSH = lcb_CMDBASE;
pub type lcb_RESPFLUSH = lcb_RESPSERVERBASE;
extern "C" {
    pub fn lcb_flush3(instance: lcb_t, cookie: *const ::std::os::raw::c_void,
                      cmd: *const lcb_CMDFLUSH) -> lcb_error_t;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum lcb_http_type_t {
    LCB_HTTP_TYPE_VIEW = 0,
    LCB_HTTP_TYPE_MANAGEMENT = 1,
    LCB_HTTP_TYPE_RAW = 2,
    LCB_HTTP_TYPE_N1QL = 3,
    LCB_HTTP_TYPE_FTS = 4,
    LCB_HTTP_TYPE_MAX = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum lcb_http_method_t {
    LCB_HTTP_METHOD_GET = 0,
    LCB_HTTP_METHOD_POST = 1,
    LCB_HTTP_METHOD_PUT = 2,
    LCB_HTTP_METHOD_DELETE = 3,
    LCB_HTTP_METHOD_MAX = 4,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_CMDHTTP {
    pub cmdflags: lcb_U32,
    pub exptime: lcb_U32,
    pub cas: lcb_U64,
    pub key: lcb_KEYBUF,
    pub _hashkey: lcb_KEYBUF,
    pub type_: lcb_http_type_t,
    pub method: lcb_http_method_t,
    pub body: *const ::std::os::raw::c_char,
    pub nbody: lcb_SIZE,
    pub reqhandle: *mut lcb_http_request_t,
    pub content_type: *const ::std::os::raw::c_char,
    pub username: *const ::std::os::raw::c_char,
    pub password: *const ::std::os::raw::c_char,
    pub host: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_lcb_CMDHTTP() {
    assert_eq!(::std::mem::size_of::<lcb_CMDHTTP>() , 128usize , concat ! (
               "Size of: " , stringify ! ( lcb_CMDHTTP ) ));
    assert_eq! (::std::mem::align_of::<lcb_CMDHTTP>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_CMDHTTP ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDHTTP ) ) . cmdflags as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDHTTP ) , "::" ,
                stringify ! ( cmdflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDHTTP ) ) . exptime as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDHTTP ) , "::" ,
                stringify ! ( exptime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDHTTP ) ) . cas as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDHTTP ) , "::" ,
                stringify ! ( cas ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDHTTP ) ) . key as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDHTTP ) , "::" ,
                stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDHTTP ) ) . _hashkey as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDHTTP ) , "::" ,
                stringify ! ( _hashkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDHTTP ) ) . type_ as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDHTTP ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDHTTP ) ) . method as * const _ as
                usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDHTTP ) , "::" ,
                stringify ! ( method ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDHTTP ) ) . body as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDHTTP ) , "::" ,
                stringify ! ( body ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDHTTP ) ) . nbody as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDHTTP ) , "::" ,
                stringify ! ( nbody ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDHTTP ) ) . reqhandle as * const _
                as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDHTTP ) , "::" ,
                stringify ! ( reqhandle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDHTTP ) ) . content_type as * const
                _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDHTTP ) , "::" ,
                stringify ! ( content_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDHTTP ) ) . username as * const _
                as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDHTTP ) , "::" ,
                stringify ! ( username ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDHTTP ) ) . password as * const _
                as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDHTTP ) , "::" ,
                stringify ! ( password ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDHTTP ) ) . host as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDHTTP ) , "::" ,
                stringify ! ( host ) ));
}
impl Clone for lcb_CMDHTTP {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_RESPHTTP {
    pub cookie: *mut ::std::os::raw::c_void,
    pub key: *const ::std::os::raw::c_void,
    pub nkey: lcb_SIZE,
    pub cas: lcb_CAS,
    pub rc: lcb_error_t,
    pub version: lcb_U16,
    pub rflags: lcb_U16,
    pub htstatus: ::std::os::raw::c_short,
    pub headers: *const *const ::std::os::raw::c_char,
    pub body: *const ::std::os::raw::c_void,
    pub nbody: lcb_SIZE,
    pub _htreq: lcb_http_request_t,
}
#[test]
fn bindgen_test_layout_lcb_RESPHTTP() {
    assert_eq!(::std::mem::size_of::<lcb_RESPHTTP>() , 80usize , concat ! (
               "Size of: " , stringify ! ( lcb_RESPHTTP ) ));
    assert_eq! (::std::mem::align_of::<lcb_RESPHTTP>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_RESPHTTP ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPHTTP ) ) . cookie as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPHTTP ) , "::" ,
                stringify ! ( cookie ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPHTTP ) ) . key as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPHTTP ) , "::" ,
                stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPHTTP ) ) . nkey as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPHTTP ) , "::" ,
                stringify ! ( nkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPHTTP ) ) . cas as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPHTTP ) , "::" ,
                stringify ! ( cas ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPHTTP ) ) . rc as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPHTTP ) , "::" ,
                stringify ! ( rc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPHTTP ) ) . version as * const _
                as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPHTTP ) , "::" ,
                stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPHTTP ) ) . rflags as * const _ as
                usize } , 38usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPHTTP ) , "::" ,
                stringify ! ( rflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPHTTP ) ) . htstatus as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPHTTP ) , "::" ,
                stringify ! ( htstatus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPHTTP ) ) . headers as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPHTTP ) , "::" ,
                stringify ! ( headers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPHTTP ) ) . body as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPHTTP ) , "::" ,
                stringify ! ( body ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPHTTP ) ) . nbody as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPHTTP ) , "::" ,
                stringify ! ( nbody ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPHTTP ) ) . _htreq as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPHTTP ) , "::" ,
                stringify ! ( _htreq ) ));
}
impl Clone for lcb_RESPHTTP {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn lcb_http3(instance: lcb_t, cookie: *const ::std::os::raw::c_void,
                     cmd: *const lcb_CMDHTTP) -> lcb_error_t;
}
extern "C" {
    pub fn lcb_cancel_http_request(instance: lcb_t,
                                   request: lcb_http_request_t);
}
extern "C" {
    pub fn lcb_set_cookie(instance: lcb_t,
                          cookie: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn lcb_get_cookie(instance: lcb_t) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn lcb_wait(instance: lcb_t) -> lcb_error_t;
}
extern "C" {
    pub fn lcb_tick_nowait(instance: lcb_t) -> lcb_error_t;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum lcb_WAITFLAGS { LCB_WAIT_DEFAULT = 0, LCB_WAIT_NOCHECK = 1, }
extern "C" {
    pub fn lcb_wait3(instance: lcb_t, flags: lcb_WAITFLAGS);
}
extern "C" {
    pub fn lcb_breakout(instance: lcb_t);
}
extern "C" {
    pub fn lcb_is_waiting(instance: lcb_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcb_refresh_config(instance: lcb_t);
}
extern "C" {
    pub fn lcb_sched_enter(instance: lcb_t);
}
extern "C" {
    pub fn lcb_sched_leave(instance: lcb_t);
}
extern "C" {
    pub fn lcb_sched_fail(instance: lcb_t);
}
extern "C" {
    pub fn lcb_sched_flush(instance: lcb_t);
}
extern "C" {
    pub fn lcb_destroy(instance: lcb_t);
}
pub type lcb_destroy_callback =
    ::std::option::Option<unsafe extern "C" fn(cookie:
                                                   *const ::std::os::raw::c_void)>;
extern "C" {
    pub fn lcb_set_destroy_callback(arg1: lcb_t, arg2: lcb_destroy_callback)
     -> lcb_destroy_callback;
}
extern "C" {
    pub fn lcb_destroy_async(instance: lcb_t,
                             arg: *const ::std::os::raw::c_void);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum lcb_VALUEFLAGS {
    LCB_VALUE_RAW = 0,
    LCB_VALUE_F_JSON = 1,
    LCB_VALUE_F_SNAPPYCOMP = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum lcb_GETNODETYPE {
    LCB_NODE_HTCONFIG = 1,
    LCB_NODE_DATA = 2,
    LCB_NODE_VIEWS = 4,
    LCB_NODE_CONNECTED = 8,
    LCB_NODE_NEVERNULL = 16,
    LCB_NODE_HTCONFIG_CONNECTED = 9,
    LCB_NODE_HTCONFIG_ANY = 17,
}
extern "C" {
    pub fn lcb_get_node(instance: lcb_t, type_: lcb_GETNODETYPE,
                        index: ::std::os::raw::c_uint)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn lcb_get_keynode(instance: lcb_t,
                           key: *const ::std::os::raw::c_void, nkey: usize)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn lcb_get_num_replicas(instance: lcb_t) -> lcb_S32;
}
extern "C" {
    pub fn lcb_get_num_nodes(instance: lcb_t) -> lcb_S32;
}
extern "C" {
    pub fn lcb_get_server_list(instance: lcb_t)
     -> *const *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn lcb_dump(instance: lcb_t, fp: *mut FILE, flags: lcb_U32);
}
extern "C" {
    pub fn lcb_cntl(instance: lcb_t, mode: ::std::os::raw::c_int,
                    cmd: ::std::os::raw::c_int,
                    arg: *mut ::std::os::raw::c_void) -> lcb_error_t;
}
extern "C" {
    pub fn lcb_cntl_string(instance: lcb_t,
                           key: *const ::std::os::raw::c_char,
                           value: *const ::std::os::raw::c_char)
     -> lcb_error_t;
}
extern "C" {
    pub fn lcb_cntl_setu32(instance: lcb_t, cmd: ::std::os::raw::c_int,
                           arg: lcb_U32) -> lcb_error_t;
}
extern "C" {
    pub fn lcb_cntl_getu32(instance: lcb_t, cmd: ::std::os::raw::c_int)
     -> lcb_U32;
}
extern "C" {
    pub fn lcb_cntl_exists(ctl: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum lcb_timeunit_t {
    LCB_TIMEUNIT_NSEC = 0,
    LCB_TIMEUNIT_USEC = 1,
    LCB_TIMEUNIT_MSEC = 2,
    LCB_TIMEUNIT_SEC = 3,
}
extern "C" {
    pub fn lcb_enable_timings(instance: lcb_t) -> lcb_error_t;
}
extern "C" {
    pub fn lcb_disable_timings(instance: lcb_t) -> lcb_error_t;
}
pub type lcb_timings_callback =
    ::std::option::Option<unsafe extern "C" fn(instance: lcb_t,
                                               cookie:
                                                   *const ::std::os::raw::c_void,
                                               timeunit: lcb_timeunit_t,
                                               min: lcb_U32, max: lcb_U32,
                                               total: lcb_U32,
                                               maxtotal: lcb_U32)>;
extern "C" {
    pub fn lcb_get_timings(instance: lcb_t,
                           cookie: *const ::std::os::raw::c_void,
                           callback: lcb_timings_callback) -> lcb_error_t;
}
extern "C" {
    pub fn lcb_get_version(version: *mut lcb_U32)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "lcb_version_g"]
    pub static lcb_version_g: lcb_U32;
}
extern "C" {
    pub fn lcb_supports_feature(n: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcb_mem_alloc(size: lcb_SIZE) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lcb_mem_free(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn lcb_run_loop(instance: lcb_t);
}
extern "C" {
    pub fn lcb_stop_loop(instance: lcb_t);
}
extern "C" {
    pub fn lcb_nstime() -> lcb_U64;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum lcb_DUMPFLAGS {
    LCB_DUMP_VBCONFIG = 1,
    LCB_DUMP_PKTINFO = 2,
    LCB_DUMP_BUFINFO = 4,
    LCB_DUMP_ALL = 255,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lcb_histogram_st {
    _unused: [u8; 0],
}
pub type lcb_HISTOGRAM = lcb_histogram_st;
extern "C" {
    pub fn lcb_histogram_create() -> *mut lcb_HISTOGRAM;
}
extern "C" {
    pub fn lcb_histogram_destroy(hg: *mut lcb_HISTOGRAM);
}
extern "C" {
    pub fn lcb_histogram_record(hg: *mut lcb_HISTOGRAM, duration: lcb_U64);
}
pub type lcb_HISTOGRAM_CALLBACK =
    ::std::option::Option<unsafe extern "C" fn(cookie:
                                                   *const ::std::os::raw::c_void,
                                               timeunit: lcb_timeunit_t,
                                               min: lcb_U32, max: lcb_U32,
                                               total: lcb_U32,
                                               maxtotal: lcb_U32)>;
extern "C" {
    pub fn lcb_histogram_read(hg: *const lcb_HISTOGRAM,
                              cookie: *const ::std::os::raw::c_void,
                              cb: lcb_HISTOGRAM_CALLBACK);
}
extern "C" {
    pub fn lcb_histogram_print(hg: *mut lcb_HISTOGRAM, stream: *mut FILE);
}
extern "C" {
    pub fn lcb_resp_get_error_context(cbtype: ::std::os::raw::c_int,
                                      rb: *const lcb_RESPBASE)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn lcb_resp_get_error_ref(cbtype: ::std::os::raw::c_int,
                                  rb: *const lcb_RESPBASE)
     -> *const ::std::os::raw::c_char;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum lcb_SUBDOCOP {
    LCB_SDCMD_GET = 1,
    LCB_SDCMD_EXISTS = 2,
    LCB_SDCMD_REPLACE = 3,
    LCB_SDCMD_DICT_ADD = 4,
    LCB_SDCMD_DICT_UPSERT = 5,
    LCB_SDCMD_ARRAY_ADD_FIRST = 6,
    LCB_SDCMD_ARRAY_ADD_LAST = 7,
    LCB_SDCMD_ARRAY_ADD_UNIQUE = 8,
    LCB_SDCMD_ARRAY_INSERT = 9,
    LCB_SDCMD_COUNTER = 10,
    LCB_SDCMD_REMOVE = 11,
    LCB_SDCMD_GET_COUNT = 12,
    LCB_SDCMD_GET_FULLDOC = 13,
    LCB_SDCMD_SET_FULLDOC = 14,
    LCB_SDCMD_MAX = 15,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_SDSPEC {
    pub sdcmd: lcb_U32,
    pub options: lcb_U32,
    pub path: lcb_KEYBUF,
    pub value: lcb_VALBUF,
}
#[test]
fn bindgen_test_layout_lcb_SDSPEC() {
    assert_eq!(::std::mem::size_of::<lcb_SDSPEC>() , 56usize , concat ! (
               "Size of: " , stringify ! ( lcb_SDSPEC ) ));
    assert_eq! (::std::mem::align_of::<lcb_SDSPEC>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_SDSPEC ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_SDSPEC ) ) . sdcmd as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_SDSPEC ) , "::" ,
                stringify ! ( sdcmd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_SDSPEC ) ) . options as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_SDSPEC ) , "::" ,
                stringify ! ( options ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_SDSPEC ) ) . path as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_SDSPEC ) , "::" ,
                stringify ! ( path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_SDSPEC ) ) . value as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_SDSPEC ) , "::" ,
                stringify ! ( value ) ));
}
impl Clone for lcb_SDSPEC {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_CMDSUBDOC {
    pub cmdflags: lcb_U32,
    pub exptime: lcb_U32,
    pub cas: lcb_U64,
    pub key: lcb_KEYBUF,
    pub _hashkey: lcb_KEYBUF,
    pub specs: *const lcb_SDSPEC,
    pub nspecs: usize,
    pub error_index: *mut ::std::os::raw::c_int,
    pub multimode: lcb_U32,
}
#[test]
fn bindgen_test_layout_lcb_CMDSUBDOC() {
    assert_eq!(::std::mem::size_of::<lcb_CMDSUBDOC>() , 96usize , concat ! (
               "Size of: " , stringify ! ( lcb_CMDSUBDOC ) ));
    assert_eq! (::std::mem::align_of::<lcb_CMDSUBDOC>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_CMDSUBDOC ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDSUBDOC ) ) . cmdflags as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDSUBDOC ) , "::"
                , stringify ! ( cmdflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDSUBDOC ) ) . exptime as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDSUBDOC ) , "::"
                , stringify ! ( exptime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDSUBDOC ) ) . cas as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDSUBDOC ) , "::"
                , stringify ! ( cas ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDSUBDOC ) ) . key as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDSUBDOC ) , "::"
                , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDSUBDOC ) ) . _hashkey as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDSUBDOC ) , "::"
                , stringify ! ( _hashkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDSUBDOC ) ) . specs as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDSUBDOC ) , "::"
                , stringify ! ( specs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDSUBDOC ) ) . nspecs as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDSUBDOC ) , "::"
                , stringify ! ( nspecs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDSUBDOC ) ) . error_index as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDSUBDOC ) , "::"
                , stringify ! ( error_index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDSUBDOC ) ) . multimode as * const
                _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDSUBDOC ) , "::"
                , stringify ! ( multimode ) ));
}
impl Clone for lcb_CMDSUBDOC {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn lcb_subdoc3(instance: lcb_t, cookie: *const ::std::os::raw::c_void,
                       cmd: *const lcb_CMDSUBDOC) -> lcb_error_t;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_RESPSUBDOC {
    pub cookie: *mut ::std::os::raw::c_void,
    pub key: *const ::std::os::raw::c_void,
    pub nkey: lcb_SIZE,
    pub cas: lcb_CAS,
    pub rc: lcb_error_t,
    pub version: lcb_U16,
    pub rflags: lcb_U16,
    pub responses: *const ::std::os::raw::c_void,
    pub bufh: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_lcb_RESPSUBDOC() {
    assert_eq!(::std::mem::size_of::<lcb_RESPSUBDOC>() , 56usize , concat ! (
               "Size of: " , stringify ! ( lcb_RESPSUBDOC ) ));
    assert_eq! (::std::mem::align_of::<lcb_RESPSUBDOC>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_RESPSUBDOC ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPSUBDOC ) ) . cookie as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPSUBDOC ) , "::"
                , stringify ! ( cookie ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPSUBDOC ) ) . key as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPSUBDOC ) , "::"
                , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPSUBDOC ) ) . nkey as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPSUBDOC ) , "::"
                , stringify ! ( nkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPSUBDOC ) ) . cas as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPSUBDOC ) , "::"
                , stringify ! ( cas ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPSUBDOC ) ) . rc as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPSUBDOC ) , "::"
                , stringify ! ( rc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPSUBDOC ) ) . version as * const _
                as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPSUBDOC ) , "::"
                , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPSUBDOC ) ) . rflags as * const _
                as usize } , 38usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPSUBDOC ) , "::"
                , stringify ! ( rflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPSUBDOC ) ) . responses as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPSUBDOC ) , "::"
                , stringify ! ( responses ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPSUBDOC ) ) . bufh as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPSUBDOC ) , "::"
                , stringify ! ( bufh ) ));
}
impl Clone for lcb_RESPSUBDOC {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_SDENTRY {
    pub value: *const ::std::os::raw::c_void,
    pub nvalue: usize,
    pub status: lcb_error_t,
    pub index: lcb_U8,
}
#[test]
fn bindgen_test_layout_lcb_SDENTRY() {
    assert_eq!(::std::mem::size_of::<lcb_SDENTRY>() , 24usize , concat ! (
               "Size of: " , stringify ! ( lcb_SDENTRY ) ));
    assert_eq! (::std::mem::align_of::<lcb_SDENTRY>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_SDENTRY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_SDENTRY ) ) . value as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_SDENTRY ) , "::" ,
                stringify ! ( value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_SDENTRY ) ) . nvalue as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_SDENTRY ) , "::" ,
                stringify ! ( nvalue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_SDENTRY ) ) . status as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_SDENTRY ) , "::" ,
                stringify ! ( status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_SDENTRY ) ) . index as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_SDENTRY ) , "::" ,
                stringify ! ( index ) ));
}
impl Clone for lcb_SDENTRY {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn lcb_sdresult_next(resp: *const lcb_RESPSUBDOC,
                             out: *mut lcb_SDENTRY, iter: *mut usize)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_cntl_vbinfo_st {
    pub version: ::std::os::raw::c_int,
    pub v: lcb_cntl_vbinfo_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_cntl_vbinfo_st__bindgen_ty_1 {
    pub v0: __BindgenUnionField<lcb_cntl_vbinfo_st__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: [u64; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_cntl_vbinfo_st__bindgen_ty_1__bindgen_ty_1 {
    pub key: *const ::std::os::raw::c_void,
    pub nkey: lcb_SIZE,
    pub vbucket: ::std::os::raw::c_int,
    pub server_index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_lcb_cntl_vbinfo_st__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<lcb_cntl_vbinfo_st__bindgen_ty_1__bindgen_ty_1>()
               , 24usize , concat ! (
               "Size of: " , stringify ! (
               lcb_cntl_vbinfo_st__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<lcb_cntl_vbinfo_st__bindgen_ty_1__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                lcb_cntl_vbinfo_st__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const lcb_cntl_vbinfo_st__bindgen_ty_1__bindgen_ty_1 )
                ) . key as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_cntl_vbinfo_st__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( key ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const lcb_cntl_vbinfo_st__bindgen_ty_1__bindgen_ty_1 )
                ) . nkey as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_cntl_vbinfo_st__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( nkey ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const lcb_cntl_vbinfo_st__bindgen_ty_1__bindgen_ty_1 )
                ) . vbucket as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_cntl_vbinfo_st__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( vbucket ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const lcb_cntl_vbinfo_st__bindgen_ty_1__bindgen_ty_1 )
                ) . server_index as * const _ as usize } , 20usize , concat !
                (
                "Alignment of field: " , stringify ! (
                lcb_cntl_vbinfo_st__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( server_index ) ));
}
impl Clone for lcb_cntl_vbinfo_st__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_lcb_cntl_vbinfo_st__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<lcb_cntl_vbinfo_st__bindgen_ty_1>() ,
               24usize , concat ! (
               "Size of: " , stringify ! ( lcb_cntl_vbinfo_st__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<lcb_cntl_vbinfo_st__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                lcb_cntl_vbinfo_st__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_cntl_vbinfo_st__bindgen_ty_1 ) ) . v0
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_cntl_vbinfo_st__bindgen_ty_1 ) , "::" , stringify ! ( v0 )
                ));
}
impl Clone for lcb_cntl_vbinfo_st__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_lcb_cntl_vbinfo_st() {
    assert_eq!(::std::mem::size_of::<lcb_cntl_vbinfo_st>() , 32usize , concat
               ! ( "Size of: " , stringify ! ( lcb_cntl_vbinfo_st ) ));
    assert_eq! (::std::mem::align_of::<lcb_cntl_vbinfo_st>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( lcb_cntl_vbinfo_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_cntl_vbinfo_st ) ) . version as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_cntl_vbinfo_st ) ,
                "::" , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_cntl_vbinfo_st ) ) . v as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_cntl_vbinfo_st ) ,
                "::" , stringify ! ( v ) ));
}
impl Clone for lcb_cntl_vbinfo_st {
    fn clone(&self) -> Self { *self }
}
pub type lcb_cntl_vbinfo_t = lcb_cntl_vbinfo_st;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum lcb_log_severity_t {
    LCB_LOG_TRACE = 0,
    LCB_LOG_DEBUG = 1,
    LCB_LOG_INFO = 2,
    LCB_LOG_WARN = 3,
    LCB_LOG_ERROR = 4,
    LCB_LOG_FATAL = 5,
    LCB_LOG_MAX = 6,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_logprocs_st {
    pub version: ::std::os::raw::c_int,
    pub v: lcb_logprocs_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_logprocs_st__bindgen_ty_1 {
    pub v0: __BindgenUnionField<lcb_logprocs_st__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: u64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_logprocs_st__bindgen_ty_1__bindgen_ty_1 {
    pub callback: lcb_logging_callback,
}
#[test]
fn bindgen_test_layout_lcb_logprocs_st__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<lcb_logprocs_st__bindgen_ty_1__bindgen_ty_1>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               lcb_logprocs_st__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<lcb_logprocs_st__bindgen_ty_1__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                lcb_logprocs_st__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const lcb_logprocs_st__bindgen_ty_1__bindgen_ty_1 )
                ) . callback as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_logprocs_st__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( callback ) ));
}
impl Clone for lcb_logprocs_st__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_lcb_logprocs_st__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<lcb_logprocs_st__bindgen_ty_1>() , 8usize
               , concat ! (
               "Size of: " , stringify ! ( lcb_logprocs_st__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<lcb_logprocs_st__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_logprocs_st__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_logprocs_st__bindgen_ty_1 ) ) . v0 as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_logprocs_st__bindgen_ty_1 ) , "::" , stringify ! ( v0 )
                ));
}
impl Clone for lcb_logprocs_st__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_lcb_logprocs_st() {
    assert_eq!(::std::mem::size_of::<lcb_logprocs_st>() , 16usize , concat ! (
               "Size of: " , stringify ! ( lcb_logprocs_st ) ));
    assert_eq! (::std::mem::align_of::<lcb_logprocs_st>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( lcb_logprocs_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_logprocs_st ) ) . version as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_logprocs_st ) ,
                "::" , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_logprocs_st ) ) . v as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_logprocs_st ) ,
                "::" , stringify ! ( v ) ));
}
impl Clone for lcb_logprocs_st {
    fn clone(&self) -> Self { *self }
}
pub type lcb_logging_callback =
    ::std::option::Option<unsafe extern "C" fn(procs: *mut lcb_logprocs_st,
                                               iid: ::std::os::raw::c_uint,
                                               subsys:
                                                   *const ::std::os::raw::c_char,
                                               severity:
                                                   ::std::os::raw::c_int,
                                               srcfile:
                                                   *const ::std::os::raw::c_char,
                                               srcline: ::std::os::raw::c_int,
                                               fmt:
                                                   *const ::std::os::raw::c_char,
                                               ap: *mut __va_list_tag)>;
pub type lcb_logprocs = lcb_logprocs_st;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum lcb_SSLOPTS {
    LCB_SSL_ENABLED = 1,
    LCB_SSL_NOVERIFY = 2,
    LCB_SSL_NOGLOBALINIT = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum lcb_RETRYMODEOPTS {
    LCB_RETRY_ON_TOPOCHANGE = 0,
    LCB_RETRY_ON_SOCKERR = 1,
    LCB_RETRY_ON_VBMAPERR = 2,
    LCB_RETRY_ON_MISSINGNODE = 3,
    LCB_RETRY_ON_MAX = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum lcb_RETRYCMDOPTS {
    LCB_RETRY_CMDS_NONE = 0,
    LCB_RETRY_CMDS_GET = 1,
    LCB_RETRY_CMDS_SAFE = 3,
    LCB_RETRY_CMDS_ALL = 7,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum lcb_HTCONFIG_URLTYPE {
    LCB_HTCONFIG_URLTYPE_25PLUS = 1,
    LCB_HTCONFIG_URLTYPE_COMPAT = 2,
    LCB_HTCONFIG_URLTYPE_TRYALL = 3,
}
pub type lcb_BUCKETCRED = [*const ::std::os::raw::c_char; 2usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_cntl_server_st {
    pub version: ::std::os::raw::c_int,
    pub v: lcb_cntl_server_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_cntl_server_st__bindgen_ty_1 {
    pub v0: __BindgenUnionField<lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_1>,
    pub v1: __BindgenUnionField<lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_2>,
    pub bindgen_union_field: [u64; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_1 {
    pub index: ::std::os::raw::c_int,
    pub host: *const ::std::os::raw::c_char,
    pub port: *const ::std::os::raw::c_char,
    pub connected: ::std::os::raw::c_int,
    pub sock: lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub sockfd: __BindgenUnionField<lcb_socket_t>,
    pub sockptr: __BindgenUnionField<*mut lcb_sockdata_t>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 )
                ) . sockfd as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 )
                , "::" , stringify ! ( sockfd ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 )
                ) . sockptr as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 )
                , "::" , stringify ! ( sockptr ) ));
}
impl Clone for lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_1>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_1 )
                ) . index as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( index ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_1 )
                ) . host as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( host ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_1 )
                ) . port as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( port ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_1 )
                ) . connected as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( connected ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_1 )
                ) . sock as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( sock ) ));
}
impl Clone for lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_2 {
    pub index: ::std::os::raw::c_int,
    pub host: *const ::std::os::raw::c_char,
    pub port: *const ::std::os::raw::c_char,
    pub connected: ::std::os::raw::c_int,
    pub sock: lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
    pub sasl_mech: *const ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub sockfd: __BindgenUnionField<lcb_socket_t>,
    pub sockptr: __BindgenUnionField<*mut lcb_sockdata_t>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 )
                ) . sockfd as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 )
                , "::" , stringify ! ( sockfd ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 )
                ) . sockptr as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 )
                , "::" , stringify ! ( sockptr ) ));
}
impl Clone for lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_2>()
               , 48usize , concat ! (
               "Size of: " , stringify ! (
               lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_2>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_2 )
                ) . index as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( index ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_2 )
                ) . host as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( host ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_2 )
                ) . port as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( port ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_2 )
                ) . connected as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( connected ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_2 )
                ) . sock as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( sock ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_2 )
                ) . sasl_mech as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( sasl_mech ) ));
}
impl Clone for lcb_cntl_server_st__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_lcb_cntl_server_st__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<lcb_cntl_server_st__bindgen_ty_1>() ,
               48usize , concat ! (
               "Size of: " , stringify ! ( lcb_cntl_server_st__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<lcb_cntl_server_st__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                lcb_cntl_server_st__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_cntl_server_st__bindgen_ty_1 ) ) . v0
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_cntl_server_st__bindgen_ty_1 ) , "::" , stringify ! ( v0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_cntl_server_st__bindgen_ty_1 ) ) . v1
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_cntl_server_st__bindgen_ty_1 ) , "::" , stringify ! ( v1 )
                ));
}
impl Clone for lcb_cntl_server_st__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_lcb_cntl_server_st() {
    assert_eq!(::std::mem::size_of::<lcb_cntl_server_st>() , 56usize , concat
               ! ( "Size of: " , stringify ! ( lcb_cntl_server_st ) ));
    assert_eq! (::std::mem::align_of::<lcb_cntl_server_st>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( lcb_cntl_server_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_cntl_server_st ) ) . version as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_cntl_server_st ) ,
                "::" , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_cntl_server_st ) ) . v as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_cntl_server_st ) ,
                "::" , stringify ! ( v ) ));
}
impl Clone for lcb_cntl_server_st {
    fn clone(&self) -> Self { *self }
}
pub type lcb_cntl_server_t = lcb_cntl_server_st;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_cntl_iops_info_st {
    pub version: ::std::os::raw::c_int,
    pub v: lcb_cntl_iops_info_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_cntl_iops_info_st__bindgen_ty_1 {
    pub v0: __BindgenUnionField<lcb_cntl_iops_info_st__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_cntl_iops_info_st__bindgen_ty_1__bindgen_ty_1 {
    pub options: *const lcb_create_io_ops_st,
    pub os_default: lcb_io_ops_type_t,
    pub effective: lcb_io_ops_type_t,
}
#[test]
fn bindgen_test_layout_lcb_cntl_iops_info_st__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<lcb_cntl_iops_info_st__bindgen_ty_1__bindgen_ty_1>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               lcb_cntl_iops_info_st__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<lcb_cntl_iops_info_st__bindgen_ty_1__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                lcb_cntl_iops_info_st__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const lcb_cntl_iops_info_st__bindgen_ty_1__bindgen_ty_1
                ) ) . options as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_cntl_iops_info_st__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( options ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const lcb_cntl_iops_info_st__bindgen_ty_1__bindgen_ty_1
                ) ) . os_default as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_cntl_iops_info_st__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( os_default ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const lcb_cntl_iops_info_st__bindgen_ty_1__bindgen_ty_1
                ) ) . effective as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_cntl_iops_info_st__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( effective ) ));
}
impl Clone for lcb_cntl_iops_info_st__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_lcb_cntl_iops_info_st__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<lcb_cntl_iops_info_st__bindgen_ty_1>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( lcb_cntl_iops_info_st__bindgen_ty_1
               ) ));
    assert_eq! (::std::mem::align_of::<lcb_cntl_iops_info_st__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                lcb_cntl_iops_info_st__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_cntl_iops_info_st__bindgen_ty_1 ) ) .
                v0 as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_cntl_iops_info_st__bindgen_ty_1 ) , "::" , stringify ! (
                v0 ) ));
}
impl Clone for lcb_cntl_iops_info_st__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_lcb_cntl_iops_info_st() {
    assert_eq!(::std::mem::size_of::<lcb_cntl_iops_info_st>() , 24usize ,
               concat ! ( "Size of: " , stringify ! ( lcb_cntl_iops_info_st )
               ));
    assert_eq! (::std::mem::align_of::<lcb_cntl_iops_info_st>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( lcb_cntl_iops_info_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_cntl_iops_info_st ) ) . version as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_cntl_iops_info_st )
                , "::" , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_cntl_iops_info_st ) ) . v as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_cntl_iops_info_st )
                , "::" , stringify ! ( v ) ));
}
impl Clone for lcb_cntl_iops_info_st {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum lcb_COMPRESSOPTS {
    LCB_COMPRESS_NONE = 0,
    LCB_COMPRESS_IN = 1,
    LCB_COMPRESS_OUT = 2,
    LCB_COMPRESS_INOUT = 3,
    LCB_COMPRESS_FORCE = 4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rdb_ALLOCATOR {
    _unused: [u8; 0],
}
pub type lcb_RDBALLOCFACTORY =
    ::std::option::Option<unsafe extern "C" fn() -> *mut rdb_ALLOCATOR>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_cntl_rdballocfactory {
    pub factory: lcb_RDBALLOCFACTORY,
}
#[test]
fn bindgen_test_layout_lcb_cntl_rdballocfactory() {
    assert_eq!(::std::mem::size_of::<lcb_cntl_rdballocfactory>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( lcb_cntl_rdballocfactory ) ));
    assert_eq! (::std::mem::align_of::<lcb_cntl_rdballocfactory>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( lcb_cntl_rdballocfactory ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_cntl_rdballocfactory ) ) . factory as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_cntl_rdballocfactory ) , "::" , stringify ! ( factory )
                ));
}
impl Clone for lcb_cntl_rdballocfactory {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum lcb_ipv6_t {
    LCB_IPV6_DISABLED = 0,
    LCB_IPV6_ONLY = 1,
    LCB_IPV6_ALLOW = 2,
}
extern "C" {
    pub fn lcb_behavior_set_ipv6(instance: lcb_t, mode: lcb_ipv6_t);
}
extern "C" {
    pub fn lcb_behavior_get_ipv6(instance: lcb_t) -> lcb_ipv6_t;
}
extern "C" {
    pub fn lcb_behavior_set_config_errors_threshold(instance: lcb_t,
                                                    num_events: lcb_size_t);
}
extern "C" {
    pub fn lcb_behavior_get_config_errors_threshold(instance: lcb_t)
     -> lcb_size_t;
}
extern "C" {
    pub fn lcb_set_timeout(instance: lcb_t, usec: lcb_uint32_t);
}
extern "C" {
    pub fn lcb_get_timeout(instance: lcb_t) -> lcb_uint32_t;
}
extern "C" {
    pub fn lcb_set_view_timeout(instance: lcb_t, usec: lcb_uint32_t);
}
extern "C" {
    pub fn lcb_get_view_timeout(instance: lcb_t) -> lcb_uint32_t;
}
extern "C" {
    pub fn lcb_get_last_error(instance: lcb_t) -> lcb_error_t;
}
extern "C" {
    pub fn lcb_flush_buffers(instance: lcb_t,
                             cookie: *const ::std::os::raw::c_void);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum lcb_vbucket_state_t {
    LCB_VBUCKET_STATE_ACTIVE = 1,
    LCB_VBUCKET_STATE_REPLICA = 2,
    LCB_VBUCKET_STATE_PENDING = 3,
    LCB_VBUCKET_STATE_DEAD = 4,
}
pub type lcb_error_callback =
    ::std::option::Option<unsafe extern "C" fn(instance: lcb_t,
                                               error: lcb_error_t,
                                               errinfo:
                                                   *const ::std::os::raw::c_char)>;
extern "C" {
    pub fn lcb_set_error_callback(arg1: lcb_t, arg2: lcb_error_callback)
     -> lcb_error_callback;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lcb_timer_st {
    _unused: [u8; 0],
}
pub type lcb_timer_t = *mut lcb_timer_st;
pub type lcb_timer_callback =
    ::std::option::Option<unsafe extern "C" fn(timer: lcb_timer_t,
                                               instance: lcb_t,
                                               cookie:
                                                   *const ::std::os::raw::c_void)>;
extern "C" {
    pub fn lcb_timer_create(instance: lcb_t,
                            command_cookie: *const ::std::os::raw::c_void,
                            usec: lcb_uint32_t,
                            periodic: ::std::os::raw::c_int,
                            callback: lcb_timer_callback,
                            error: *mut lcb_error_t) -> lcb_timer_t;
}
extern "C" {
    pub fn lcb_timer_destroy(instance: lcb_t, timer: lcb_timer_t)
     -> lcb_error_t;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum lcb_compat_t { LCB_MEMCACHED_CLUSTER = 0, LCB_CACHED_CONFIG = 1, }
pub use self::lcb_compat_t as lcb_cluster_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_memcached_st {
    pub serverlist: *const ::std::os::raw::c_char,
    pub username: *const ::std::os::raw::c_char,
    pub password: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_lcb_memcached_st() {
    assert_eq!(::std::mem::size_of::<lcb_memcached_st>() , 24usize , concat !
               ( "Size of: " , stringify ! ( lcb_memcached_st ) ));
    assert_eq! (::std::mem::align_of::<lcb_memcached_st>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( lcb_memcached_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_memcached_st ) ) . serverlist as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_memcached_st ) ,
                "::" , stringify ! ( serverlist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_memcached_st ) ) . username as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_memcached_st ) ,
                "::" , stringify ! ( username ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_memcached_st ) ) . password as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_memcached_st ) ,
                "::" , stringify ! ( password ) ));
}
impl Clone for lcb_memcached_st {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_cached_config_st {
    pub cachefile: *const ::std::os::raw::c_char,
    pub createopt: lcb_create_st,
}
#[test]
fn bindgen_test_layout_lcb_cached_config_st() {
    assert_eq!(::std::mem::size_of::<lcb_cached_config_st>() , 80usize ,
               concat ! ( "Size of: " , stringify ! ( lcb_cached_config_st )
               ));
    assert_eq! (::std::mem::align_of::<lcb_cached_config_st>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( lcb_cached_config_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_cached_config_st ) ) . cachefile as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_cached_config_st )
                , "::" , stringify ! ( cachefile ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_cached_config_st ) ) . createopt as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_cached_config_st )
                , "::" , stringify ! ( createopt ) ));
}
impl Clone for lcb_cached_config_st {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn lcb__create_compat_230(type_: lcb_compat_t,
                                  specific: *const ::std::os::raw::c_void,
                                  instance: *mut lcb_t,
                                  io: *mut lcb_io_opt_st) -> lcb_error_t;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum lcb_syncmode_t { LCB_ASYNCHRONOUS = 0, LCB_SYNCHRONOUS = 255, }
extern "C" {
    pub fn lcb_behavior_set_syncmode(arg1: lcb_t, arg2: lcb_syncmode_t);
}
extern "C" {
    pub fn lcb_behavior_get_syncmode(arg1: lcb_t) -> lcb_syncmode_t;
}
extern "C" {
    pub fn lcb_get_host(arg1: lcb_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn lcb_get_port(arg1: lcb_t) -> *const ::std::os::raw::c_char;
}
pub const lcb__STRUCTSIZES_LCB_C_I_O_ST_V: lcb__STRUCTSIZES =
    lcb__STRUCTSIZES::LCB_C_I_O_ST_ID;
pub const lcb__STRUCTSIZES_LCB_G_C_ST_V: lcb__STRUCTSIZES =
    lcb__STRUCTSIZES::LCB_C_ST_ID;
pub const lcb__STRUCTSIZES_LCB_G_R_C_ST_ID: lcb__STRUCTSIZES =
    lcb__STRUCTSIZES::LCB_C_ST_V;
pub const lcb__STRUCTSIZES_LCB_G_R_C_ST_V: lcb__STRUCTSIZES =
    lcb__STRUCTSIZES::LCB_C_I_O_ST_ID;
pub const lcb__STRUCTSIZES_LCB_U_C_ST_V: lcb__STRUCTSIZES =
    lcb__STRUCTSIZES::LCB_C_ST_ID;
pub const lcb__STRUCTSIZES_LCB_T_C_ST_V: lcb__STRUCTSIZES =
    lcb__STRUCTSIZES::LCB_C_ST_ID;
pub const lcb__STRUCTSIZES_LCB_S_C_ST_V: lcb__STRUCTSIZES =
    lcb__STRUCTSIZES::LCB_C_ST_ID;
pub const lcb__STRUCTSIZES_LCB_A_C_ST_V: lcb__STRUCTSIZES =
    lcb__STRUCTSIZES::LCB_C_ST_ID;
pub const lcb__STRUCTSIZES_LCB_O_C_ST_V: lcb__STRUCTSIZES =
    lcb__STRUCTSIZES::LCB_C_ST_ID;
pub const lcb__STRUCTSIZES_LCB_R_C_ST_V: lcb__STRUCTSIZES =
    lcb__STRUCTSIZES::LCB_C_ST_ID;
pub const lcb__STRUCTSIZES_LCB_H_C_ST_V: lcb__STRUCTSIZES =
    lcb__STRUCTSIZES::LCB_C_I_O_ST_ID;
pub const lcb__STRUCTSIZES_LCB_S_S_C_ST_V: lcb__STRUCTSIZES =
    lcb__STRUCTSIZES::LCB_C_ST_ID;
pub const lcb__STRUCTSIZES_LCB_S_V_C_ST_V: lcb__STRUCTSIZES =
    lcb__STRUCTSIZES::LCB_C_ST_ID;
pub const lcb__STRUCTSIZES_LCB_V_C_ST_V: lcb__STRUCTSIZES =
    lcb__STRUCTSIZES::LCB_C_ST_ID;
pub const lcb__STRUCTSIZES_LCB_F_C_ST_V: lcb__STRUCTSIZES =
    lcb__STRUCTSIZES::LCB_C_ST_ID;
pub const lcb__STRUCTSIZES_LCB_G_R_ST_V: lcb__STRUCTSIZES =
    lcb__STRUCTSIZES::LCB_C_ST_ID;
pub const lcb__STRUCTSIZES_LCB_S_R_ST_V: lcb__STRUCTSIZES =
    lcb__STRUCTSIZES::LCB_C_ST_ID;
pub const lcb__STRUCTSIZES_LCB_R_R_ST_V: lcb__STRUCTSIZES =
    lcb__STRUCTSIZES::LCB_C_ST_ID;
pub const lcb__STRUCTSIZES_LCB_T_R_ST_V: lcb__STRUCTSIZES =
    lcb__STRUCTSIZES::LCB_C_ST_ID;
pub const lcb__STRUCTSIZES_LCB_U_R_ST_V: lcb__STRUCTSIZES =
    lcb__STRUCTSIZES::LCB_C_ST_ID;
pub const lcb__STRUCTSIZES_LCB_A_R_ST_V: lcb__STRUCTSIZES =
    lcb__STRUCTSIZES::LCB_C_ST_ID;
pub const lcb__STRUCTSIZES_LCB_O_R_ST_V: lcb__STRUCTSIZES =
    lcb__STRUCTSIZES::LCB_C_ST_ID;
pub const lcb__STRUCTSIZES_LCB_H_R_ST_V: lcb__STRUCTSIZES =
    lcb__STRUCTSIZES::LCB_C_ST_ID;
pub const lcb__STRUCTSIZES_LCB_S_S_R_ST_V: lcb__STRUCTSIZES =
    lcb__STRUCTSIZES::LCB_C_ST_ID;
pub const lcb__STRUCTSIZES_LCB_S_V_R_ST_V: lcb__STRUCTSIZES =
    lcb__STRUCTSIZES::LCB_C_ST_ID;
pub const lcb__STRUCTSIZES_LCB_V_R_ST_V: lcb__STRUCTSIZES =
    lcb__STRUCTSIZES::LCB_C_ST_ID;
pub const lcb__STRUCTSIZES_LCB_F_R_ST_V: lcb__STRUCTSIZES =
    lcb__STRUCTSIZES::LCB_C_ST_ID;
pub const lcb__STRUCTSIZES_LCB_ST_M: lcb__STRUCTSIZES =
    lcb__STRUCTSIZES::LCB_F_R_ST_ID;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum lcb__STRUCTSIZES {
    LCB_C_ST_ID = 0,
    LCB_C_ST_V = 3,
    LCB_C_I_O_ST_ID = 1,
    LCB_G_C_ST_ID = 2,
    LCB_U_C_ST_ID = 4,
    LCB_T_C_ST_ID = 5,
    LCB_S_C_ST_ID = 6,
    LCB_A_C_ST_ID = 7,
    LCB_O_C_ST_ID = 8,
    LCB_R_C_ST_ID = 9,
    LCB_H_C_ST_ID = 10,
    LCB_S_S_C_ST_ID = 11,
    LCB_S_V_C_ST_ID = 12,
    LCB_V_C_ST_ID = 13,
    LCB_F_C_ST_ID = 14,
    LCB_G_R_ST_ID = 15,
    LCB_S_R_ST_ID = 16,
    LCB_R_R_ST_ID = 17,
    LCB_T_R_ST_ID = 18,
    LCB_U_R_ST_ID = 19,
    LCB_A_R_ST_ID = 20,
    LCB_O_R_ST_ID = 21,
    LCB_H_R_ST_ID = 22,
    LCB_S_S_R_ST_ID = 23,
    LCB_S_V_R_ST_ID = 24,
    LCB_V_R_ST_ID = 25,
    LCB_F_R_ST_ID = 26,
}
extern "C" {
    pub fn lcb_verify_struct_size(id: lcb_uint32_t, version: lcb_uint32_t,
                                  size: lcb_size_t) -> lcb_error_t;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum lcb_configuration_t {
    LCB_CONFIGURATION_NEW = 0,
    LCB_CONFIGURATION_CHANGED = 1,
    LCB_CONFIGURATION_UNCHANGED = 2,
}
pub type lcb_configuration_callback =
    ::std::option::Option<unsafe extern "C" fn(instance: lcb_t,
                                               config: lcb_configuration_t)>;
extern "C" {
    pub fn lcb_set_configuration_callback(arg1: lcb_t,
                                          arg2: lcb_configuration_callback)
     -> lcb_configuration_callback;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum lcb_http_status_t {
    LCB_HTTP_STATUS_CONTINUE = 100,
    LCB_HTTP_STATUS_SWITCHING_PROTOCOLS = 101,
    LCB_HTTP_STATUS_PROCESSING = 102,
    LCB_HTTP_STATUS_OK = 200,
    LCB_HTTP_STATUS_CREATED = 201,
    LCB_HTTP_STATUS_ACCEPTED = 202,
    LCB_HTTP_STATUS_NON_AUTHORITATIVE_INFORMATION = 203,
    LCB_HTTP_STATUS_NO_CONTENT = 204,
    LCB_HTTP_STATUS_RESET_CONTENT = 205,
    LCB_HTTP_STATUS_PARTIAL_CONTENT = 206,
    LCB_HTTP_STATUS_MULTI_STATUS = 207,
    LCB_HTTP_STATUS_MULTIPLE_CHOICES = 300,
    LCB_HTTP_STATUS_MOVED_PERMANENTLY = 301,
    LCB_HTTP_STATUS_FOUND = 302,
    LCB_HTTP_STATUS_SEE_OTHER = 303,
    LCB_HTTP_STATUS_NOT_MODIFIED = 304,
    LCB_HTTP_STATUS_USE_PROXY = 305,
    LCB_HTTP_STATUS_UNUSED = 306,
    LCB_HTTP_STATUS_TEMPORARY_REDIRECT = 307,
    LCB_HTTP_STATUS_BAD_REQUEST = 400,
    LCB_HTTP_STATUS_UNAUTHORIZED = 401,
    LCB_HTTP_STATUS_PAYMENT_REQUIRED = 402,
    LCB_HTTP_STATUS_FORBIDDEN = 403,
    LCB_HTTP_STATUS_NOT_FOUND = 404,
    LCB_HTTP_STATUS_METHOD_NOT_ALLOWED = 405,
    LCB_HTTP_STATUS_NOT_ACCEPTABLE = 406,
    LCB_HTTP_STATUS_PROXY_AUTHENTICATION_REQUIRED = 407,
    LCB_HTTP_STATUS_REQUEST_TIMEOUT = 408,
    LCB_HTTP_STATUS_CONFLICT = 409,
    LCB_HTTP_STATUS_GONE = 410,
    LCB_HTTP_STATUS_LENGTH_REQUIRED = 411,
    LCB_HTTP_STATUS_PRECONDITION_FAILED = 412,
    LCB_HTTP_STATUS_REQUEST_ENTITY_TOO_LARGE = 413,
    LCB_HTTP_STATUS_REQUEST_URI_TOO_LONG = 414,
    LCB_HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE = 415,
    LCB_HTTP_STATUS_REQUESTED_RANGE_NOT_SATISFIABLE = 416,
    LCB_HTTP_STATUS_EXPECTATION_FAILED = 417,
    LCB_HTTP_STATUS_UNPROCESSABLE_ENTITY = 422,
    LCB_HTTP_STATUS_LOCKED = 423,
    LCB_HTTP_STATUS_FAILED_DEPENDENCY = 424,
    LCB_HTTP_STATUS_INTERNAL_SERVER_ERROR = 500,
    LCB_HTTP_STATUS_NOT_IMPLEMENTED = 501,
    LCB_HTTP_STATUS_BAD_GATEWAY = 502,
    LCB_HTTP_STATUS_SERVICE_UNAVAILABLE = 503,
    LCB_HTTP_STATUS_GATEWAY_TIMEOUT = 504,
    LCB_HTTP_STATUS_HTTP_VERSION_NOT_SUPPORTED = 505,
    LCB_HTTP_STATUS_INSUFFICIENT_STORAGE = 507,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_GETCMDv0 {
    pub key: *const ::std::os::raw::c_void,
    pub nkey: lcb_SIZE,
    pub exptime: lcb_time_t,
    pub lock: ::std::os::raw::c_int,
    pub hashkey: *const ::std::os::raw::c_void,
    pub nhashkey: lcb_SIZE,
}
#[test]
fn bindgen_test_layout_lcb_GETCMDv0() {
    assert_eq!(::std::mem::size_of::<lcb_GETCMDv0>() , 48usize , concat ! (
               "Size of: " , stringify ! ( lcb_GETCMDv0 ) ));
    assert_eq! (::std::mem::align_of::<lcb_GETCMDv0>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_GETCMDv0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_GETCMDv0 ) ) . key as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_GETCMDv0 ) , "::" ,
                stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_GETCMDv0 ) ) . nkey as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_GETCMDv0 ) , "::" ,
                stringify ! ( nkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_GETCMDv0 ) ) . exptime as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_GETCMDv0 ) , "::" ,
                stringify ! ( exptime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_GETCMDv0 ) ) . lock as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_GETCMDv0 ) , "::" ,
                stringify ! ( lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_GETCMDv0 ) ) . hashkey as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_GETCMDv0 ) , "::" ,
                stringify ! ( hashkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_GETCMDv0 ) ) . nhashkey as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_GETCMDv0 ) , "::" ,
                stringify ! ( nhashkey ) ));
}
impl Clone for lcb_GETCMDv0 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_get_cmd_st {
    pub version: ::std::os::raw::c_int,
    pub v: lcb_get_cmd_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_get_cmd_st__bindgen_ty_1 {
    pub v0: __BindgenUnionField<lcb_GETCMDv0>,
    pub bindgen_union_field: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_lcb_get_cmd_st__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<lcb_get_cmd_st__bindgen_ty_1>() , 48usize
               , concat ! (
               "Size of: " , stringify ! ( lcb_get_cmd_st__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<lcb_get_cmd_st__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_get_cmd_st__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_get_cmd_st__bindgen_ty_1 ) ) . v0 as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_get_cmd_st__bindgen_ty_1 ) , "::" , stringify ! ( v0 ) ));
}
impl Clone for lcb_get_cmd_st__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_lcb_get_cmd_st() {
    assert_eq!(::std::mem::size_of::<lcb_get_cmd_st>() , 56usize , concat ! (
               "Size of: " , stringify ! ( lcb_get_cmd_st ) ));
    assert_eq! (::std::mem::align_of::<lcb_get_cmd_st>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_get_cmd_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_get_cmd_st ) ) . version as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_get_cmd_st ) , "::"
                , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_get_cmd_st ) ) . v as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_get_cmd_st ) , "::"
                , stringify ! ( v ) ));
}
impl Clone for lcb_get_cmd_st {
    fn clone(&self) -> Self { *self }
}
pub type lcb_get_cmd_t = lcb_get_cmd_st;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_GETRESPv0 {
    pub key: *const ::std::os::raw::c_void,
    pub nkey: lcb_SIZE,
    pub bytes: *const ::std::os::raw::c_void,
    pub nbytes: lcb_SIZE,
    pub flags: lcb_U32,
    pub cas: lcb_cas_t,
    pub datatype: lcb_U8,
}
#[test]
fn bindgen_test_layout_lcb_GETRESPv0() {
    assert_eq!(::std::mem::size_of::<lcb_GETRESPv0>() , 56usize , concat ! (
               "Size of: " , stringify ! ( lcb_GETRESPv0 ) ));
    assert_eq! (::std::mem::align_of::<lcb_GETRESPv0>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_GETRESPv0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_GETRESPv0 ) ) . key as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_GETRESPv0 ) , "::"
                , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_GETRESPv0 ) ) . nkey as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_GETRESPv0 ) , "::"
                , stringify ! ( nkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_GETRESPv0 ) ) . bytes as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_GETRESPv0 ) , "::"
                , stringify ! ( bytes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_GETRESPv0 ) ) . nbytes as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_GETRESPv0 ) , "::"
                , stringify ! ( nbytes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_GETRESPv0 ) ) . flags as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_GETRESPv0 ) , "::"
                , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_GETRESPv0 ) ) . cas as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_GETRESPv0 ) , "::"
                , stringify ! ( cas ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_GETRESPv0 ) ) . datatype as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_GETRESPv0 ) , "::"
                , stringify ! ( datatype ) ));
}
impl Clone for lcb_GETRESPv0 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_get_resp_t {
    pub version: ::std::os::raw::c_int,
    pub v: lcb_get_resp_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_get_resp_t__bindgen_ty_1 {
    pub v0: __BindgenUnionField<lcb_GETRESPv0>,
    pub bindgen_union_field: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_lcb_get_resp_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<lcb_get_resp_t__bindgen_ty_1>() , 56usize
               , concat ! (
               "Size of: " , stringify ! ( lcb_get_resp_t__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<lcb_get_resp_t__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_get_resp_t__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_get_resp_t__bindgen_ty_1 ) ) . v0 as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_get_resp_t__bindgen_ty_1 ) , "::" , stringify ! ( v0 ) ));
}
impl Clone for lcb_get_resp_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_lcb_get_resp_t() {
    assert_eq!(::std::mem::size_of::<lcb_get_resp_t>() , 64usize , concat ! (
               "Size of: " , stringify ! ( lcb_get_resp_t ) ));
    assert_eq! (::std::mem::align_of::<lcb_get_resp_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_get_resp_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_get_resp_t ) ) . version as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_get_resp_t ) , "::"
                , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_get_resp_t ) ) . v as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_get_resp_t ) , "::"
                , stringify ! ( v ) ));
}
impl Clone for lcb_get_resp_t {
    fn clone(&self) -> Self { *self }
}
pub type lcb_get_callback =
    ::std::option::Option<unsafe extern "C" fn(instance: lcb_t,
                                               cookie:
                                                   *const ::std::os::raw::c_void,
                                               error: lcb_error_t,
                                               resp: *const lcb_get_resp_t)>;
extern "C" {
    pub fn lcb_set_get_callback(arg1: lcb_t, callback: lcb_get_callback)
     -> lcb_get_callback;
}
extern "C" {
    pub fn lcb_get(instance: lcb_t,
                   command_cookie: *const ::std::os::raw::c_void,
                   num: lcb_SIZE, commands: *const *const lcb_get_cmd_t)
     -> lcb_error_t;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_GETREPLICACMDv0 {
    pub key: *const ::std::os::raw::c_void,
    pub nkey: lcb_SIZE,
    pub hashkey: *const ::std::os::raw::c_void,
    pub nhashkey: lcb_SIZE,
}
#[test]
fn bindgen_test_layout_lcb_GETREPLICACMDv0() {
    assert_eq!(::std::mem::size_of::<lcb_GETREPLICACMDv0>() , 32usize , concat
               ! ( "Size of: " , stringify ! ( lcb_GETREPLICACMDv0 ) ));
    assert_eq! (::std::mem::align_of::<lcb_GETREPLICACMDv0>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( lcb_GETREPLICACMDv0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_GETREPLICACMDv0 ) ) . key as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_GETREPLICACMDv0 ) ,
                "::" , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_GETREPLICACMDv0 ) ) . nkey as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_GETREPLICACMDv0 ) ,
                "::" , stringify ! ( nkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_GETREPLICACMDv0 ) ) . hashkey as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_GETREPLICACMDv0 ) ,
                "::" , stringify ! ( hashkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_GETREPLICACMDv0 ) ) . nhashkey as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_GETREPLICACMDv0 ) ,
                "::" , stringify ! ( nhashkey ) ));
}
impl Clone for lcb_GETREPLICACMDv0 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_GETREPLICACMDv1 {
    pub key: *const ::std::os::raw::c_void,
    pub nkey: lcb_SIZE,
    pub hashkey: *const ::std::os::raw::c_void,
    pub nhashkey: lcb_SIZE,
    pub strategy: lcb_replica_t,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_lcb_GETREPLICACMDv1() {
    assert_eq!(::std::mem::size_of::<lcb_GETREPLICACMDv1>() , 40usize , concat
               ! ( "Size of: " , stringify ! ( lcb_GETREPLICACMDv1 ) ));
    assert_eq! (::std::mem::align_of::<lcb_GETREPLICACMDv1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( lcb_GETREPLICACMDv1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_GETREPLICACMDv1 ) ) . key as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_GETREPLICACMDv1 ) ,
                "::" , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_GETREPLICACMDv1 ) ) . nkey as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_GETREPLICACMDv1 ) ,
                "::" , stringify ! ( nkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_GETREPLICACMDv1 ) ) . hashkey as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_GETREPLICACMDv1 ) ,
                "::" , stringify ! ( hashkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_GETREPLICACMDv1 ) ) . nhashkey as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_GETREPLICACMDv1 ) ,
                "::" , stringify ! ( nhashkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_GETREPLICACMDv1 ) ) . strategy as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_GETREPLICACMDv1 ) ,
                "::" , stringify ! ( strategy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_GETREPLICACMDv1 ) ) . index as *
                const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_GETREPLICACMDv1 ) ,
                "::" , stringify ! ( index ) ));
}
impl Clone for lcb_GETREPLICACMDv1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_get_replica_cmd_st {
    pub version: ::std::os::raw::c_int,
    pub v: lcb_get_replica_cmd_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_get_replica_cmd_st__bindgen_ty_1 {
    pub v0: __BindgenUnionField<lcb_GETREPLICACMDv0>,
    pub v1: __BindgenUnionField<lcb_GETREPLICACMDv1>,
    pub bindgen_union_field: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_lcb_get_replica_cmd_st__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<lcb_get_replica_cmd_st__bindgen_ty_1>() ,
               40usize , concat ! (
               "Size of: " , stringify ! (
               lcb_get_replica_cmd_st__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<lcb_get_replica_cmd_st__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                lcb_get_replica_cmd_st__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_get_replica_cmd_st__bindgen_ty_1 ) )
                . v0 as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_get_replica_cmd_st__bindgen_ty_1 ) , "::" , stringify ! (
                v0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_get_replica_cmd_st__bindgen_ty_1 ) )
                . v1 as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_get_replica_cmd_st__bindgen_ty_1 ) , "::" , stringify ! (
                v1 ) ));
}
impl Clone for lcb_get_replica_cmd_st__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_lcb_get_replica_cmd_st() {
    assert_eq!(::std::mem::size_of::<lcb_get_replica_cmd_st>() , 48usize ,
               concat ! ( "Size of: " , stringify ! ( lcb_get_replica_cmd_st )
               ));
    assert_eq! (::std::mem::align_of::<lcb_get_replica_cmd_st>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( lcb_get_replica_cmd_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_get_replica_cmd_st ) ) . version as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_get_replica_cmd_st
                ) , "::" , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_get_replica_cmd_st ) ) . v as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_get_replica_cmd_st
                ) , "::" , stringify ! ( v ) ));
}
impl Clone for lcb_get_replica_cmd_st {
    fn clone(&self) -> Self { *self }
}
pub type lcb_get_replica_cmd_t = lcb_get_replica_cmd_st;
extern "C" {
    pub fn lcb_get_replica(instance: lcb_t,
                           command_cookie: *const ::std::os::raw::c_void,
                           num: lcb_SIZE,
                           commands: *const *const lcb_get_replica_cmd_t)
     -> lcb_error_t;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_UNLOCKCMDv0 {
    pub key: *const ::std::os::raw::c_void,
    pub nkey: lcb_SIZE,
    pub cas: lcb_cas_t,
    pub hashkey: *const ::std::os::raw::c_void,
    pub nhashkey: lcb_SIZE,
}
#[test]
fn bindgen_test_layout_lcb_UNLOCKCMDv0() {
    assert_eq!(::std::mem::size_of::<lcb_UNLOCKCMDv0>() , 40usize , concat ! (
               "Size of: " , stringify ! ( lcb_UNLOCKCMDv0 ) ));
    assert_eq! (::std::mem::align_of::<lcb_UNLOCKCMDv0>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( lcb_UNLOCKCMDv0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_UNLOCKCMDv0 ) ) . key as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_UNLOCKCMDv0 ) ,
                "::" , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_UNLOCKCMDv0 ) ) . nkey as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_UNLOCKCMDv0 ) ,
                "::" , stringify ! ( nkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_UNLOCKCMDv0 ) ) . cas as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_UNLOCKCMDv0 ) ,
                "::" , stringify ! ( cas ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_UNLOCKCMDv0 ) ) . hashkey as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_UNLOCKCMDv0 ) ,
                "::" , stringify ! ( hashkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_UNLOCKCMDv0 ) ) . nhashkey as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_UNLOCKCMDv0 ) ,
                "::" , stringify ! ( nhashkey ) ));
}
impl Clone for lcb_UNLOCKCMDv0 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_unlock_cmd_st {
    pub version: ::std::os::raw::c_int,
    pub v: lcb_unlock_cmd_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_unlock_cmd_st__bindgen_ty_1 {
    pub v0: __BindgenUnionField<lcb_UNLOCKCMDv0>,
    pub bindgen_union_field: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_lcb_unlock_cmd_st__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<lcb_unlock_cmd_st__bindgen_ty_1>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( lcb_unlock_cmd_st__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<lcb_unlock_cmd_st__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                lcb_unlock_cmd_st__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_unlock_cmd_st__bindgen_ty_1 ) ) . v0
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_unlock_cmd_st__bindgen_ty_1 ) , "::" , stringify ! ( v0 )
                ));
}
impl Clone for lcb_unlock_cmd_st__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_lcb_unlock_cmd_st() {
    assert_eq!(::std::mem::size_of::<lcb_unlock_cmd_st>() , 48usize , concat !
               ( "Size of: " , stringify ! ( lcb_unlock_cmd_st ) ));
    assert_eq! (::std::mem::align_of::<lcb_unlock_cmd_st>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( lcb_unlock_cmd_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_unlock_cmd_st ) ) . version as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_unlock_cmd_st ) ,
                "::" , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_unlock_cmd_st ) ) . v as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_unlock_cmd_st ) ,
                "::" , stringify ! ( v ) ));
}
impl Clone for lcb_unlock_cmd_st {
    fn clone(&self) -> Self { *self }
}
pub type lcb_unlock_cmd_t = lcb_unlock_cmd_st;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_UNLOCKRESPv0 {
    pub key: *const ::std::os::raw::c_void,
    pub nkey: lcb_SIZE,
}
#[test]
fn bindgen_test_layout_lcb_UNLOCKRESPv0() {
    assert_eq!(::std::mem::size_of::<lcb_UNLOCKRESPv0>() , 16usize , concat !
               ( "Size of: " , stringify ! ( lcb_UNLOCKRESPv0 ) ));
    assert_eq! (::std::mem::align_of::<lcb_UNLOCKRESPv0>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( lcb_UNLOCKRESPv0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_UNLOCKRESPv0 ) ) . key as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_UNLOCKRESPv0 ) ,
                "::" , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_UNLOCKRESPv0 ) ) . nkey as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_UNLOCKRESPv0 ) ,
                "::" , stringify ! ( nkey ) ));
}
impl Clone for lcb_UNLOCKRESPv0 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_unlock_resp_t {
    pub version: ::std::os::raw::c_int,
    pub v: lcb_unlock_resp_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_unlock_resp_t__bindgen_ty_1 {
    pub v0: __BindgenUnionField<lcb_UNLOCKRESPv0>,
    pub bindgen_union_field: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_lcb_unlock_resp_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<lcb_unlock_resp_t__bindgen_ty_1>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( lcb_unlock_resp_t__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<lcb_unlock_resp_t__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                lcb_unlock_resp_t__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_unlock_resp_t__bindgen_ty_1 ) ) . v0
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_unlock_resp_t__bindgen_ty_1 ) , "::" , stringify ! ( v0 )
                ));
}
impl Clone for lcb_unlock_resp_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_lcb_unlock_resp_t() {
    assert_eq!(::std::mem::size_of::<lcb_unlock_resp_t>() , 24usize , concat !
               ( "Size of: " , stringify ! ( lcb_unlock_resp_t ) ));
    assert_eq! (::std::mem::align_of::<lcb_unlock_resp_t>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( lcb_unlock_resp_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_unlock_resp_t ) ) . version as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_unlock_resp_t ) ,
                "::" , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_unlock_resp_t ) ) . v as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_unlock_resp_t ) ,
                "::" , stringify ! ( v ) ));
}
impl Clone for lcb_unlock_resp_t {
    fn clone(&self) -> Self { *self }
}
pub type lcb_unlock_callback =
    ::std::option::Option<unsafe extern "C" fn(instance: lcb_t,
                                               cookie:
                                                   *const ::std::os::raw::c_void,
                                               error: lcb_error_t,
                                               resp:
                                                   *const lcb_unlock_resp_t)>;
extern "C" {
    pub fn lcb_set_unlock_callback(arg1: lcb_t, arg2: lcb_unlock_callback)
     -> lcb_unlock_callback;
}
extern "C" {
    pub fn lcb_unlock(instance: lcb_t,
                      command_cookie: *const ::std::os::raw::c_void,
                      num: lcb_SIZE, commands: *const *const lcb_unlock_cmd_t)
     -> lcb_error_t;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_STORECMDv0 {
    pub key: *const ::std::os::raw::c_void,
    pub nkey: lcb_SIZE,
    pub bytes: *const ::std::os::raw::c_void,
    pub nbytes: lcb_SIZE,
    pub flags: lcb_U32,
    pub cas: lcb_cas_t,
    pub datatype: lcb_U8,
    pub exptime: lcb_time_t,
    pub operation: lcb_storage_t,
    pub hashkey: *const ::std::os::raw::c_void,
    pub nhashkey: lcb_SIZE,
}
#[test]
fn bindgen_test_layout_lcb_STORECMDv0() {
    assert_eq!(::std::mem::size_of::<lcb_STORECMDv0>() , 88usize , concat ! (
               "Size of: " , stringify ! ( lcb_STORECMDv0 ) ));
    assert_eq! (::std::mem::align_of::<lcb_STORECMDv0>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_STORECMDv0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_STORECMDv0 ) ) . key as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_STORECMDv0 ) , "::"
                , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_STORECMDv0 ) ) . nkey as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_STORECMDv0 ) , "::"
                , stringify ! ( nkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_STORECMDv0 ) ) . bytes as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_STORECMDv0 ) , "::"
                , stringify ! ( bytes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_STORECMDv0 ) ) . nbytes as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_STORECMDv0 ) , "::"
                , stringify ! ( nbytes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_STORECMDv0 ) ) . flags as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_STORECMDv0 ) , "::"
                , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_STORECMDv0 ) ) . cas as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_STORECMDv0 ) , "::"
                , stringify ! ( cas ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_STORECMDv0 ) ) . datatype as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_STORECMDv0 ) , "::"
                , stringify ! ( datatype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_STORECMDv0 ) ) . exptime as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_STORECMDv0 ) , "::"
                , stringify ! ( exptime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_STORECMDv0 ) ) . operation as * const
                _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_STORECMDv0 ) , "::"
                , stringify ! ( operation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_STORECMDv0 ) ) . hashkey as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_STORECMDv0 ) , "::"
                , stringify ! ( hashkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_STORECMDv0 ) ) . nhashkey as * const
                _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_STORECMDv0 ) , "::"
                , stringify ! ( nhashkey ) ));
}
impl Clone for lcb_STORECMDv0 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_store_cmd_st {
    pub version: ::std::os::raw::c_int,
    pub v: lcb_store_cmd_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_store_cmd_st__bindgen_ty_1 {
    pub v0: __BindgenUnionField<lcb_STORECMDv0>,
    pub bindgen_union_field: [u64; 11usize],
}
#[test]
fn bindgen_test_layout_lcb_store_cmd_st__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<lcb_store_cmd_st__bindgen_ty_1>() ,
               88usize , concat ! (
               "Size of: " , stringify ! ( lcb_store_cmd_st__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<lcb_store_cmd_st__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_store_cmd_st__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_store_cmd_st__bindgen_ty_1 ) ) . v0
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_store_cmd_st__bindgen_ty_1 ) , "::" , stringify ! ( v0 )
                ));
}
impl Clone for lcb_store_cmd_st__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_lcb_store_cmd_st() {
    assert_eq!(::std::mem::size_of::<lcb_store_cmd_st>() , 96usize , concat !
               ( "Size of: " , stringify ! ( lcb_store_cmd_st ) ));
    assert_eq! (::std::mem::align_of::<lcb_store_cmd_st>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( lcb_store_cmd_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_store_cmd_st ) ) . version as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_store_cmd_st ) ,
                "::" , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_store_cmd_st ) ) . v as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_store_cmd_st ) ,
                "::" , stringify ! ( v ) ));
}
impl Clone for lcb_store_cmd_st {
    fn clone(&self) -> Self { *self }
}
pub type lcb_store_cmd_t = lcb_store_cmd_st;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_STORERESPv0 {
    pub key: *const ::std::os::raw::c_void,
    pub nkey: lcb_SIZE,
    pub cas: lcb_cas_t,
    pub mutation_token: *const lcb_MUTATION_TOKEN,
}
#[test]
fn bindgen_test_layout_lcb_STORERESPv0() {
    assert_eq!(::std::mem::size_of::<lcb_STORERESPv0>() , 32usize , concat ! (
               "Size of: " , stringify ! ( lcb_STORERESPv0 ) ));
    assert_eq! (::std::mem::align_of::<lcb_STORERESPv0>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( lcb_STORERESPv0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_STORERESPv0 ) ) . key as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_STORERESPv0 ) ,
                "::" , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_STORERESPv0 ) ) . nkey as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_STORERESPv0 ) ,
                "::" , stringify ! ( nkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_STORERESPv0 ) ) . cas as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_STORERESPv0 ) ,
                "::" , stringify ! ( cas ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_STORERESPv0 ) ) . mutation_token as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_STORERESPv0 ) ,
                "::" , stringify ! ( mutation_token ) ));
}
impl Clone for lcb_STORERESPv0 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_store_resp_t {
    pub version: ::std::os::raw::c_int,
    pub v: lcb_store_resp_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_store_resp_t__bindgen_ty_1 {
    pub v0: __BindgenUnionField<lcb_STORERESPv0>,
    pub bindgen_union_field: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_lcb_store_resp_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<lcb_store_resp_t__bindgen_ty_1>() ,
               32usize , concat ! (
               "Size of: " , stringify ! ( lcb_store_resp_t__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<lcb_store_resp_t__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_store_resp_t__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_store_resp_t__bindgen_ty_1 ) ) . v0
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_store_resp_t__bindgen_ty_1 ) , "::" , stringify ! ( v0 )
                ));
}
impl Clone for lcb_store_resp_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_lcb_store_resp_t() {
    assert_eq!(::std::mem::size_of::<lcb_store_resp_t>() , 40usize , concat !
               ( "Size of: " , stringify ! ( lcb_store_resp_t ) ));
    assert_eq! (::std::mem::align_of::<lcb_store_resp_t>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( lcb_store_resp_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_store_resp_t ) ) . version as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_store_resp_t ) ,
                "::" , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_store_resp_t ) ) . v as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_store_resp_t ) ,
                "::" , stringify ! ( v ) ));
}
impl Clone for lcb_store_resp_t {
    fn clone(&self) -> Self { *self }
}
pub type lcb_store_callback =
    ::std::option::Option<unsafe extern "C" fn(instance: lcb_t,
                                               cookie:
                                                   *const ::std::os::raw::c_void,
                                               operation: lcb_storage_t,
                                               error: lcb_error_t,
                                               resp:
                                                   *const lcb_store_resp_t)>;
extern "C" {
    pub fn lcb_set_store_callback(arg1: lcb_t, callback: lcb_store_callback)
     -> lcb_store_callback;
}
extern "C" {
    pub fn lcb_store(instance: lcb_t,
                     command_cookie: *const ::std::os::raw::c_void,
                     num: lcb_SIZE, commands: *const *const lcb_store_cmd_t)
     -> lcb_error_t;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_ARITHCMDv0 {
    pub key: *const ::std::os::raw::c_void,
    pub nkey: lcb_SIZE,
    pub exptime: lcb_time_t,
    pub create: ::std::os::raw::c_int,
    pub delta: lcb_S64,
    pub initial: lcb_U64,
    pub hashkey: *const ::std::os::raw::c_void,
    pub nhashkey: lcb_SIZE,
}
#[test]
fn bindgen_test_layout_lcb_ARITHCMDv0() {
    assert_eq!(::std::mem::size_of::<lcb_ARITHCMDv0>() , 64usize , concat ! (
               "Size of: " , stringify ! ( lcb_ARITHCMDv0 ) ));
    assert_eq! (::std::mem::align_of::<lcb_ARITHCMDv0>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_ARITHCMDv0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_ARITHCMDv0 ) ) . key as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_ARITHCMDv0 ) , "::"
                , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_ARITHCMDv0 ) ) . nkey as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_ARITHCMDv0 ) , "::"
                , stringify ! ( nkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_ARITHCMDv0 ) ) . exptime as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_ARITHCMDv0 ) , "::"
                , stringify ! ( exptime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_ARITHCMDv0 ) ) . create as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_ARITHCMDv0 ) , "::"
                , stringify ! ( create ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_ARITHCMDv0 ) ) . delta as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_ARITHCMDv0 ) , "::"
                , stringify ! ( delta ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_ARITHCMDv0 ) ) . initial as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_ARITHCMDv0 ) , "::"
                , stringify ! ( initial ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_ARITHCMDv0 ) ) . hashkey as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_ARITHCMDv0 ) , "::"
                , stringify ! ( hashkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_ARITHCMDv0 ) ) . nhashkey as * const
                _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_ARITHCMDv0 ) , "::"
                , stringify ! ( nhashkey ) ));
}
impl Clone for lcb_ARITHCMDv0 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_arithmetic_cmd_st {
    pub version: ::std::os::raw::c_int,
    pub v: lcb_arithmetic_cmd_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_arithmetic_cmd_st__bindgen_ty_1 {
    pub v0: __BindgenUnionField<lcb_ARITHCMDv0>,
    pub bindgen_union_field: [u64; 8usize],
}
#[test]
fn bindgen_test_layout_lcb_arithmetic_cmd_st__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<lcb_arithmetic_cmd_st__bindgen_ty_1>() ,
               64usize , concat ! (
               "Size of: " , stringify ! ( lcb_arithmetic_cmd_st__bindgen_ty_1
               ) ));
    assert_eq! (::std::mem::align_of::<lcb_arithmetic_cmd_st__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                lcb_arithmetic_cmd_st__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_arithmetic_cmd_st__bindgen_ty_1 ) ) .
                v0 as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_arithmetic_cmd_st__bindgen_ty_1 ) , "::" , stringify ! (
                v0 ) ));
}
impl Clone for lcb_arithmetic_cmd_st__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_lcb_arithmetic_cmd_st() {
    assert_eq!(::std::mem::size_of::<lcb_arithmetic_cmd_st>() , 72usize ,
               concat ! ( "Size of: " , stringify ! ( lcb_arithmetic_cmd_st )
               ));
    assert_eq! (::std::mem::align_of::<lcb_arithmetic_cmd_st>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( lcb_arithmetic_cmd_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_arithmetic_cmd_st ) ) . version as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_arithmetic_cmd_st )
                , "::" , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_arithmetic_cmd_st ) ) . v as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_arithmetic_cmd_st )
                , "::" , stringify ! ( v ) ));
}
impl Clone for lcb_arithmetic_cmd_st {
    fn clone(&self) -> Self { *self }
}
pub type lcb_arithmetic_cmd_t = lcb_arithmetic_cmd_st;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_ARITHRESPv0 {
    pub key: *const ::std::os::raw::c_void,
    pub nkey: lcb_SIZE,
    pub value: lcb_U64,
    pub cas: lcb_cas_t,
    pub mutation_token: *const lcb_MUTATION_TOKEN,
}
#[test]
fn bindgen_test_layout_lcb_ARITHRESPv0() {
    assert_eq!(::std::mem::size_of::<lcb_ARITHRESPv0>() , 40usize , concat ! (
               "Size of: " , stringify ! ( lcb_ARITHRESPv0 ) ));
    assert_eq! (::std::mem::align_of::<lcb_ARITHRESPv0>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( lcb_ARITHRESPv0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_ARITHRESPv0 ) ) . key as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_ARITHRESPv0 ) ,
                "::" , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_ARITHRESPv0 ) ) . nkey as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_ARITHRESPv0 ) ,
                "::" , stringify ! ( nkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_ARITHRESPv0 ) ) . value as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_ARITHRESPv0 ) ,
                "::" , stringify ! ( value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_ARITHRESPv0 ) ) . cas as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_ARITHRESPv0 ) ,
                "::" , stringify ! ( cas ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_ARITHRESPv0 ) ) . mutation_token as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_ARITHRESPv0 ) ,
                "::" , stringify ! ( mutation_token ) ));
}
impl Clone for lcb_ARITHRESPv0 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_arithmetic_resp_t {
    pub version: ::std::os::raw::c_int,
    pub v: lcb_arithmetic_resp_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_arithmetic_resp_t__bindgen_ty_1 {
    pub v0: __BindgenUnionField<lcb_ARITHRESPv0>,
    pub bindgen_union_field: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_lcb_arithmetic_resp_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<lcb_arithmetic_resp_t__bindgen_ty_1>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( lcb_arithmetic_resp_t__bindgen_ty_1
               ) ));
    assert_eq! (::std::mem::align_of::<lcb_arithmetic_resp_t__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                lcb_arithmetic_resp_t__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_arithmetic_resp_t__bindgen_ty_1 ) ) .
                v0 as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_arithmetic_resp_t__bindgen_ty_1 ) , "::" , stringify ! (
                v0 ) ));
}
impl Clone for lcb_arithmetic_resp_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_lcb_arithmetic_resp_t() {
    assert_eq!(::std::mem::size_of::<lcb_arithmetic_resp_t>() , 48usize ,
               concat ! ( "Size of: " , stringify ! ( lcb_arithmetic_resp_t )
               ));
    assert_eq! (::std::mem::align_of::<lcb_arithmetic_resp_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( lcb_arithmetic_resp_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_arithmetic_resp_t ) ) . version as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_arithmetic_resp_t )
                , "::" , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_arithmetic_resp_t ) ) . v as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_arithmetic_resp_t )
                , "::" , stringify ! ( v ) ));
}
impl Clone for lcb_arithmetic_resp_t {
    fn clone(&self) -> Self { *self }
}
pub type lcb_arithmetic_callback =
    ::std::option::Option<unsafe extern "C" fn(instance: lcb_t,
                                               cookie:
                                                   *const ::std::os::raw::c_void,
                                               error: lcb_error_t,
                                               resp:
                                                   *const lcb_arithmetic_resp_t)>;
extern "C" {
    pub fn lcb_set_arithmetic_callback(arg1: lcb_t,
                                       arg2: lcb_arithmetic_callback)
     -> lcb_arithmetic_callback;
}
extern "C" {
    pub fn lcb_arithmetic(instance: lcb_t,
                          command_cookie: *const ::std::os::raw::c_void,
                          num: lcb_SIZE,
                          commands: *const *const lcb_arithmetic_cmd_t)
     -> lcb_error_t;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum lcb_observe_options_t { LCB_OBSERVE_MASTER_ONLY = 1, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_OBSERVECMDv0 {
    pub key: *const ::std::os::raw::c_void,
    pub nkey: lcb_SIZE,
    pub hashkey: *const ::std::os::raw::c_void,
    pub nhashkey: lcb_SIZE,
}
#[test]
fn bindgen_test_layout_lcb_OBSERVECMDv0() {
    assert_eq!(::std::mem::size_of::<lcb_OBSERVECMDv0>() , 32usize , concat !
               ( "Size of: " , stringify ! ( lcb_OBSERVECMDv0 ) ));
    assert_eq! (::std::mem::align_of::<lcb_OBSERVECMDv0>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( lcb_OBSERVECMDv0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_OBSERVECMDv0 ) ) . key as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_OBSERVECMDv0 ) ,
                "::" , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_OBSERVECMDv0 ) ) . nkey as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_OBSERVECMDv0 ) ,
                "::" , stringify ! ( nkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_OBSERVECMDv0 ) ) . hashkey as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_OBSERVECMDv0 ) ,
                "::" , stringify ! ( hashkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_OBSERVECMDv0 ) ) . nhashkey as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_OBSERVECMDv0 ) ,
                "::" , stringify ! ( nhashkey ) ));
}
impl Clone for lcb_OBSERVECMDv0 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_OBSERVECMDv1 {
    pub key: *const ::std::os::raw::c_void,
    pub nkey: lcb_SIZE,
    pub hashkey: *const ::std::os::raw::c_void,
    pub nhashkey: lcb_SIZE,
    pub options: lcb_observe_options_t,
}
#[test]
fn bindgen_test_layout_lcb_OBSERVECMDv1() {
    assert_eq!(::std::mem::size_of::<lcb_OBSERVECMDv1>() , 40usize , concat !
               ( "Size of: " , stringify ! ( lcb_OBSERVECMDv1 ) ));
    assert_eq! (::std::mem::align_of::<lcb_OBSERVECMDv1>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( lcb_OBSERVECMDv1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_OBSERVECMDv1 ) ) . key as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_OBSERVECMDv1 ) ,
                "::" , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_OBSERVECMDv1 ) ) . nkey as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_OBSERVECMDv1 ) ,
                "::" , stringify ! ( nkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_OBSERVECMDv1 ) ) . hashkey as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_OBSERVECMDv1 ) ,
                "::" , stringify ! ( hashkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_OBSERVECMDv1 ) ) . nhashkey as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_OBSERVECMDv1 ) ,
                "::" , stringify ! ( nhashkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_OBSERVECMDv1 ) ) . options as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_OBSERVECMDv1 ) ,
                "::" , stringify ! ( options ) ));
}
impl Clone for lcb_OBSERVECMDv1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_observe_cmd_st {
    pub version: ::std::os::raw::c_int,
    pub v: lcb_observe_cmd_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_observe_cmd_st__bindgen_ty_1 {
    pub v0: __BindgenUnionField<lcb_OBSERVECMDv0>,
    pub v1: __BindgenUnionField<lcb_OBSERVECMDv1>,
    pub bindgen_union_field: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_lcb_observe_cmd_st__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<lcb_observe_cmd_st__bindgen_ty_1>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( lcb_observe_cmd_st__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<lcb_observe_cmd_st__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                lcb_observe_cmd_st__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_observe_cmd_st__bindgen_ty_1 ) ) . v0
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_observe_cmd_st__bindgen_ty_1 ) , "::" , stringify ! ( v0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_observe_cmd_st__bindgen_ty_1 ) ) . v1
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_observe_cmd_st__bindgen_ty_1 ) , "::" , stringify ! ( v1 )
                ));
}
impl Clone for lcb_observe_cmd_st__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_lcb_observe_cmd_st() {
    assert_eq!(::std::mem::size_of::<lcb_observe_cmd_st>() , 48usize , concat
               ! ( "Size of: " , stringify ! ( lcb_observe_cmd_st ) ));
    assert_eq! (::std::mem::align_of::<lcb_observe_cmd_st>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( lcb_observe_cmd_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_observe_cmd_st ) ) . version as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_observe_cmd_st ) ,
                "::" , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_observe_cmd_st ) ) . v as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_observe_cmd_st ) ,
                "::" , stringify ! ( v ) ));
}
impl Clone for lcb_observe_cmd_st {
    fn clone(&self) -> Self { *self }
}
pub type lcb_observe_cmd_t = lcb_observe_cmd_st;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_OBSERVERESPv0 {
    pub key: *const ::std::os::raw::c_void,
    pub nkey: lcb_SIZE,
    pub cas: lcb_cas_t,
    pub status: lcb_observe_t,
    pub from_master: ::std::os::raw::c_int,
    pub ttp: lcb_time_t,
    pub ttr: lcb_time_t,
}
#[test]
fn bindgen_test_layout_lcb_OBSERVERESPv0() {
    assert_eq!(::std::mem::size_of::<lcb_OBSERVERESPv0>() , 48usize , concat !
               ( "Size of: " , stringify ! ( lcb_OBSERVERESPv0 ) ));
    assert_eq! (::std::mem::align_of::<lcb_OBSERVERESPv0>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( lcb_OBSERVERESPv0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_OBSERVERESPv0 ) ) . key as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_OBSERVERESPv0 ) ,
                "::" , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_OBSERVERESPv0 ) ) . nkey as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_OBSERVERESPv0 ) ,
                "::" , stringify ! ( nkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_OBSERVERESPv0 ) ) . cas as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_OBSERVERESPv0 ) ,
                "::" , stringify ! ( cas ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_OBSERVERESPv0 ) ) . status as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_OBSERVERESPv0 ) ,
                "::" , stringify ! ( status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_OBSERVERESPv0 ) ) . from_master as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_OBSERVERESPv0 ) ,
                "::" , stringify ! ( from_master ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_OBSERVERESPv0 ) ) . ttp as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_OBSERVERESPv0 ) ,
                "::" , stringify ! ( ttp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_OBSERVERESPv0 ) ) . ttr as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_OBSERVERESPv0 ) ,
                "::" , stringify ! ( ttr ) ));
}
impl Clone for lcb_OBSERVERESPv0 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_observe_resp_t {
    pub version: ::std::os::raw::c_int,
    pub v: lcb_observe_resp_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_observe_resp_t__bindgen_ty_1 {
    pub v0: __BindgenUnionField<lcb_OBSERVERESPv0>,
    pub bindgen_union_field: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_lcb_observe_resp_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<lcb_observe_resp_t__bindgen_ty_1>() ,
               48usize , concat ! (
               "Size of: " , stringify ! ( lcb_observe_resp_t__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<lcb_observe_resp_t__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                lcb_observe_resp_t__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_observe_resp_t__bindgen_ty_1 ) ) . v0
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_observe_resp_t__bindgen_ty_1 ) , "::" , stringify ! ( v0 )
                ));
}
impl Clone for lcb_observe_resp_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_lcb_observe_resp_t() {
    assert_eq!(::std::mem::size_of::<lcb_observe_resp_t>() , 56usize , concat
               ! ( "Size of: " , stringify ! ( lcb_observe_resp_t ) ));
    assert_eq! (::std::mem::align_of::<lcb_observe_resp_t>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( lcb_observe_resp_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_observe_resp_t ) ) . version as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_observe_resp_t ) ,
                "::" , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_observe_resp_t ) ) . v as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_observe_resp_t ) ,
                "::" , stringify ! ( v ) ));
}
impl Clone for lcb_observe_resp_t {
    fn clone(&self) -> Self { *self }
}
pub type lcb_observe_callback =
    ::std::option::Option<unsafe extern "C" fn(instance: lcb_t,
                                               cookie:
                                                   *const ::std::os::raw::c_void,
                                               error: lcb_error_t,
                                               resp:
                                                   *const lcb_observe_resp_t)>;
extern "C" {
    pub fn lcb_set_observe_callback(arg1: lcb_t, arg2: lcb_observe_callback)
     -> lcb_observe_callback;
}
extern "C" {
    pub fn lcb_observe(instance: lcb_t,
                       command_cookie: *const ::std::os::raw::c_void,
                       num: lcb_SIZE,
                       commands: *const *const lcb_observe_cmd_t)
     -> lcb_error_t;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_REMOVECMDv0 {
    pub key: *const ::std::os::raw::c_void,
    pub nkey: lcb_SIZE,
    pub cas: lcb_cas_t,
    pub hashkey: *const ::std::os::raw::c_void,
    pub nhashkey: lcb_SIZE,
}
#[test]
fn bindgen_test_layout_lcb_REMOVECMDv0() {
    assert_eq!(::std::mem::size_of::<lcb_REMOVECMDv0>() , 40usize , concat ! (
               "Size of: " , stringify ! ( lcb_REMOVECMDv0 ) ));
    assert_eq! (::std::mem::align_of::<lcb_REMOVECMDv0>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( lcb_REMOVECMDv0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_REMOVECMDv0 ) ) . key as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_REMOVECMDv0 ) ,
                "::" , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_REMOVECMDv0 ) ) . nkey as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_REMOVECMDv0 ) ,
                "::" , stringify ! ( nkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_REMOVECMDv0 ) ) . cas as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_REMOVECMDv0 ) ,
                "::" , stringify ! ( cas ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_REMOVECMDv0 ) ) . hashkey as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_REMOVECMDv0 ) ,
                "::" , stringify ! ( hashkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_REMOVECMDv0 ) ) . nhashkey as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_REMOVECMDv0 ) ,
                "::" , stringify ! ( nhashkey ) ));
}
impl Clone for lcb_REMOVECMDv0 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_remove_cmd_st {
    pub version: ::std::os::raw::c_int,
    pub v: lcb_remove_cmd_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_remove_cmd_st__bindgen_ty_1 {
    pub v0: __BindgenUnionField<lcb_REMOVECMDv0>,
    pub bindgen_union_field: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_lcb_remove_cmd_st__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<lcb_remove_cmd_st__bindgen_ty_1>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( lcb_remove_cmd_st__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<lcb_remove_cmd_st__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                lcb_remove_cmd_st__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_remove_cmd_st__bindgen_ty_1 ) ) . v0
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_remove_cmd_st__bindgen_ty_1 ) , "::" , stringify ! ( v0 )
                ));
}
impl Clone for lcb_remove_cmd_st__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_lcb_remove_cmd_st() {
    assert_eq!(::std::mem::size_of::<lcb_remove_cmd_st>() , 48usize , concat !
               ( "Size of: " , stringify ! ( lcb_remove_cmd_st ) ));
    assert_eq! (::std::mem::align_of::<lcb_remove_cmd_st>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( lcb_remove_cmd_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_remove_cmd_st ) ) . version as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_remove_cmd_st ) ,
                "::" , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_remove_cmd_st ) ) . v as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_remove_cmd_st ) ,
                "::" , stringify ! ( v ) ));
}
impl Clone for lcb_remove_cmd_st {
    fn clone(&self) -> Self { *self }
}
pub type lcb_remove_cmd_t = lcb_remove_cmd_st;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_REMOVERESPv0 {
    pub key: *const ::std::os::raw::c_void,
    pub nkey: lcb_SIZE,
    pub cas: lcb_cas_t,
    pub mutation_token: *const lcb_MUTATION_TOKEN,
}
#[test]
fn bindgen_test_layout_lcb_REMOVERESPv0() {
    assert_eq!(::std::mem::size_of::<lcb_REMOVERESPv0>() , 32usize , concat !
               ( "Size of: " , stringify ! ( lcb_REMOVERESPv0 ) ));
    assert_eq! (::std::mem::align_of::<lcb_REMOVERESPv0>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( lcb_REMOVERESPv0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_REMOVERESPv0 ) ) . key as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_REMOVERESPv0 ) ,
                "::" , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_REMOVERESPv0 ) ) . nkey as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_REMOVERESPv0 ) ,
                "::" , stringify ! ( nkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_REMOVERESPv0 ) ) . cas as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_REMOVERESPv0 ) ,
                "::" , stringify ! ( cas ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_REMOVERESPv0 ) ) . mutation_token as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_REMOVERESPv0 ) ,
                "::" , stringify ! ( mutation_token ) ));
}
impl Clone for lcb_REMOVERESPv0 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_remove_resp_t {
    pub version: ::std::os::raw::c_int,
    pub v: lcb_remove_resp_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_remove_resp_t__bindgen_ty_1 {
    pub v0: __BindgenUnionField<lcb_REMOVERESPv0>,
    pub bindgen_union_field: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_lcb_remove_resp_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<lcb_remove_resp_t__bindgen_ty_1>() ,
               32usize , concat ! (
               "Size of: " , stringify ! ( lcb_remove_resp_t__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<lcb_remove_resp_t__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                lcb_remove_resp_t__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_remove_resp_t__bindgen_ty_1 ) ) . v0
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_remove_resp_t__bindgen_ty_1 ) , "::" , stringify ! ( v0 )
                ));
}
impl Clone for lcb_remove_resp_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_lcb_remove_resp_t() {
    assert_eq!(::std::mem::size_of::<lcb_remove_resp_t>() , 40usize , concat !
               ( "Size of: " , stringify ! ( lcb_remove_resp_t ) ));
    assert_eq! (::std::mem::align_of::<lcb_remove_resp_t>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( lcb_remove_resp_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_remove_resp_t ) ) . version as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_remove_resp_t ) ,
                "::" , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_remove_resp_t ) ) . v as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_remove_resp_t ) ,
                "::" , stringify ! ( v ) ));
}
impl Clone for lcb_remove_resp_t {
    fn clone(&self) -> Self { *self }
}
pub type lcb_remove_callback =
    ::std::option::Option<unsafe extern "C" fn(instance: lcb_t,
                                               cookie:
                                                   *const ::std::os::raw::c_void,
                                               error: lcb_error_t,
                                               resp:
                                                   *const lcb_remove_resp_t)>;
extern "C" {
    pub fn lcb_set_remove_callback(arg1: lcb_t, arg2: lcb_remove_callback)
     -> lcb_remove_callback;
}
extern "C" {
    pub fn lcb_remove(instance: lcb_t,
                      command_cookie: *const ::std::os::raw::c_void,
                      num: lcb_SIZE, commands: *const *const lcb_remove_cmd_t)
     -> lcb_error_t;
}
pub type lcb_touch_cmd_t = lcb_get_cmd_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_TOUCHRESPv0 {
    pub key: *const ::std::os::raw::c_void,
    pub nkey: lcb_SIZE,
    pub cas: lcb_cas_t,
}
#[test]
fn bindgen_test_layout_lcb_TOUCHRESPv0() {
    assert_eq!(::std::mem::size_of::<lcb_TOUCHRESPv0>() , 24usize , concat ! (
               "Size of: " , stringify ! ( lcb_TOUCHRESPv0 ) ));
    assert_eq! (::std::mem::align_of::<lcb_TOUCHRESPv0>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( lcb_TOUCHRESPv0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_TOUCHRESPv0 ) ) . key as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_TOUCHRESPv0 ) ,
                "::" , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_TOUCHRESPv0 ) ) . nkey as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_TOUCHRESPv0 ) ,
                "::" , stringify ! ( nkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_TOUCHRESPv0 ) ) . cas as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_TOUCHRESPv0 ) ,
                "::" , stringify ! ( cas ) ));
}
impl Clone for lcb_TOUCHRESPv0 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_touch_resp_t {
    pub version: ::std::os::raw::c_int,
    pub v: lcb_touch_resp_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_touch_resp_t__bindgen_ty_1 {
    pub v0: __BindgenUnionField<lcb_TOUCHRESPv0>,
    pub bindgen_union_field: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_lcb_touch_resp_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<lcb_touch_resp_t__bindgen_ty_1>() ,
               24usize , concat ! (
               "Size of: " , stringify ! ( lcb_touch_resp_t__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<lcb_touch_resp_t__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_touch_resp_t__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_touch_resp_t__bindgen_ty_1 ) ) . v0
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_touch_resp_t__bindgen_ty_1 ) , "::" , stringify ! ( v0 )
                ));
}
impl Clone for lcb_touch_resp_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_lcb_touch_resp_t() {
    assert_eq!(::std::mem::size_of::<lcb_touch_resp_t>() , 32usize , concat !
               ( "Size of: " , stringify ! ( lcb_touch_resp_t ) ));
    assert_eq! (::std::mem::align_of::<lcb_touch_resp_t>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( lcb_touch_resp_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_touch_resp_t ) ) . version as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_touch_resp_t ) ,
                "::" , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_touch_resp_t ) ) . v as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_touch_resp_t ) ,
                "::" , stringify ! ( v ) ));
}
impl Clone for lcb_touch_resp_t {
    fn clone(&self) -> Self { *self }
}
pub type lcb_touch_callback =
    ::std::option::Option<unsafe extern "C" fn(instance: lcb_t,
                                               cookie:
                                                   *const ::std::os::raw::c_void,
                                               error: lcb_error_t,
                                               resp:
                                                   *const lcb_touch_resp_t)>;
extern "C" {
    pub fn lcb_set_touch_callback(arg1: lcb_t, arg2: lcb_touch_callback)
     -> lcb_touch_callback;
}
extern "C" {
    pub fn lcb_touch(instance: lcb_t, cookie: *const ::std::os::raw::c_void,
                     num: lcb_SIZE, commands: *const *const lcb_touch_cmd_t)
     -> lcb_error_t;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_DURABILITYCMDv0 {
    pub key: *const ::std::os::raw::c_void,
    pub nkey: usize,
    pub hashkey: *const ::std::os::raw::c_void,
    pub nhashkey: lcb_SIZE,
    pub cas: lcb_cas_t,
    pub mutation_token: *const lcb_MUTATION_TOKEN,
}
#[test]
fn bindgen_test_layout_lcb_DURABILITYCMDv0() {
    assert_eq!(::std::mem::size_of::<lcb_DURABILITYCMDv0>() , 48usize , concat
               ! ( "Size of: " , stringify ! ( lcb_DURABILITYCMDv0 ) ));
    assert_eq! (::std::mem::align_of::<lcb_DURABILITYCMDv0>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( lcb_DURABILITYCMDv0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_DURABILITYCMDv0 ) ) . key as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_DURABILITYCMDv0 ) ,
                "::" , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_DURABILITYCMDv0 ) ) . nkey as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_DURABILITYCMDv0 ) ,
                "::" , stringify ! ( nkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_DURABILITYCMDv0 ) ) . hashkey as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_DURABILITYCMDv0 ) ,
                "::" , stringify ! ( hashkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_DURABILITYCMDv0 ) ) . nhashkey as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_DURABILITYCMDv0 ) ,
                "::" , stringify ! ( nhashkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_DURABILITYCMDv0 ) ) . cas as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_DURABILITYCMDv0 ) ,
                "::" , stringify ! ( cas ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_DURABILITYCMDv0 ) ) . mutation_token
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_DURABILITYCMDv0 ) ,
                "::" , stringify ! ( mutation_token ) ));
}
impl Clone for lcb_DURABILITYCMDv0 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_durability_cmd_st {
    pub version: ::std::os::raw::c_int,
    pub v: lcb_durability_cmd_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_durability_cmd_st__bindgen_ty_1 {
    pub v0: __BindgenUnionField<lcb_DURABILITYCMDv0>,
    pub bindgen_union_field: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_lcb_durability_cmd_st__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<lcb_durability_cmd_st__bindgen_ty_1>() ,
               48usize , concat ! (
               "Size of: " , stringify ! ( lcb_durability_cmd_st__bindgen_ty_1
               ) ));
    assert_eq! (::std::mem::align_of::<lcb_durability_cmd_st__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                lcb_durability_cmd_st__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_durability_cmd_st__bindgen_ty_1 ) ) .
                v0 as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_durability_cmd_st__bindgen_ty_1 ) , "::" , stringify ! (
                v0 ) ));
}
impl Clone for lcb_durability_cmd_st__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_lcb_durability_cmd_st() {
    assert_eq!(::std::mem::size_of::<lcb_durability_cmd_st>() , 56usize ,
               concat ! ( "Size of: " , stringify ! ( lcb_durability_cmd_st )
               ));
    assert_eq! (::std::mem::align_of::<lcb_durability_cmd_st>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( lcb_durability_cmd_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_durability_cmd_st ) ) . version as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_durability_cmd_st )
                , "::" , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_durability_cmd_st ) ) . v as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_durability_cmd_st )
                , "::" , stringify ! ( v ) ));
}
impl Clone for lcb_durability_cmd_st {
    fn clone(&self) -> Self { *self }
}
pub type lcb_durability_cmd_t = lcb_durability_cmd_st;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_DURABILITYRESPv0 {
    pub key: *const ::std::os::raw::c_void,
    pub nkey: lcb_SIZE,
    pub err: lcb_error_t,
    pub cas: lcb_cas_t,
    pub persisted_master: ::std::os::raw::c_uchar,
    pub exists_master: ::std::os::raw::c_uchar,
    pub npersisted: ::std::os::raw::c_uchar,
    pub nreplicated: ::std::os::raw::c_uchar,
    pub nresponses: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_lcb_DURABILITYRESPv0() {
    assert_eq!(::std::mem::size_of::<lcb_DURABILITYRESPv0>() , 40usize ,
               concat ! ( "Size of: " , stringify ! ( lcb_DURABILITYRESPv0 )
               ));
    assert_eq! (::std::mem::align_of::<lcb_DURABILITYRESPv0>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( lcb_DURABILITYRESPv0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_DURABILITYRESPv0 ) ) . key as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_DURABILITYRESPv0 )
                , "::" , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_DURABILITYRESPv0 ) ) . nkey as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_DURABILITYRESPv0 )
                , "::" , stringify ! ( nkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_DURABILITYRESPv0 ) ) . err as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_DURABILITYRESPv0 )
                , "::" , stringify ! ( err ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_DURABILITYRESPv0 ) ) . cas as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_DURABILITYRESPv0 )
                , "::" , stringify ! ( cas ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_DURABILITYRESPv0 ) ) .
                persisted_master as * const _ as usize } , 32usize , concat !
                (
                "Alignment of field: " , stringify ! ( lcb_DURABILITYRESPv0 )
                , "::" , stringify ! ( persisted_master ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_DURABILITYRESPv0 ) ) . exists_master
                as * const _ as usize } , 33usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_DURABILITYRESPv0 )
                , "::" , stringify ! ( exists_master ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_DURABILITYRESPv0 ) ) . npersisted as
                * const _ as usize } , 34usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_DURABILITYRESPv0 )
                , "::" , stringify ! ( npersisted ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_DURABILITYRESPv0 ) ) . nreplicated as
                * const _ as usize } , 35usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_DURABILITYRESPv0 )
                , "::" , stringify ! ( nreplicated ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_DURABILITYRESPv0 ) ) . nresponses as
                * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_DURABILITYRESPv0 )
                , "::" , stringify ! ( nresponses ) ));
}
impl Clone for lcb_DURABILITYRESPv0 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_durability_resp_st {
    pub version: ::std::os::raw::c_int,
    pub v: lcb_durability_resp_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_durability_resp_st__bindgen_ty_1 {
    pub v0: __BindgenUnionField<lcb_DURABILITYRESPv0>,
    pub bindgen_union_field: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_lcb_durability_resp_st__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<lcb_durability_resp_st__bindgen_ty_1>() ,
               40usize , concat ! (
               "Size of: " , stringify ! (
               lcb_durability_resp_st__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<lcb_durability_resp_st__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                lcb_durability_resp_st__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_durability_resp_st__bindgen_ty_1 ) )
                . v0 as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_durability_resp_st__bindgen_ty_1 ) , "::" , stringify ! (
                v0 ) ));
}
impl Clone for lcb_durability_resp_st__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_lcb_durability_resp_st() {
    assert_eq!(::std::mem::size_of::<lcb_durability_resp_st>() , 48usize ,
               concat ! ( "Size of: " , stringify ! ( lcb_durability_resp_st )
               ));
    assert_eq! (::std::mem::align_of::<lcb_durability_resp_st>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( lcb_durability_resp_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_durability_resp_st ) ) . version as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_durability_resp_st
                ) , "::" , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_durability_resp_st ) ) . v as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_durability_resp_st
                ) , "::" , stringify ! ( v ) ));
}
impl Clone for lcb_durability_resp_st {
    fn clone(&self) -> Self { *self }
}
pub type lcb_durability_resp_t = lcb_durability_resp_st;
extern "C" {
    pub fn lcb_durability_poll(instance: lcb_t,
                               cookie: *const ::std::os::raw::c_void,
                               options: *const lcb_durability_opts_t,
                               ncmds: lcb_SIZE,
                               cmds: *const *const lcb_durability_cmd_t)
     -> lcb_error_t;
}
pub type lcb_durability_callback =
    ::std::option::Option<unsafe extern "C" fn(instance: lcb_t,
                                               cookie:
                                                   *const ::std::os::raw::c_void,
                                               err: lcb_error_t,
                                               res:
                                                   *const lcb_durability_resp_t)>;
extern "C" {
    pub fn lcb_set_durability_callback(arg1: lcb_t,
                                       arg2: lcb_durability_callback)
     -> lcb_durability_callback;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_STATSCMDv0 {
    pub name: *const ::std::os::raw::c_void,
    pub nname: lcb_SIZE,
}
#[test]
fn bindgen_test_layout_lcb_STATSCMDv0() {
    assert_eq!(::std::mem::size_of::<lcb_STATSCMDv0>() , 16usize , concat ! (
               "Size of: " , stringify ! ( lcb_STATSCMDv0 ) ));
    assert_eq! (::std::mem::align_of::<lcb_STATSCMDv0>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_STATSCMDv0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_STATSCMDv0 ) ) . name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_STATSCMDv0 ) , "::"
                , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_STATSCMDv0 ) ) . nname as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_STATSCMDv0 ) , "::"
                , stringify ! ( nname ) ));
}
impl Clone for lcb_STATSCMDv0 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_server_stats_cmd_st {
    pub version: ::std::os::raw::c_int,
    pub v: lcb_server_stats_cmd_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_server_stats_cmd_st__bindgen_ty_1 {
    pub v0: __BindgenUnionField<lcb_STATSCMDv0>,
    pub bindgen_union_field: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_lcb_server_stats_cmd_st__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<lcb_server_stats_cmd_st__bindgen_ty_1>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               lcb_server_stats_cmd_st__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<lcb_server_stats_cmd_st__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                lcb_server_stats_cmd_st__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_server_stats_cmd_st__bindgen_ty_1 ) )
                . v0 as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_server_stats_cmd_st__bindgen_ty_1 ) , "::" , stringify ! (
                v0 ) ));
}
impl Clone for lcb_server_stats_cmd_st__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_lcb_server_stats_cmd_st() {
    assert_eq!(::std::mem::size_of::<lcb_server_stats_cmd_st>() , 24usize ,
               concat ! (
               "Size of: " , stringify ! ( lcb_server_stats_cmd_st ) ));
    assert_eq! (::std::mem::align_of::<lcb_server_stats_cmd_st>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( lcb_server_stats_cmd_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_server_stats_cmd_st ) ) . version as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_server_stats_cmd_st
                ) , "::" , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_server_stats_cmd_st ) ) . v as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_server_stats_cmd_st
                ) , "::" , stringify ! ( v ) ));
}
impl Clone for lcb_server_stats_cmd_st {
    fn clone(&self) -> Self { *self }
}
pub type lcb_server_stats_cmd_t = lcb_server_stats_cmd_st;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_STATSRESPv0 {
    pub server_endpoint: *const ::std::os::raw::c_char,
    pub key: *const ::std::os::raw::c_void,
    pub nkey: lcb_SIZE,
    pub bytes: *const ::std::os::raw::c_void,
    pub nbytes: lcb_SIZE,
}
#[test]
fn bindgen_test_layout_lcb_STATSRESPv0() {
    assert_eq!(::std::mem::size_of::<lcb_STATSRESPv0>() , 40usize , concat ! (
               "Size of: " , stringify ! ( lcb_STATSRESPv0 ) ));
    assert_eq! (::std::mem::align_of::<lcb_STATSRESPv0>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( lcb_STATSRESPv0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_STATSRESPv0 ) ) . server_endpoint as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_STATSRESPv0 ) ,
                "::" , stringify ! ( server_endpoint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_STATSRESPv0 ) ) . key as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_STATSRESPv0 ) ,
                "::" , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_STATSRESPv0 ) ) . nkey as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_STATSRESPv0 ) ,
                "::" , stringify ! ( nkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_STATSRESPv0 ) ) . bytes as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_STATSRESPv0 ) ,
                "::" , stringify ! ( bytes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_STATSRESPv0 ) ) . nbytes as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_STATSRESPv0 ) ,
                "::" , stringify ! ( nbytes ) ));
}
impl Clone for lcb_STATSRESPv0 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_server_stat_resp_st {
    pub version: ::std::os::raw::c_int,
    pub v: lcb_server_stat_resp_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_server_stat_resp_st__bindgen_ty_1 {
    pub v0: __BindgenUnionField<lcb_STATSRESPv0>,
    pub bindgen_union_field: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_lcb_server_stat_resp_st__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<lcb_server_stat_resp_st__bindgen_ty_1>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               lcb_server_stat_resp_st__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<lcb_server_stat_resp_st__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                lcb_server_stat_resp_st__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_server_stat_resp_st__bindgen_ty_1 ) )
                . v0 as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_server_stat_resp_st__bindgen_ty_1 ) , "::" , stringify ! (
                v0 ) ));
}
impl Clone for lcb_server_stat_resp_st__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_lcb_server_stat_resp_st() {
    assert_eq!(::std::mem::size_of::<lcb_server_stat_resp_st>() , 48usize ,
               concat ! (
               "Size of: " , stringify ! ( lcb_server_stat_resp_st ) ));
    assert_eq! (::std::mem::align_of::<lcb_server_stat_resp_st>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( lcb_server_stat_resp_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_server_stat_resp_st ) ) . version as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_server_stat_resp_st
                ) , "::" , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_server_stat_resp_st ) ) . v as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_server_stat_resp_st
                ) , "::" , stringify ! ( v ) ));
}
impl Clone for lcb_server_stat_resp_st {
    fn clone(&self) -> Self { *self }
}
pub type lcb_server_stat_resp_t = lcb_server_stat_resp_st;
pub type lcb_stat_callback =
    ::std::option::Option<unsafe extern "C" fn(instance: lcb_t,
                                               cookie:
                                                   *const ::std::os::raw::c_void,
                                               error: lcb_error_t,
                                               resp:
                                                   *const lcb_server_stat_resp_t)>;
extern "C" {
    pub fn lcb_set_stat_callback(arg1: lcb_t, arg2: lcb_stat_callback)
     -> lcb_stat_callback;
}
extern "C" {
    pub fn lcb_server_stats(instance: lcb_t,
                            command_cookie: *const ::std::os::raw::c_void,
                            num: lcb_SIZE,
                            commands: *const *const lcb_server_stats_cmd_t)
     -> lcb_error_t;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_server_version_cmd_st {
    pub version: ::std::os::raw::c_int,
    pub v: lcb_server_version_cmd_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_server_version_cmd_st__bindgen_ty_1 {
    pub v0: __BindgenUnionField<lcb_server_version_cmd_st__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: u64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_server_version_cmd_st__bindgen_ty_1__bindgen_ty_1 {
    pub notused: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_lcb_server_version_cmd_st__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<lcb_server_version_cmd_st__bindgen_ty_1__bindgen_ty_1>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               lcb_server_version_cmd_st__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<lcb_server_version_cmd_st__bindgen_ty_1__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                lcb_server_version_cmd_st__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                lcb_server_version_cmd_st__bindgen_ty_1__bindgen_ty_1 ) ) .
                notused as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_server_version_cmd_st__bindgen_ty_1__bindgen_ty_1 ) , "::"
                , stringify ! ( notused ) ));
}
impl Clone for lcb_server_version_cmd_st__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_lcb_server_version_cmd_st__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<lcb_server_version_cmd_st__bindgen_ty_1>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               lcb_server_version_cmd_st__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<lcb_server_version_cmd_st__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                lcb_server_version_cmd_st__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_server_version_cmd_st__bindgen_ty_1 )
                ) . v0 as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_server_version_cmd_st__bindgen_ty_1 ) , "::" , stringify !
                ( v0 ) ));
}
impl Clone for lcb_server_version_cmd_st__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_lcb_server_version_cmd_st() {
    assert_eq!(::std::mem::size_of::<lcb_server_version_cmd_st>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( lcb_server_version_cmd_st ) ));
    assert_eq! (::std::mem::align_of::<lcb_server_version_cmd_st>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( lcb_server_version_cmd_st )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_server_version_cmd_st ) ) . version
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_server_version_cmd_st ) , "::" , stringify ! ( version )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_server_version_cmd_st ) ) . v as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_server_version_cmd_st ) , "::" , stringify ! ( v ) ));
}
impl Clone for lcb_server_version_cmd_st {
    fn clone(&self) -> Self { *self }
}
pub type lcb_server_version_cmd_t = lcb_server_version_cmd_st;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_server_version_resp_st {
    pub version: ::std::os::raw::c_int,
    pub v: lcb_server_version_resp_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_server_version_resp_st__bindgen_ty_1 {
    pub v0: __BindgenUnionField<lcb_server_version_resp_st__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: [u64; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_server_version_resp_st__bindgen_ty_1__bindgen_ty_1 {
    pub server_endpoint: *const ::std::os::raw::c_char,
    pub vstring: *const ::std::os::raw::c_char,
    pub nvstring: lcb_SIZE,
}
#[test]
fn bindgen_test_layout_lcb_server_version_resp_st__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<lcb_server_version_resp_st__bindgen_ty_1__bindgen_ty_1>()
               , 24usize , concat ! (
               "Size of: " , stringify ! (
               lcb_server_version_resp_st__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<lcb_server_version_resp_st__bindgen_ty_1__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                lcb_server_version_resp_st__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                lcb_server_version_resp_st__bindgen_ty_1__bindgen_ty_1 ) ) .
                server_endpoint as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_server_version_resp_st__bindgen_ty_1__bindgen_ty_1 ) ,
                "::" , stringify ! ( server_endpoint ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                lcb_server_version_resp_st__bindgen_ty_1__bindgen_ty_1 ) ) .
                vstring as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_server_version_resp_st__bindgen_ty_1__bindgen_ty_1 ) ,
                "::" , stringify ! ( vstring ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                lcb_server_version_resp_st__bindgen_ty_1__bindgen_ty_1 ) ) .
                nvstring as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_server_version_resp_st__bindgen_ty_1__bindgen_ty_1 ) ,
                "::" , stringify ! ( nvstring ) ));
}
impl Clone for lcb_server_version_resp_st__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_lcb_server_version_resp_st__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<lcb_server_version_resp_st__bindgen_ty_1>()
               , 24usize , concat ! (
               "Size of: " , stringify ! (
               lcb_server_version_resp_st__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<lcb_server_version_resp_st__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                lcb_server_version_resp_st__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const lcb_server_version_resp_st__bindgen_ty_1 ) )
                . v0 as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_server_version_resp_st__bindgen_ty_1 ) , "::" , stringify
                ! ( v0 ) ));
}
impl Clone for lcb_server_version_resp_st__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_lcb_server_version_resp_st() {
    assert_eq!(::std::mem::size_of::<lcb_server_version_resp_st>() , 32usize ,
               concat ! (
               "Size of: " , stringify ! ( lcb_server_version_resp_st ) ));
    assert_eq! (::std::mem::align_of::<lcb_server_version_resp_st>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( lcb_server_version_resp_st )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_server_version_resp_st ) ) . version
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_server_version_resp_st ) , "::" , stringify ! ( version )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_server_version_resp_st ) ) . v as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_server_version_resp_st ) , "::" , stringify ! ( v ) ));
}
impl Clone for lcb_server_version_resp_st {
    fn clone(&self) -> Self { *self }
}
pub type lcb_server_version_resp_t = lcb_server_version_resp_st;
extern "C" {
    pub fn lcb_server_versions(instance: lcb_t,
                               command_cookie: *const ::std::os::raw::c_void,
                               num: lcb_SIZE,
                               commands:
                                   *const *const lcb_server_version_cmd_t)
     -> lcb_error_t;
}
pub type lcb_version_callback =
    ::std::option::Option<unsafe extern "C" fn(instance: lcb_t,
                                               cookie:
                                                   *const ::std::os::raw::c_void,
                                               error: lcb_error_t,
                                               resp:
                                                   *const lcb_server_version_resp_t)>;
extern "C" {
    pub fn lcb_set_version_callback(arg1: lcb_t, arg2: lcb_version_callback)
     -> lcb_version_callback;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_VERBOSITYCMDv0 {
    pub server: *const ::std::os::raw::c_char,
    pub level: lcb_verbosity_level_t,
}
#[test]
fn bindgen_test_layout_lcb_VERBOSITYCMDv0() {
    assert_eq!(::std::mem::size_of::<lcb_VERBOSITYCMDv0>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( lcb_VERBOSITYCMDv0 ) ));
    assert_eq! (::std::mem::align_of::<lcb_VERBOSITYCMDv0>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( lcb_VERBOSITYCMDv0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_VERBOSITYCMDv0 ) ) . server as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_VERBOSITYCMDv0 ) ,
                "::" , stringify ! ( server ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_VERBOSITYCMDv0 ) ) . level as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_VERBOSITYCMDv0 ) ,
                "::" , stringify ! ( level ) ));
}
impl Clone for lcb_VERBOSITYCMDv0 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_verbosity_cmd_st {
    pub version: ::std::os::raw::c_int,
    pub v: lcb_verbosity_cmd_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_verbosity_cmd_st__bindgen_ty_1 {
    pub v0: __BindgenUnionField<lcb_VERBOSITYCMDv0>,
    pub bindgen_union_field: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_lcb_verbosity_cmd_st__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<lcb_verbosity_cmd_st__bindgen_ty_1>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( lcb_verbosity_cmd_st__bindgen_ty_1
               ) ));
    assert_eq! (::std::mem::align_of::<lcb_verbosity_cmd_st__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                lcb_verbosity_cmd_st__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_verbosity_cmd_st__bindgen_ty_1 ) ) .
                v0 as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_verbosity_cmd_st__bindgen_ty_1 ) , "::" , stringify ! ( v0
                ) ));
}
impl Clone for lcb_verbosity_cmd_st__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_lcb_verbosity_cmd_st() {
    assert_eq!(::std::mem::size_of::<lcb_verbosity_cmd_st>() , 24usize ,
               concat ! ( "Size of: " , stringify ! ( lcb_verbosity_cmd_st )
               ));
    assert_eq! (::std::mem::align_of::<lcb_verbosity_cmd_st>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( lcb_verbosity_cmd_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_verbosity_cmd_st ) ) . version as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_verbosity_cmd_st )
                , "::" , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_verbosity_cmd_st ) ) . v as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_verbosity_cmd_st )
                , "::" , stringify ! ( v ) ));
}
impl Clone for lcb_verbosity_cmd_st {
    fn clone(&self) -> Self { *self }
}
pub type lcb_verbosity_cmd_t = lcb_verbosity_cmd_st;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_verbosity_resp_st {
    pub version: ::std::os::raw::c_int,
    pub v: lcb_verbosity_resp_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_verbosity_resp_st__bindgen_ty_1 {
    pub v0: __BindgenUnionField<lcb_verbosity_resp_st__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: u64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_verbosity_resp_st__bindgen_ty_1__bindgen_ty_1 {
    pub server_endpoint: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_lcb_verbosity_resp_st__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<lcb_verbosity_resp_st__bindgen_ty_1__bindgen_ty_1>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               lcb_verbosity_resp_st__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<lcb_verbosity_resp_st__bindgen_ty_1__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                lcb_verbosity_resp_st__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const lcb_verbosity_resp_st__bindgen_ty_1__bindgen_ty_1
                ) ) . server_endpoint as * const _ as usize } , 0usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                lcb_verbosity_resp_st__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( server_endpoint ) ));
}
impl Clone for lcb_verbosity_resp_st__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_lcb_verbosity_resp_st__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<lcb_verbosity_resp_st__bindgen_ty_1>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( lcb_verbosity_resp_st__bindgen_ty_1
               ) ));
    assert_eq! (::std::mem::align_of::<lcb_verbosity_resp_st__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                lcb_verbosity_resp_st__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_verbosity_resp_st__bindgen_ty_1 ) ) .
                v0 as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_verbosity_resp_st__bindgen_ty_1 ) , "::" , stringify ! (
                v0 ) ));
}
impl Clone for lcb_verbosity_resp_st__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_lcb_verbosity_resp_st() {
    assert_eq!(::std::mem::size_of::<lcb_verbosity_resp_st>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( lcb_verbosity_resp_st )
               ));
    assert_eq! (::std::mem::align_of::<lcb_verbosity_resp_st>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( lcb_verbosity_resp_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_verbosity_resp_st ) ) . version as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_verbosity_resp_st )
                , "::" , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_verbosity_resp_st ) ) . v as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_verbosity_resp_st )
                , "::" , stringify ! ( v ) ));
}
impl Clone for lcb_verbosity_resp_st {
    fn clone(&self) -> Self { *self }
}
pub type lcb_verbosity_resp_t = lcb_verbosity_resp_st;
extern "C" {
    pub fn lcb_set_verbosity(instance: lcb_t,
                             command_cookie: *const ::std::os::raw::c_void,
                             num: lcb_SIZE,
                             commands: *const *const lcb_verbosity_cmd_t)
     -> lcb_error_t;
}
pub type lcb_verbosity_callback =
    ::std::option::Option<unsafe extern "C" fn(instance: lcb_t,
                                               cookie:
                                                   *const ::std::os::raw::c_void,
                                               error: lcb_error_t,
                                               resp:
                                                   *const lcb_verbosity_resp_t)>;
extern "C" {
    pub fn lcb_set_verbosity_callback(arg1: lcb_t,
                                      arg2: lcb_verbosity_callback)
     -> lcb_verbosity_callback;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_flush_cmd_st {
    pub version: ::std::os::raw::c_int,
    pub v: lcb_flush_cmd_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_flush_cmd_st__bindgen_ty_1 {
    pub v0: __BindgenUnionField<lcb_flush_cmd_st__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_flush_cmd_st__bindgen_ty_1__bindgen_ty_1 {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_lcb_flush_cmd_st__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<lcb_flush_cmd_st__bindgen_ty_1__bindgen_ty_1>()
               , 4usize , concat ! (
               "Size of: " , stringify ! (
               lcb_flush_cmd_st__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<lcb_flush_cmd_st__bindgen_ty_1__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                lcb_flush_cmd_st__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const lcb_flush_cmd_st__bindgen_ty_1__bindgen_ty_1
                ) ) . unused as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_flush_cmd_st__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( unused ) ));
}
impl Clone for lcb_flush_cmd_st__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_lcb_flush_cmd_st__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<lcb_flush_cmd_st__bindgen_ty_1>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( lcb_flush_cmd_st__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<lcb_flush_cmd_st__bindgen_ty_1>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( lcb_flush_cmd_st__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_flush_cmd_st__bindgen_ty_1 ) ) . v0
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_flush_cmd_st__bindgen_ty_1 ) , "::" , stringify ! ( v0 )
                ));
}
impl Clone for lcb_flush_cmd_st__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_lcb_flush_cmd_st() {
    assert_eq!(::std::mem::size_of::<lcb_flush_cmd_st>() , 8usize , concat ! (
               "Size of: " , stringify ! ( lcb_flush_cmd_st ) ));
    assert_eq! (::std::mem::align_of::<lcb_flush_cmd_st>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( lcb_flush_cmd_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_flush_cmd_st ) ) . version as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_flush_cmd_st ) ,
                "::" , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_flush_cmd_st ) ) . v as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_flush_cmd_st ) ,
                "::" , stringify ! ( v ) ));
}
impl Clone for lcb_flush_cmd_st {
    fn clone(&self) -> Self { *self }
}
pub type lcb_flush_cmd_t = lcb_flush_cmd_st;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_flush_resp_st {
    pub version: ::std::os::raw::c_int,
    pub v: lcb_flush_resp_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_flush_resp_st__bindgen_ty_1 {
    pub v0: __BindgenUnionField<lcb_flush_resp_st__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: u64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_flush_resp_st__bindgen_ty_1__bindgen_ty_1 {
    pub server_endpoint: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_lcb_flush_resp_st__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<lcb_flush_resp_st__bindgen_ty_1__bindgen_ty_1>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               lcb_flush_resp_st__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<lcb_flush_resp_st__bindgen_ty_1__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                lcb_flush_resp_st__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const lcb_flush_resp_st__bindgen_ty_1__bindgen_ty_1
                ) ) . server_endpoint as * const _ as usize } , 0usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                lcb_flush_resp_st__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( server_endpoint ) ));
}
impl Clone for lcb_flush_resp_st__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_lcb_flush_resp_st__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<lcb_flush_resp_st__bindgen_ty_1>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( lcb_flush_resp_st__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<lcb_flush_resp_st__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                lcb_flush_resp_st__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_flush_resp_st__bindgen_ty_1 ) ) . v0
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_flush_resp_st__bindgen_ty_1 ) , "::" , stringify ! ( v0 )
                ));
}
impl Clone for lcb_flush_resp_st__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_lcb_flush_resp_st() {
    assert_eq!(::std::mem::size_of::<lcb_flush_resp_st>() , 16usize , concat !
               ( "Size of: " , stringify ! ( lcb_flush_resp_st ) ));
    assert_eq! (::std::mem::align_of::<lcb_flush_resp_st>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( lcb_flush_resp_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_flush_resp_st ) ) . version as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_flush_resp_st ) ,
                "::" , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_flush_resp_st ) ) . v as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_flush_resp_st ) ,
                "::" , stringify ! ( v ) ));
}
impl Clone for lcb_flush_resp_st {
    fn clone(&self) -> Self { *self }
}
pub type lcb_flush_resp_t = lcb_flush_resp_st;
extern "C" {
    pub fn lcb_flush(instance: lcb_t, cookie: *const ::std::os::raw::c_void,
                     num: lcb_SIZE, commands: *const *const lcb_flush_cmd_t)
     -> lcb_error_t;
}
pub type lcb_flush_callback =
    ::std::option::Option<unsafe extern "C" fn(instance: lcb_t,
                                               cookie:
                                                   *const ::std::os::raw::c_void,
                                               error: lcb_error_t,
                                               resp:
                                                   *const lcb_flush_resp_t)>;
extern "C" {
    pub fn lcb_set_flush_callback(arg1: lcb_t, arg2: lcb_flush_callback)
     -> lcb_flush_callback;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_HTTPCMDv0 {
    pub path: *const ::std::os::raw::c_char,
    pub npath: lcb_SIZE,
    pub body: *const ::std::os::raw::c_void,
    pub nbody: lcb_SIZE,
    pub method: lcb_http_method_t,
    pub chunked: ::std::os::raw::c_int,
    pub content_type: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_lcb_HTTPCMDv0() {
    assert_eq!(::std::mem::size_of::<lcb_HTTPCMDv0>() , 48usize , concat ! (
               "Size of: " , stringify ! ( lcb_HTTPCMDv0 ) ));
    assert_eq! (::std::mem::align_of::<lcb_HTTPCMDv0>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_HTTPCMDv0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_HTTPCMDv0 ) ) . path as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_HTTPCMDv0 ) , "::"
                , stringify ! ( path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_HTTPCMDv0 ) ) . npath as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_HTTPCMDv0 ) , "::"
                , stringify ! ( npath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_HTTPCMDv0 ) ) . body as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_HTTPCMDv0 ) , "::"
                , stringify ! ( body ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_HTTPCMDv0 ) ) . nbody as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_HTTPCMDv0 ) , "::"
                , stringify ! ( nbody ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_HTTPCMDv0 ) ) . method as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_HTTPCMDv0 ) , "::"
                , stringify ! ( method ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_HTTPCMDv0 ) ) . chunked as * const _
                as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_HTTPCMDv0 ) , "::"
                , stringify ! ( chunked ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_HTTPCMDv0 ) ) . content_type as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_HTTPCMDv0 ) , "::"
                , stringify ! ( content_type ) ));
}
impl Clone for lcb_HTTPCMDv0 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_HTTPCMDv1 {
    pub path: *const ::std::os::raw::c_char,
    pub npath: lcb_SIZE,
    pub body: *const ::std::os::raw::c_void,
    pub nbody: lcb_SIZE,
    pub method: lcb_http_method_t,
    pub chunked: ::std::os::raw::c_int,
    pub content_type: *const ::std::os::raw::c_char,
    pub host: *const ::std::os::raw::c_char,
    pub username: *const ::std::os::raw::c_char,
    pub password: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_lcb_HTTPCMDv1() {
    assert_eq!(::std::mem::size_of::<lcb_HTTPCMDv1>() , 72usize , concat ! (
               "Size of: " , stringify ! ( lcb_HTTPCMDv1 ) ));
    assert_eq! (::std::mem::align_of::<lcb_HTTPCMDv1>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_HTTPCMDv1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_HTTPCMDv1 ) ) . path as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_HTTPCMDv1 ) , "::"
                , stringify ! ( path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_HTTPCMDv1 ) ) . npath as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_HTTPCMDv1 ) , "::"
                , stringify ! ( npath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_HTTPCMDv1 ) ) . body as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_HTTPCMDv1 ) , "::"
                , stringify ! ( body ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_HTTPCMDv1 ) ) . nbody as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_HTTPCMDv1 ) , "::"
                , stringify ! ( nbody ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_HTTPCMDv1 ) ) . method as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_HTTPCMDv1 ) , "::"
                , stringify ! ( method ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_HTTPCMDv1 ) ) . chunked as * const _
                as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_HTTPCMDv1 ) , "::"
                , stringify ! ( chunked ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_HTTPCMDv1 ) ) . content_type as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_HTTPCMDv1 ) , "::"
                , stringify ! ( content_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_HTTPCMDv1 ) ) . host as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_HTTPCMDv1 ) , "::"
                , stringify ! ( host ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_HTTPCMDv1 ) ) . username as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_HTTPCMDv1 ) , "::"
                , stringify ! ( username ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_HTTPCMDv1 ) ) . password as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_HTTPCMDv1 ) , "::"
                , stringify ! ( password ) ));
}
impl Clone for lcb_HTTPCMDv1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_http_cmd_st {
    pub version: ::std::os::raw::c_int,
    pub v: lcb_http_cmd_st__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_http_cmd_st__bindgen_ty_1 {
    pub v0: __BindgenUnionField<lcb_HTTPCMDv0>,
    pub v1: __BindgenUnionField<lcb_HTTPCMDv1>,
    pub bindgen_union_field: [u64; 9usize],
}
#[test]
fn bindgen_test_layout_lcb_http_cmd_st__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<lcb_http_cmd_st__bindgen_ty_1>() ,
               72usize , concat ! (
               "Size of: " , stringify ! ( lcb_http_cmd_st__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<lcb_http_cmd_st__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_http_cmd_st__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_http_cmd_st__bindgen_ty_1 ) ) . v0 as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_http_cmd_st__bindgen_ty_1 ) , "::" , stringify ! ( v0 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_http_cmd_st__bindgen_ty_1 ) ) . v1 as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_http_cmd_st__bindgen_ty_1 ) , "::" , stringify ! ( v1 )
                ));
}
impl Clone for lcb_http_cmd_st__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_lcb_http_cmd_st() {
    assert_eq!(::std::mem::size_of::<lcb_http_cmd_st>() , 80usize , concat ! (
               "Size of: " , stringify ! ( lcb_http_cmd_st ) ));
    assert_eq! (::std::mem::align_of::<lcb_http_cmd_st>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( lcb_http_cmd_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_http_cmd_st ) ) . version as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_http_cmd_st ) ,
                "::" , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_http_cmd_st ) ) . v as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_http_cmd_st ) ,
                "::" , stringify ! ( v ) ));
}
impl Clone for lcb_http_cmd_st {
    fn clone(&self) -> Self { *self }
}
pub type lcb_http_cmd_t = lcb_http_cmd_st;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_HTTPRESPv0 {
    pub status: lcb_http_status_t,
    pub path: *const ::std::os::raw::c_char,
    pub npath: lcb_SIZE,
    pub headers: *const *const ::std::os::raw::c_char,
    pub bytes: *const ::std::os::raw::c_void,
    pub nbytes: lcb_SIZE,
}
#[test]
fn bindgen_test_layout_lcb_HTTPRESPv0() {
    assert_eq!(::std::mem::size_of::<lcb_HTTPRESPv0>() , 48usize , concat ! (
               "Size of: " , stringify ! ( lcb_HTTPRESPv0 ) ));
    assert_eq! (::std::mem::align_of::<lcb_HTTPRESPv0>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_HTTPRESPv0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_HTTPRESPv0 ) ) . status as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_HTTPRESPv0 ) , "::"
                , stringify ! ( status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_HTTPRESPv0 ) ) . path as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_HTTPRESPv0 ) , "::"
                , stringify ! ( path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_HTTPRESPv0 ) ) . npath as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_HTTPRESPv0 ) , "::"
                , stringify ! ( npath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_HTTPRESPv0 ) ) . headers as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_HTTPRESPv0 ) , "::"
                , stringify ! ( headers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_HTTPRESPv0 ) ) . bytes as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_HTTPRESPv0 ) , "::"
                , stringify ! ( bytes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_HTTPRESPv0 ) ) . nbytes as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_HTTPRESPv0 ) , "::"
                , stringify ! ( nbytes ) ));
}
impl Clone for lcb_HTTPRESPv0 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_http_resp_t {
    pub version: ::std::os::raw::c_int,
    pub v: lcb_http_resp_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_http_resp_t__bindgen_ty_1 {
    pub v0: __BindgenUnionField<lcb_HTTPRESPv0>,
    pub bindgen_union_field: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_lcb_http_resp_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<lcb_http_resp_t__bindgen_ty_1>() ,
               48usize , concat ! (
               "Size of: " , stringify ! ( lcb_http_resp_t__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<lcb_http_resp_t__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_http_resp_t__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_http_resp_t__bindgen_ty_1 ) ) . v0 as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                lcb_http_resp_t__bindgen_ty_1 ) , "::" , stringify ! ( v0 )
                ));
}
impl Clone for lcb_http_resp_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_lcb_http_resp_t() {
    assert_eq!(::std::mem::size_of::<lcb_http_resp_t>() , 56usize , concat ! (
               "Size of: " , stringify ! ( lcb_http_resp_t ) ));
    assert_eq! (::std::mem::align_of::<lcb_http_resp_t>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( lcb_http_resp_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_http_resp_t ) ) . version as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_http_resp_t ) ,
                "::" , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_http_resp_t ) ) . v as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_http_resp_t ) ,
                "::" , stringify ! ( v ) ));
}
impl Clone for lcb_http_resp_t {
    fn clone(&self) -> Self { *self }
}
pub type lcb_http_res_callback =
    ::std::option::Option<unsafe extern "C" fn(request: lcb_http_request_t,
                                               instance: lcb_t,
                                               cookie:
                                                   *const ::std::os::raw::c_void,
                                               error: lcb_error_t,
                                               resp: *const lcb_http_resp_t)>;
pub type lcb_http_data_callback = lcb_http_res_callback;
pub type lcb_http_complete_callback = lcb_http_res_callback;
extern "C" {
    pub fn lcb_set_http_complete_callback(arg1: lcb_t,
                                          arg2: lcb_http_complete_callback)
     -> lcb_http_complete_callback;
}
extern "C" {
    pub fn lcb_set_http_data_callback(arg1: lcb_t,
                                      arg2: lcb_http_data_callback)
     -> lcb_http_data_callback;
}
extern "C" {
    pub fn lcb_make_http_request(instance: lcb_t,
                                 command_cookie:
                                     *const ::std::os::raw::c_void,
                                 type_: lcb_http_type_t,
                                 cmd: *const lcb_http_cmd_t,
                                 request: *mut lcb_http_request_t)
     -> lcb_error_t;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_RESPN1QL {
    pub cookie: *mut ::std::os::raw::c_void,
    pub key: *const ::std::os::raw::c_void,
    pub nkey: lcb_SIZE,
    pub cas: lcb_CAS,
    pub rc: lcb_error_t,
    pub version: lcb_U16,
    pub rflags: lcb_U16,
    pub row: *const ::std::os::raw::c_char,
    pub nrow: usize,
    pub htresp: *const lcb_RESPHTTP,
}
#[test]
fn bindgen_test_layout_lcb_RESPN1QL() {
    assert_eq!(::std::mem::size_of::<lcb_RESPN1QL>() , 64usize , concat ! (
               "Size of: " , stringify ! ( lcb_RESPN1QL ) ));
    assert_eq! (::std::mem::align_of::<lcb_RESPN1QL>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_RESPN1QL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPN1QL ) ) . cookie as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPN1QL ) , "::" ,
                stringify ! ( cookie ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPN1QL ) ) . key as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPN1QL ) , "::" ,
                stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPN1QL ) ) . nkey as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPN1QL ) , "::" ,
                stringify ! ( nkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPN1QL ) ) . cas as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPN1QL ) , "::" ,
                stringify ! ( cas ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPN1QL ) ) . rc as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPN1QL ) , "::" ,
                stringify ! ( rc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPN1QL ) ) . version as * const _
                as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPN1QL ) , "::" ,
                stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPN1QL ) ) . rflags as * const _ as
                usize } , 38usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPN1QL ) , "::" ,
                stringify ! ( rflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPN1QL ) ) . row as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPN1QL ) , "::" ,
                stringify ! ( row ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPN1QL ) ) . nrow as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPN1QL ) , "::" ,
                stringify ! ( nrow ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPN1QL ) ) . htresp as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPN1QL ) , "::" ,
                stringify ! ( htresp ) ));
}
impl Clone for lcb_RESPN1QL {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_CMDN1QL {
    pub cmdflags: lcb_U32,
    pub query: *const ::std::os::raw::c_char,
    pub nquery: usize,
    pub host: *const ::std::os::raw::c_char,
    pub content_type: *const ::std::os::raw::c_char,
    pub callback: lcb_N1QLCALLBACK,
    pub handle: *mut lcb_N1QLHANDLE,
}
#[test]
fn bindgen_test_layout_lcb_CMDN1QL() {
    assert_eq!(::std::mem::size_of::<lcb_CMDN1QL>() , 56usize , concat ! (
               "Size of: " , stringify ! ( lcb_CMDN1QL ) ));
    assert_eq! (::std::mem::align_of::<lcb_CMDN1QL>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_CMDN1QL ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDN1QL ) ) . cmdflags as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDN1QL ) , "::" ,
                stringify ! ( cmdflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDN1QL ) ) . query as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDN1QL ) , "::" ,
                stringify ! ( query ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDN1QL ) ) . nquery as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDN1QL ) , "::" ,
                stringify ! ( nquery ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDN1QL ) ) . host as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDN1QL ) , "::" ,
                stringify ! ( host ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDN1QL ) ) . content_type as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDN1QL ) , "::" ,
                stringify ! ( content_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDN1QL ) ) . callback as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDN1QL ) , "::" ,
                stringify ! ( callback ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDN1QL ) ) . handle as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDN1QL ) , "::" ,
                stringify ! ( handle ) ));
}
impl Clone for lcb_CMDN1QL {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lcb_N1QLREQ {
    _unused: [u8; 0],
}
pub type lcb_N1QLHANDLE = *mut lcb_N1QLREQ;
pub type lcb_N1QLCALLBACK =
    ::std::option::Option<unsafe extern "C" fn(arg1: lcb_t,
                                               arg2: ::std::os::raw::c_int,
                                               arg3: *const lcb_RESPN1QL)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lcb_N1QLPARAMS_st {
    _unused: [u8; 0],
}
pub type lcb_N1QLPARAMS = lcb_N1QLPARAMS_st;
extern "C" {
    pub fn lcb_n1p_new() -> *mut lcb_N1QLPARAMS;
}
extern "C" {
    pub fn lcb_n1p_reset(params: *mut lcb_N1QLPARAMS);
}
extern "C" {
    pub fn lcb_n1p_free(params: *mut lcb_N1QLPARAMS);
}
extern "C" {
    pub fn lcb_n1p_setquery(params: *mut lcb_N1QLPARAMS,
                            qstr: *const ::std::os::raw::c_char, nqstr: usize,
                            type_: ::std::os::raw::c_int) -> lcb_error_t;
}
extern "C" {
    pub fn lcb_n1p_namedparam(params: *mut lcb_N1QLPARAMS,
                              name: *const ::std::os::raw::c_char,
                              n_name: usize,
                              value: *const ::std::os::raw::c_char,
                              n_value: usize) -> lcb_error_t;
}
extern "C" {
    pub fn lcb_n1p_posparam(params: *mut lcb_N1QLPARAMS,
                            value: *const ::std::os::raw::c_char,
                            n_value: usize) -> lcb_error_t;
}
extern "C" {
    pub fn lcb_n1p_setopt(params: *mut lcb_N1QLPARAMS,
                          name: *const ::std::os::raw::c_char, n_name: usize,
                          value: *const ::std::os::raw::c_char,
                          n_value: usize) -> lcb_error_t;
}
extern "C" {
    pub fn lcb_n1p_setconsistency(params: *mut lcb_N1QLPARAMS,
                                  mode: ::std::os::raw::c_int) -> lcb_error_t;
}
extern "C" {
    pub fn lcb_n1p_setconsistent_token(params: *mut lcb_N1QLPARAMS,
                                       keyspace:
                                           *const ::std::os::raw::c_char,
                                       st: *const lcb_MUTATION_TOKEN)
     -> lcb_error_t;
}
extern "C" {
    pub fn lcb_n1p_setconsistent_handle(params: *mut lcb_N1QLPARAMS,
                                        instance: lcb_t) -> lcb_error_t;
}
extern "C" {
    pub fn lcb_n1p_encode(params: *mut lcb_N1QLPARAMS, rc: *mut lcb_error_t)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn lcb_n1p_mkcmd(params: *mut lcb_N1QLPARAMS, cmd: *mut lcb_CMDN1QL)
     -> lcb_error_t;
}
extern "C" {
    pub fn lcb_n1ql_query(instance: lcb_t,
                          cookie: *const ::std::os::raw::c_void,
                          cmd: *const lcb_CMDN1QL) -> lcb_error_t;
}
extern "C" {
    pub fn lcb_n1ql_cancel(instance: lcb_t, handle: lcb_N1QLHANDLE);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_RESPFTS {
    pub cookie: *mut ::std::os::raw::c_void,
    pub key: *const ::std::os::raw::c_void,
    pub nkey: lcb_SIZE,
    pub cas: lcb_CAS,
    pub rc: lcb_error_t,
    pub version: lcb_U16,
    pub rflags: lcb_U16,
    pub row: *const ::std::os::raw::c_char,
    pub nrow: usize,
    pub htresp: *const lcb_RESPHTTP,
}
#[test]
fn bindgen_test_layout_lcb_RESPFTS() {
    assert_eq!(::std::mem::size_of::<lcb_RESPFTS>() , 64usize , concat ! (
               "Size of: " , stringify ! ( lcb_RESPFTS ) ));
    assert_eq! (::std::mem::align_of::<lcb_RESPFTS>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_RESPFTS ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPFTS ) ) . cookie as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPFTS ) , "::" ,
                stringify ! ( cookie ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPFTS ) ) . key as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPFTS ) , "::" ,
                stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPFTS ) ) . nkey as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPFTS ) , "::" ,
                stringify ! ( nkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPFTS ) ) . cas as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPFTS ) , "::" ,
                stringify ! ( cas ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPFTS ) ) . rc as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPFTS ) , "::" ,
                stringify ! ( rc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPFTS ) ) . version as * const _ as
                usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPFTS ) , "::" ,
                stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPFTS ) ) . rflags as * const _ as
                usize } , 38usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPFTS ) , "::" ,
                stringify ! ( rflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPFTS ) ) . row as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPFTS ) , "::" ,
                stringify ! ( row ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPFTS ) ) . nrow as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPFTS ) , "::" ,
                stringify ! ( nrow ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPFTS ) ) . htresp as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPFTS ) , "::" ,
                stringify ! ( htresp ) ));
}
impl Clone for lcb_RESPFTS {
    fn clone(&self) -> Self { *self }
}
pub type lcb_FTSCALLBACK =
    ::std::option::Option<unsafe extern "C" fn(arg1: lcb_t,
                                               arg2: ::std::os::raw::c_int,
                                               arg3: *const lcb_RESPFTS)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lcb_FTSREQ {
    _unused: [u8; 0],
}
pub type lcb_FTSHANDLE = *mut lcb_FTSREQ;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_CMDFTS {
    pub cmdflags: lcb_U32,
    pub query: *const ::std::os::raw::c_char,
    pub nquery: usize,
    pub callback: lcb_FTSCALLBACK,
    pub handle: *mut lcb_FTSHANDLE,
}
#[test]
fn bindgen_test_layout_lcb_CMDFTS() {
    assert_eq!(::std::mem::size_of::<lcb_CMDFTS>() , 40usize , concat ! (
               "Size of: " , stringify ! ( lcb_CMDFTS ) ));
    assert_eq! (::std::mem::align_of::<lcb_CMDFTS>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lcb_CMDFTS ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDFTS ) ) . cmdflags as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDFTS ) , "::" ,
                stringify ! ( cmdflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDFTS ) ) . query as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDFTS ) , "::" ,
                stringify ! ( query ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDFTS ) ) . nquery as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDFTS ) , "::" ,
                stringify ! ( nquery ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDFTS ) ) . callback as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDFTS ) , "::" ,
                stringify ! ( callback ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDFTS ) ) . handle as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDFTS ) , "::" ,
                stringify ! ( handle ) ));
}
impl Clone for lcb_CMDFTS {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn lcb_fts_query(instance: lcb_t,
                         cookie: *const ::std::os::raw::c_void,
                         cmd: *const lcb_CMDFTS) -> lcb_error_t;
}
extern "C" {
    pub fn lcb_fts_cancel(arg1: lcb_t, arg2: lcb_FTSHANDLE);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lcbview_REQUEST_st {
    _unused: [u8; 0],
}
pub type lcb_VIEWHANDLE = *mut lcbview_REQUEST_st;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_RESPVIEW_st {
    pub cookie: *mut ::std::os::raw::c_void,
    pub key: *const ::std::os::raw::c_void,
    pub nkey: lcb_SIZE,
    pub cas: lcb_CAS,
    pub rc: lcb_error_t,
    pub version: lcb_U16,
    pub rflags: lcb_U16,
    pub docid: *const ::std::os::raw::c_char,
    pub ndocid: usize,
    pub value: *const ::std::os::raw::c_char,
    pub nvalue: usize,
    pub geometry: *const ::std::os::raw::c_char,
    pub ngeometry: usize,
    pub htresp: *const lcb_RESPHTTP,
    pub docresp: *const lcb_RESPGET,
}
#[test]
fn bindgen_test_layout_lcb_RESPVIEW_st() {
    assert_eq!(::std::mem::size_of::<lcb_RESPVIEW_st>() , 104usize , concat !
               ( "Size of: " , stringify ! ( lcb_RESPVIEW_st ) ));
    assert_eq! (::std::mem::align_of::<lcb_RESPVIEW_st>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( lcb_RESPVIEW_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPVIEW_st ) ) . cookie as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPVIEW_st ) ,
                "::" , stringify ! ( cookie ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPVIEW_st ) ) . key as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPVIEW_st ) ,
                "::" , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPVIEW_st ) ) . nkey as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPVIEW_st ) ,
                "::" , stringify ! ( nkey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPVIEW_st ) ) . cas as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPVIEW_st ) ,
                "::" , stringify ! ( cas ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPVIEW_st ) ) . rc as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPVIEW_st ) ,
                "::" , stringify ! ( rc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPVIEW_st ) ) . version as * const
                _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPVIEW_st ) ,
                "::" , stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPVIEW_st ) ) . rflags as * const _
                as usize } , 38usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPVIEW_st ) ,
                "::" , stringify ! ( rflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPVIEW_st ) ) . docid as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPVIEW_st ) ,
                "::" , stringify ! ( docid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPVIEW_st ) ) . ndocid as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPVIEW_st ) ,
                "::" , stringify ! ( ndocid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPVIEW_st ) ) . value as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPVIEW_st ) ,
                "::" , stringify ! ( value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPVIEW_st ) ) . nvalue as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPVIEW_st ) ,
                "::" , stringify ! ( nvalue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPVIEW_st ) ) . geometry as * const
                _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPVIEW_st ) ,
                "::" , stringify ! ( geometry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPVIEW_st ) ) . ngeometry as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPVIEW_st ) ,
                "::" , stringify ! ( ngeometry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPVIEW_st ) ) . htresp as * const _
                as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPVIEW_st ) ,
                "::" , stringify ! ( htresp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_RESPVIEW_st ) ) . docresp as * const
                _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_RESPVIEW_st ) ,
                "::" , stringify ! ( docresp ) ));
}
impl Clone for lcb_RESPVIEW_st {
    fn clone(&self) -> Self { *self }
}
pub type lcb_RESPVIEWQUERY = lcb_RESPVIEW_st;
pub type lcb_VIEWQUERYCALLBACK =
    ::std::option::Option<unsafe extern "C" fn(instance: lcb_t,
                                               cbtype: ::std::os::raw::c_int,
                                               row:
                                                   *const lcb_RESPVIEWQUERY)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lcb_CMDVIEWQUERY {
    pub cmdflags: lcb_U32,
    pub ddoc: *const ::std::os::raw::c_char,
    pub nddoc: usize,
    pub view: *const ::std::os::raw::c_char,
    pub nview: usize,
    pub optstr: *const ::std::os::raw::c_char,
    pub noptstr: usize,
    pub postdata: *const ::std::os::raw::c_char,
    pub npostdata: usize,
    pub docs_concurrent_max: ::std::os::raw::c_uint,
    pub callback: lcb_VIEWQUERYCALLBACK,
    pub handle: *mut lcb_VIEWHANDLE,
}
#[test]
fn bindgen_test_layout_lcb_CMDVIEWQUERY() {
    assert_eq!(::std::mem::size_of::<lcb_CMDVIEWQUERY>() , 96usize , concat !
               ( "Size of: " , stringify ! ( lcb_CMDVIEWQUERY ) ));
    assert_eq! (::std::mem::align_of::<lcb_CMDVIEWQUERY>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( lcb_CMDVIEWQUERY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDVIEWQUERY ) ) . cmdflags as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDVIEWQUERY ) ,
                "::" , stringify ! ( cmdflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDVIEWQUERY ) ) . ddoc as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDVIEWQUERY ) ,
                "::" , stringify ! ( ddoc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDVIEWQUERY ) ) . nddoc as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDVIEWQUERY ) ,
                "::" , stringify ! ( nddoc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDVIEWQUERY ) ) . view as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDVIEWQUERY ) ,
                "::" , stringify ! ( view ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDVIEWQUERY ) ) . nview as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDVIEWQUERY ) ,
                "::" , stringify ! ( nview ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDVIEWQUERY ) ) . optstr as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDVIEWQUERY ) ,
                "::" , stringify ! ( optstr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDVIEWQUERY ) ) . noptstr as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDVIEWQUERY ) ,
                "::" , stringify ! ( noptstr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDVIEWQUERY ) ) . postdata as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDVIEWQUERY ) ,
                "::" , stringify ! ( postdata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDVIEWQUERY ) ) . npostdata as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDVIEWQUERY ) ,
                "::" , stringify ! ( npostdata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDVIEWQUERY ) ) .
                docs_concurrent_max as * const _ as usize } , 72usize , concat
                ! (
                "Alignment of field: " , stringify ! ( lcb_CMDVIEWQUERY ) ,
                "::" , stringify ! ( docs_concurrent_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDVIEWQUERY ) ) . callback as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDVIEWQUERY ) ,
                "::" , stringify ! ( callback ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lcb_CMDVIEWQUERY ) ) . handle as * const
                _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( lcb_CMDVIEWQUERY ) ,
                "::" , stringify ! ( handle ) ));
}
impl Clone for lcb_CMDVIEWQUERY {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn lcb_view_query(instance: lcb_t,
                          cookie: *const ::std::os::raw::c_void,
                          cmd: *const lcb_CMDVIEWQUERY) -> lcb_error_t;
}
extern "C" {
    pub fn lcb_view_query_initcmd(vq: *mut lcb_CMDVIEWQUERY,
                                  design: *const ::std::os::raw::c_char,
                                  view: *const ::std::os::raw::c_char,
                                  options: *const ::std::os::raw::c_char,
                                  callback: lcb_VIEWQUERYCALLBACK);
}
extern "C" {
    pub fn lcb_view_cancel(instance: lcb_t, handle: lcb_VIEWHANDLE);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(::std::mem::size_of::<__va_list_tag>() , 24usize , concat ! (
               "Size of: " , stringify ! ( __va_list_tag ) ));
    assert_eq! (::std::mem::align_of::<__va_list_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __va_list_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . gp_offset as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( gp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . fp_offset as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( fp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . overflow_arg_area as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( overflow_arg_area ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . reg_save_area as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( reg_save_area ) ));
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self { *self }
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
